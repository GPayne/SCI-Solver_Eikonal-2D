#line 1 "CUDA_kernels.cudafe1.cpp"
#line 1 "d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu"
#line 168 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
#pragma pack ( push, 8 )
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vadefs.h"
#pragma pack ( push, 8 )
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vadefs.h"
extern "C" { typedef unsigned __w64 uintptr_t; }
#line 61 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vadefs.h"
extern "C" { typedef char *va_list; }
#line 151 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vadefs.h"
#pragma pack ( pop )
#line 490 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
typedef unsigned size_t; 
#line 1 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"

























































#line 59 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"






#line 66 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"



#line 70 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"
























#line 95 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"










#line 106 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"

#line 1 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"




















































#line 1 "c:\\cuda\\include\\host_defines.h"










































#line 44 "c:\\cuda\\include\\host_defines.h"

















#line 62 "c:\\cuda\\include\\host_defines.h"










#line 73 "c:\\cuda\\include\\host_defines.h"






















#line 96 "c:\\cuda\\include\\host_defines.h"






#line 103 "c:\\cuda\\include\\host_defines.h"



#line 107 "c:\\cuda\\include\\host_defines.h"






#line 115 "c:\\cuda\\include\\host_defines.h"



#line 119 "c:\\cuda\\include\\host_defines.h"














#line 134 "c:\\cuda\\include\\host_defines.h"
#line 54 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
#line 1 "c:\\cuda\\include\\builtin_types.h"









































#line 1 "c:\\cuda\\include\\device_types.h"













































enum cudaRoundMode
{
  cudaRoundNearest,
  cudaRoundZero,
  cudaRoundPosInf,
  cudaRoundMinInf
};

#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"














































































#line 80 "c:\\cuda\\include\\driver_types.h"











enum cudaError
{
  cudaSuccess                           =      0,   
  cudaErrorMissingConfiguration         =      1,   
  cudaErrorMemoryAllocation             =      2,   
  cudaErrorInitializationError          =      3,   
  cudaErrorLaunchFailure                =      4,   
  cudaErrorPriorLaunchFailure           =      5,   
  cudaErrorLaunchTimeout                =      6,   
  cudaErrorLaunchOutOfResources         =      7,   
  cudaErrorInvalidDeviceFunction        =      8,   
  cudaErrorInvalidConfiguration         =      9,   
  cudaErrorInvalidDevice                =     10,   
  cudaErrorInvalidValue                 =     11,   
  cudaErrorInvalidPitchValue            =     12,   
  cudaErrorInvalidSymbol                =     13,   
  cudaErrorMapBufferObjectFailed        =     14,   
  cudaErrorUnmapBufferObjectFailed      =     15,   
  cudaErrorInvalidHostPointer           =     16,   
  cudaErrorInvalidDevicePointer         =     17,   
  cudaErrorInvalidTexture               =     18,   
  cudaErrorInvalidTextureBinding        =     19,   
  cudaErrorInvalidChannelDescriptor     =     20,   
  cudaErrorInvalidMemcpyDirection       =     21,   
  cudaErrorAddressOfConstant            =     22,   
  cudaErrorTextureFetchFailed           =     23,   
  cudaErrorTextureNotBound              =     24,   
  cudaErrorSynchronizationError         =     25,   
  cudaErrorInvalidFilterSetting         =     26,   
  cudaErrorInvalidNormSetting           =     27,   
  cudaErrorMixedDeviceExecution         =     28,   
  cudaErrorCudartUnloading              =     29,   
  cudaErrorUnknown                      =     30,   
  cudaErrorNotYetImplemented            =     31,   
  cudaErrorMemoryValueTooLarge          =     32,   
  cudaErrorInvalidResourceHandle        =     33,   
  cudaErrorNotReady                     =     34,   
  cudaErrorInsufficientDriver           =     35,   
  cudaErrorSetOnActiveProcess           =     36,   
  cudaErrorNoDevice                     =     38,   
  cudaErrorStartupFailure               =   0x7f,   
  cudaErrorApiFailureBase               =  10000    
};





enum cudaChannelFormatKind
{
  cudaChannelFormatKindSigned           =   0,      
  cudaChannelFormatKindUnsigned         =   1,      
  cudaChannelFormatKindFloat            =   2,      
  cudaChannelFormatKindNone             =   3       
};





struct cudaChannelFormatDesc
{
  int                        x; 
  int                        y; 
  int                        z; 
  int                        w; 
  enum cudaChannelFormatKind f; 
};





struct cudaArray;





enum cudaMemcpyKind
{
  cudaMemcpyHostToHost          =   0,      
  cudaMemcpyHostToDevice        =   1,      
  cudaMemcpyDeviceToHost        =   2,      
  cudaMemcpyDeviceToDevice      =   3       
};





struct cudaPitchedPtr
{
  void   *ptr;      
  size_t  pitch;    
  size_t  xsize;    
  size_t  ysize;    
};





struct cudaExtent
{
  size_t width;     
  size_t height;    
  size_t depth;     
};





struct cudaPos
{
  size_t x;     
  size_t y;     
  size_t z;     
};





struct cudaMemcpy3DParms
{
  struct cudaArray      *srcArray;  
  struct cudaPos         srcPos;    
  struct cudaPitchedPtr  srcPtr;    

  struct cudaArray      *dstArray;  
  struct cudaPos         dstPos;    
  struct cudaPitchedPtr  dstPtr;    

  struct cudaExtent      extent;    
  enum cudaMemcpyKind    kind;      
};





struct cudaFuncAttributes
{
   size_t sharedSizeBytes;  
   size_t constSizeBytes;   
   size_t localSizeBytes;   
   int maxThreadsPerBlock;  
   int numRegs;             
   int __cudaReserved[8];
};





enum cudaComputeMode
{
  cudaComputeModeDefault    =   0,  
  cudaComputeModeExclusive  =   1,  
  cudaComputeModeProhibited =   2   
};






struct cudaDeviceProp
{
  char   name[256];                 
  size_t totalGlobalMem;            
  size_t sharedMemPerBlock;         
  int    regsPerBlock;              
  int    warpSize;                  
  size_t memPitch;                  
  int    maxThreadsPerBlock;        
  int    maxThreadsDim[3];          
  int    maxGridSize[3];            
  int    clockRate;                 
  size_t totalConstMem;             
  int    major;                     
  int    minor;                     
  size_t textureAlignment;          
  int    deviceOverlap;             
  int    multiProcessorCount;       
  int    kernelExecTimeoutEnabled;  
  int    integrated;                
  int    canMapHostMemory;          
  int    computeMode;               
  int    __cudaReserved[36];
};



































typedef enum cudaError cudaError_t;





typedef int cudaStream_t;





typedef int cudaEvent_t;


 

#line 337 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"












































#line 1 "c:\\cuda\\include\\driver_types.h"















































































































































































































































































































































#line 337 "c:\\cuda\\include\\driver_types.h"
#line 46 "c:\\cuda\\include\\texture_types.h"








enum cudaTextureAddressMode
{
  cudaAddressModeWrap,
  cudaAddressModeClamp
};


enum cudaTextureFilterMode
{
  cudaFilterModePoint,
  cudaFilterModeLinear
};


enum cudaTextureReadMode
{
  cudaReadModeElementType,
  cudaReadModeNormalizedFloat
};


struct textureReference
{
  int                          normalized;
  enum cudaTextureFilterMode   filterMode;
  enum cudaTextureAddressMode  addressMode[3];
  struct cudaChannelFormatDesc channelDesc;
  int                          __cudaReserved[16];
};

#line 85 "c:\\cuda\\include\\texture_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"












































#line 1 "c:\\cuda\\include\\host_defines.h"




































































































































#line 134 "c:\\cuda\\include\\host_defines.h"
#line 46 "c:\\cuda\\include\\vector_types.h"











#line 58 "c:\\cuda\\include\\vector_types.h"




















#line 80 "c:\\cuda\\include\\vector_types.h"


struct char1
{
  signed char x;
  
};


struct uchar1 
{
  unsigned char x;
  
};


struct __declspec(align(2)) char2
{
  signed char x, y;
  
};


struct __declspec(align(2)) uchar2
{
  unsigned char x, y;
  
};


struct char3
{
  signed char x, y, z;
  
};


struct uchar3
{
  unsigned char x, y, z;
  
};


struct __declspec(align(4)) char4
{
  signed char x, y, z, w;
  
};


struct __declspec(align(4)) uchar4
{
  unsigned char x, y, z, w;
  
};


struct short1
{
  short x;
  
};


struct ushort1
{
  unsigned short x;
  
};


struct __declspec(align(4)) short2
{
  short x, y;
  
};


struct __declspec(align(4)) ushort2
{
  unsigned short x, y;
  
};


struct short3
{
  short x, y, z;
  
};


struct ushort3
{
  unsigned short x, y, z;
  
};


struct short4 { union { struct { short x, y, z, w; }; struct { long long int :1,:0; }; };  };


struct ushort4 { union { struct { unsigned short x, y, z, w; }; struct { long long int :1,:0; }; };  };


struct int1
{
  int x;
  
};


struct uint1
{
  unsigned int x;
  
};


struct int2 { union { struct { int x, y; }; struct { long long int :1,:0; }; };  };


struct uint2 { union { struct { unsigned int x, y; }; struct { long long int :1,:0; }; };  };


struct int3
{
  int x, y, z;
  
};


struct uint3
{
  unsigned int x, y, z;
  
};


struct  int4
{
  int x, y, z, w;
  
};


struct  uint4
{
  unsigned int x, y, z, w;
  
};


struct long1
{
  long int x;
  
};


struct ulong1
{
  unsigned long x;
  
};




struct long2 { union { struct { long int x, y; }; struct { long long int :1,:0; }; };  };


struct ulong2 { union { struct { unsigned long int x, y; }; struct { long long int :1,:0; }; };  };

















#line 272 "c:\\cuda\\include\\vector_types.h"




struct long3
{
  long int x, y, z;
  
};


struct ulong3
{
  unsigned long int x, y, z;
  
};


struct  long4
{
  long int x, y, z, w;
  
};


struct  ulong4
{
  unsigned long int x, y, z, w;
  
};

#line 304 "c:\\cuda\\include\\vector_types.h"


struct float1
{
  float x;
  
};


struct float2 { union { struct { float x, y; }; struct { long long int :1,:0; }; };  };


struct float3
{
  float x, y, z;
  
};


struct  float4
{
  float x, y, z, w;
  
};


struct longlong1
{
  long long int x;
  
};


struct ulonglong1
{
  unsigned long long int x;
  
};


struct  longlong2
{
  long long int x, y;
  
};


struct  ulonglong2
{
  unsigned long long int x, y;
  
};


struct double1
{
  double x;
  
};


struct  double2
{
  double x, y;
  
};








typedef struct char1 char1;

typedef struct uchar1 uchar1;

typedef struct char2 char2;

typedef struct uchar2 uchar2;

typedef struct char3 char3;

typedef struct uchar3 uchar3;

typedef struct char4 char4;

typedef struct uchar4 uchar4;

typedef struct short1 short1;

typedef struct ushort1 ushort1;

typedef struct short2 short2;

typedef struct ushort2 ushort2;

typedef struct short3 short3;

typedef struct ushort3 ushort3;

typedef struct short4 short4;

typedef struct ushort4 ushort4;

typedef struct int1 int1;

typedef struct uint1 uint1;

typedef struct int2 int2;

typedef struct uint2 uint2;

typedef struct int3 int3;

typedef struct uint3 uint3;

typedef struct int4 int4;

typedef struct uint4 uint4;

typedef struct long1 long1;

typedef struct ulong1 ulong1;

typedef struct long2 long2;

typedef struct ulong2 ulong2;

typedef struct long3 long3;

typedef struct ulong3 ulong3;

typedef struct long4 long4;

typedef struct ulong4 ulong4;

typedef struct float1 float1;

typedef struct float2 float2;

typedef struct float3 float3;

typedef struct float4 float4;

typedef struct longlong1 longlong1;

typedef struct ulonglong1 ulonglong1;

typedef struct longlong2 longlong2;

typedef struct ulonglong2 ulonglong2;

typedef struct double1 double1;

typedef struct double2 double2;








struct dim3
{
    unsigned int x, y, z;

      dim3(unsigned int x = 1, unsigned int y = 1, unsigned int z = 1) : x(x), y(y), z(z) {}
      dim3(uint3 v) : x(v.x), y(v.y), z(v.z) {}
      operator uint3(void) { uint3 t; t.x = x; t.y = y; t.z = z; return t; }
#line 477 "c:\\cuda\\include\\vector_types.h"
};


typedef struct dim3 dim3;




#line 486 "c:\\cuda\\include\\vector_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 55 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"















#line 71 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"









extern "C" {
#line 82 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"







extern  cudaError_t __stdcall cudaMalloc3D(struct cudaPitchedPtr* pitchedDevPtr, struct cudaExtent extent);
extern  cudaError_t __stdcall cudaMalloc3DArray(struct cudaArray** arrayPtr, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent);
extern  cudaError_t __stdcall cudaMemset3D(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent);
extern  cudaError_t __stdcall cudaMemcpy3D(const struct cudaMemcpy3DParms *p);
extern  cudaError_t __stdcall cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream);








extern  cudaError_t __stdcall cudaMalloc(void **devPtr, size_t size);
extern  cudaError_t __stdcall cudaMallocHost(void **ptr, size_t size);
extern  cudaError_t __stdcall cudaMallocPitch(void **devPtr, size_t *pitch, size_t width, size_t height);
extern  cudaError_t __stdcall cudaMallocArray(struct cudaArray **array, const struct cudaChannelFormatDesc *desc, size_t width, size_t height );
extern  cudaError_t __stdcall cudaFree(void *devPtr);
extern  cudaError_t __stdcall cudaFreeHost(void *ptr);
extern  cudaError_t __stdcall cudaFreeArray(struct cudaArray *array);

extern  cudaError_t __stdcall cudaHostAlloc(void **pHost, size_t bytes, unsigned int flags);
extern  cudaError_t __stdcall cudaHostGetDevicePointer(void **pDevice, void *pHost, unsigned int flags);
extern  cudaError_t __stdcall cudaHostGetFlags(unsigned int *pFlags, void *pHost);








extern  cudaError_t __stdcall cudaMemcpy(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind);
extern  cudaError_t __stdcall cudaMemcpyToArray(struct cudaArray *dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind);
extern  cudaError_t __stdcall cudaMemcpyFromArray(void *dst, const struct cudaArray *src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind);
extern  cudaError_t __stdcall cudaMemcpyArrayToArray(struct cudaArray *dst, size_t wOffsetDst, size_t hOffsetDst, const struct cudaArray *src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, enum cudaMemcpyKind kind );
extern  cudaError_t __stdcall cudaMemcpy2D(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);
extern  cudaError_t __stdcall cudaMemcpy2DToArray(struct cudaArray *dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);
extern  cudaError_t __stdcall cudaMemcpy2DFromArray(void *dst, size_t dpitch, const struct cudaArray *src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind);
extern  cudaError_t __stdcall cudaMemcpy2DArrayToArray(struct cudaArray *dst, size_t wOffsetDst, size_t hOffsetDst, const struct cudaArray *src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, enum cudaMemcpyKind kind );
extern  cudaError_t __stdcall cudaMemcpyToSymbol(const char *symbol, const void *src, size_t count, size_t offset , enum cudaMemcpyKind kind );
extern  cudaError_t __stdcall cudaMemcpyFromSymbol(void *dst, const char *symbol, size_t count, size_t offset , enum cudaMemcpyKind kind );







extern  cudaError_t __stdcall cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream);
extern  cudaError_t __stdcall cudaMemcpyToArrayAsync(struct cudaArray *dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream);
extern  cudaError_t __stdcall cudaMemcpyFromArrayAsync(void *dst, const struct cudaArray *src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream);
extern  cudaError_t __stdcall cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream);
extern  cudaError_t __stdcall cudaMemcpy2DToArrayAsync(struct cudaArray *dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream);
extern  cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void *dst, size_t dpitch, const struct cudaArray *src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream);
extern  cudaError_t __stdcall cudaMemcpyToSymbolAsync(const char *symbol, const void *src, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream);
extern  cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void *dst, const char *symbol, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream);







extern  cudaError_t __stdcall cudaMemset(void *devPtr, int value, size_t count);
extern  cudaError_t __stdcall cudaMemset2D(void *devPtr, size_t pitch, int value, size_t width, size_t height);







extern  cudaError_t __stdcall cudaGetSymbolAddress(void **devPtr, const char *symbol);
extern  cudaError_t __stdcall cudaGetSymbolSize(size_t *size, const char *symbol);







extern  cudaError_t __stdcall cudaGetDeviceCount(int *count);
extern  cudaError_t __stdcall cudaGetDeviceProperties(struct cudaDeviceProp *prop, int device);
extern  cudaError_t __stdcall cudaChooseDevice(int *device, const struct cudaDeviceProp *prop);
extern  cudaError_t __stdcall cudaSetDevice(int device);
extern  cudaError_t __stdcall cudaGetDevice(int *device);
extern  cudaError_t __stdcall cudaSetValidDevices(int *device_arr, int len);
extern  cudaError_t __stdcall cudaSetDeviceFlags( int flags );







extern  cudaError_t __stdcall cudaBindTexture(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t size );
extern  cudaError_t __stdcall cudaBindTexture2D(size_t *offset,const struct textureReference *texref,const void *devPtr, const struct cudaChannelFormatDesc *desc,size_t width, size_t height, size_t pitch);
extern  cudaError_t __stdcall cudaBindTextureToArray(const struct textureReference *texref, const struct cudaArray *array, const struct cudaChannelFormatDesc *desc);
extern  cudaError_t __stdcall cudaUnbindTexture(const struct textureReference *texref);
extern  cudaError_t __stdcall cudaGetTextureAlignmentOffset(size_t *offset, const struct textureReference *texref);
extern  cudaError_t __stdcall cudaGetTextureReference(const struct textureReference **texref, const char *symbol);







extern  cudaError_t __stdcall cudaGetChannelDesc(struct cudaChannelFormatDesc *desc, const struct cudaArray *array);
extern  struct cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int x, int y, int z, int w, enum cudaChannelFormatKind f);







extern  cudaError_t __stdcall cudaGetLastError(void);
extern  const char* __stdcall cudaGetErrorString(cudaError_t error);







extern  cudaError_t __stdcall cudaConfigureCall(dim3 gridDim, dim3 blockDim, size_t sharedMem , cudaStream_t stream );
extern  cudaError_t __stdcall cudaSetupArgument(const void *arg, size_t size, size_t offset);
extern  cudaError_t __stdcall cudaLaunch(const char *entry);
extern  cudaError_t __stdcall cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const char *func);







extern  cudaError_t __stdcall cudaStreamCreate(cudaStream_t *pStream);
extern  cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream);
extern  cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t stream);
extern  cudaError_t __stdcall cudaStreamQuery(cudaStream_t stream);







extern  cudaError_t __stdcall cudaEventCreate(cudaEvent_t *event);
extern  cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t *event, int flags);
extern  cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream);
extern  cudaError_t __stdcall cudaEventQuery(cudaEvent_t event);
extern  cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t event);
extern  cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event);
extern  cudaError_t __stdcall cudaEventElapsedTime(float *ms, cudaEvent_t start, cudaEvent_t end);







extern  cudaError_t __stdcall cudaSetDoubleForDevice(double *d);
extern  cudaError_t __stdcall cudaSetDoubleForHost(double *d);







extern  cudaError_t __stdcall cudaThreadExit(void);
extern  cudaError_t __stdcall cudaThreadSynchronize(void);







extern  cudaError_t __stdcall cudaDriverGetVersion(int *driverVersion);
extern  cudaError_t __stdcall cudaRuntimeGetVersion(int *runtimeVersion);


}
#line 276 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"



#line 280 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
#line 108 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"
#line 1 "c:\\cuda\\include\\crt\\storage_class.h"










































#line 44 "c:\\cuda\\include\\crt\\storage_class.h"






#line 51 "c:\\cuda\\include\\crt\\storage_class.h"



#line 55 "c:\\cuda\\include\\crt\\storage_class.h"



#line 59 "c:\\cuda\\include\\crt\\storage_class.h"



#line 63 "c:\\cuda\\include\\crt\\storage_class.h"



#line 67 "c:\\cuda\\include\\crt\\storage_class.h"



#line 71 "c:\\cuda\\include\\crt\\storage_class.h"



#line 75 "c:\\cuda\\include\\crt\\storage_class.h"



#line 79 "c:\\cuda\\include\\crt\\storage_class.h"



#line 83 "c:\\cuda\\include\\crt\\storage_class.h"



#line 87 "c:\\cuda\\include\\crt\\storage_class.h"



#line 91 "c:\\cuda\\include\\crt\\storage_class.h"



#line 95 "c:\\cuda\\include\\crt\\storage_class.h"



#line 99 "c:\\cuda\\include\\crt\\storage_class.h"



#line 103 "c:\\cuda\\include\\crt\\storage_class.h"



#line 107 "c:\\cuda\\include\\crt\\storage_class.h"



#line 111 "c:\\cuda\\include\\crt\\storage_class.h"



#line 115 "c:\\cuda\\include\\crt\\storage_class.h"



#line 119 "c:\\cuda\\include\\crt\\storage_class.h"



#line 123 "c:\\cuda\\include\\crt\\storage_class.h"



#line 127 "c:\\cuda\\include\\crt\\storage_class.h"



#line 131 "c:\\cuda\\include\\crt\\storage_class.h"



#line 135 "c:\\cuda\\include\\crt\\storage_class.h"



#line 139 "c:\\cuda\\include\\crt\\storage_class.h"



#line 143 "c:\\cuda\\include\\crt\\storage_class.h"



#line 147 "c:\\cuda\\include\\crt\\storage_class.h"

#line 149 "c:\\cuda\\include\\crt\\storage_class.h"
#line 109 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"































































































































































































#line 301 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"
#line 492 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
#line 497 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
extern "C" { typedef size_t rsize_t; }
#line 506 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
extern "C" { typedef int __w64 intptr_t; }
#line 524 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
extern "C" { typedef int __w64 ptrdiff_t; }
#line 535 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
extern "C" { typedef unsigned short wint_t; }
extern "C" { typedef unsigned short wctype_t; }
#line 560 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
extern "C" { typedef int errcode; }
#line 565 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
extern "C" { typedef int errno_t; }
#line 569 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
extern "C" { typedef long __w64 __time32_t; }
#line 574 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
extern "C" { typedef __int64 __time64_t; }
#line 582 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
extern "C" { typedef __time64_t time_t; }
#line 2037 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
struct threadlocaleinfostruct; 
struct threadmbcinfostruct; 
extern "C" { typedef threadlocaleinfostruct *pthreadlocinfo; }
extern "C" { typedef threadmbcinfostruct *pthreadmbcinfo; }
struct __lc_time_data; 
#line 2047 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
extern "C" { typedef 
#line 2043 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
struct localeinfo_struct { 

pthreadlocinfo locinfo; 
pthreadmbcinfo mbcinfo; 
} _locale_tstruct; }extern "C" { typedef localeinfo_struct *_locale_t; }
#line 2054 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
extern "C" { typedef 
#line 2050 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
struct tagLC_ID { 
unsigned short wLanguage; 
unsigned short wCountry; 
unsigned short wCodePage; 
} LC_ID; }extern "C" { typedef tagLC_ID *LPLC_ID; }
#line 2083 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
extern "C" { typedef 
#line 2059 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
struct threadlocaleinfostruct { 
int refcount; 
unsigned lc_codepage; 
unsigned lc_collate_cp; 
unsigned long lc_handle[6]; 
LC_ID lc_id[6]; 
struct { 
char *locale; 
__wchar_t *wlocale; 
int *refcount; 
int *wrefcount; 
} lc_category[6]; 
int lc_clike; 
int mb_cur_max; 
int *lconv_intl_refcount; 
int *lconv_num_refcount; 
int *lconv_mon_refcount; 
struct lconv *lconv; 
int *ctype1_refcount; 
unsigned short *ctype1; 
const unsigned short *pctype; 
const unsigned char *pclmap; 
const unsigned char *pcumap; 
__lc_time_data *lc_time_curr; 
} threadlocinfo; }
#line 2121 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdefs.h"
#pragma pack ( pop )
#line 46 "c:\\cuda\\include\\device_types.h"









#line 56 "c:\\cuda\\include\\device_types.h"
#line 41 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stddef.h"
extern "C" { extern int *__cdecl _errno(); } 


extern "C" { extern errno_t __cdecl _set_errno(int); } 
extern "C" { extern errno_t __cdecl _get_errno(int *); } 
#line 68 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stddef.h"
extern "C" { extern unsigned long __cdecl __threadid(); } 

extern "C" { extern uintptr_t __cdecl __threadhandle(); } 
#line 91 "c:\\cuda\\include\\driver_types.h"













































#line 137 "c:\\cuda\\include\\driver_types.h"
#line 139 "c:\\cuda\\include\\driver_types.h"









#line 149 "c:\\cuda\\include\\driver_types.h"
#line 151 "c:\\cuda\\include\\driver_types.h"










#line 162 "c:\\cuda\\include\\driver_types.h"
#line 164 "c:\\cuda\\include\\driver_types.h"


#line 167 "c:\\cuda\\include\\driver_types.h"
#line 170 "c:\\cuda\\include\\driver_types.h"









#line 180 "c:\\cuda\\include\\driver_types.h"
#line 182 "c:\\cuda\\include\\driver_types.h"









#line 192 "c:\\cuda\\include\\driver_types.h"
#line 194 "c:\\cuda\\include\\driver_types.h"








#line 203 "c:\\cuda\\include\\driver_types.h"
#line 205 "c:\\cuda\\include\\driver_types.h"








#line 214 "c:\\cuda\\include\\driver_types.h"
#line 216 "c:\\cuda\\include\\driver_types.h"















#line 232 "c:\\cuda\\include\\driver_types.h"
#line 234 "c:\\cuda\\include\\driver_types.h"











#line 246 "c:\\cuda\\include\\driver_types.h"
#line 248 "c:\\cuda\\include\\driver_types.h"








#line 257 "c:\\cuda\\include\\driver_types.h"
#line 260 "c:\\cuda\\include\\driver_types.h"


























#line 287 "c:\\cuda\\include\\driver_types.h"
#line 319 "c:\\cuda\\include\\driver_types.h"




#line 324 "c:\\cuda\\include\\driver_types.h"
#line 325 "c:\\cuda\\include\\driver_types.h"




#line 330 "c:\\cuda\\include\\driver_types.h"
#line 331 "c:\\cuda\\include\\driver_types.h"




#line 336 "c:\\cuda\\include\\driver_types.h"
#line 54 "c:\\cuda\\include\\texture_types.h"







#line 62 "c:\\cuda\\include\\texture_types.h"
#line 61 "c:\\cuda\\include\\texture_types.h"







#line 69 "c:\\cuda\\include\\texture_types.h"
#line 68 "c:\\cuda\\include\\texture_types.h"







#line 76 "c:\\cuda\\include\\texture_types.h"
#line 75 "c:\\cuda\\include\\texture_types.h"










#line 86 "c:\\cuda\\include\\texture_types.h"
#line 82 "c:\\cuda\\include\\vector_types.h"







#line 90 "c:\\cuda\\include\\vector_types.h"
#line 89 "c:\\cuda\\include\\vector_types.h"







#line 97 "c:\\cuda\\include\\vector_types.h"
#line 96 "c:\\cuda\\include\\vector_types.h"







#line 104 "c:\\cuda\\include\\vector_types.h"
#line 103 "c:\\cuda\\include\\vector_types.h"







#line 111 "c:\\cuda\\include\\vector_types.h"
#line 110 "c:\\cuda\\include\\vector_types.h"







#line 118 "c:\\cuda\\include\\vector_types.h"
#line 117 "c:\\cuda\\include\\vector_types.h"







#line 125 "c:\\cuda\\include\\vector_types.h"
#line 124 "c:\\cuda\\include\\vector_types.h"







#line 132 "c:\\cuda\\include\\vector_types.h"
#line 131 "c:\\cuda\\include\\vector_types.h"







#line 139 "c:\\cuda\\include\\vector_types.h"
#line 138 "c:\\cuda\\include\\vector_types.h"







#line 146 "c:\\cuda\\include\\vector_types.h"
#line 145 "c:\\cuda\\include\\vector_types.h"







#line 153 "c:\\cuda\\include\\vector_types.h"
#line 152 "c:\\cuda\\include\\vector_types.h"







#line 160 "c:\\cuda\\include\\vector_types.h"
#line 159 "c:\\cuda\\include\\vector_types.h"







#line 167 "c:\\cuda\\include\\vector_types.h"
#line 166 "c:\\cuda\\include\\vector_types.h"







#line 174 "c:\\cuda\\include\\vector_types.h"
#line 173 "c:\\cuda\\include\\vector_types.h"







#line 181 "c:\\cuda\\include\\vector_types.h"
#line 180 "c:\\cuda\\include\\vector_types.h"



#line 184 "c:\\cuda\\include\\vector_types.h"
#line 183 "c:\\cuda\\include\\vector_types.h"



#line 187 "c:\\cuda\\include\\vector_types.h"
#line 186 "c:\\cuda\\include\\vector_types.h"







#line 194 "c:\\cuda\\include\\vector_types.h"
#line 193 "c:\\cuda\\include\\vector_types.h"







#line 201 "c:\\cuda\\include\\vector_types.h"
#line 200 "c:\\cuda\\include\\vector_types.h"



#line 204 "c:\\cuda\\include\\vector_types.h"
#line 203 "c:\\cuda\\include\\vector_types.h"



#line 207 "c:\\cuda\\include\\vector_types.h"
#line 206 "c:\\cuda\\include\\vector_types.h"







#line 214 "c:\\cuda\\include\\vector_types.h"
#line 213 "c:\\cuda\\include\\vector_types.h"







#line 221 "c:\\cuda\\include\\vector_types.h"
#line 220 "c:\\cuda\\include\\vector_types.h"







#line 228 "c:\\cuda\\include\\vector_types.h"
#line 227 "c:\\cuda\\include\\vector_types.h"







#line 235 "c:\\cuda\\include\\vector_types.h"
#line 234 "c:\\cuda\\include\\vector_types.h"







#line 242 "c:\\cuda\\include\\vector_types.h"
#line 241 "c:\\cuda\\include\\vector_types.h"







#line 249 "c:\\cuda\\include\\vector_types.h"
#line 250 "c:\\cuda\\include\\vector_types.h"



#line 254 "c:\\cuda\\include\\vector_types.h"
#line 253 "c:\\cuda\\include\\vector_types.h"



#line 257 "c:\\cuda\\include\\vector_types.h"
#line 276 "c:\\cuda\\include\\vector_types.h"







#line 284 "c:\\cuda\\include\\vector_types.h"
#line 283 "c:\\cuda\\include\\vector_types.h"







#line 291 "c:\\cuda\\include\\vector_types.h"
#line 290 "c:\\cuda\\include\\vector_types.h"







#line 298 "c:\\cuda\\include\\vector_types.h"
#line 297 "c:\\cuda\\include\\vector_types.h"







#line 305 "c:\\cuda\\include\\vector_types.h"
#line 306 "c:\\cuda\\include\\vector_types.h"







#line 314 "c:\\cuda\\include\\vector_types.h"
#line 313 "c:\\cuda\\include\\vector_types.h"



#line 317 "c:\\cuda\\include\\vector_types.h"
#line 316 "c:\\cuda\\include\\vector_types.h"







#line 324 "c:\\cuda\\include\\vector_types.h"
#line 323 "c:\\cuda\\include\\vector_types.h"







#line 331 "c:\\cuda\\include\\vector_types.h"
#line 330 "c:\\cuda\\include\\vector_types.h"







#line 338 "c:\\cuda\\include\\vector_types.h"
#line 337 "c:\\cuda\\include\\vector_types.h"







#line 345 "c:\\cuda\\include\\vector_types.h"
#line 344 "c:\\cuda\\include\\vector_types.h"







#line 352 "c:\\cuda\\include\\vector_types.h"
#line 351 "c:\\cuda\\include\\vector_types.h"







#line 359 "c:\\cuda\\include\\vector_types.h"
#line 358 "c:\\cuda\\include\\vector_types.h"







#line 366 "c:\\cuda\\include\\vector_types.h"
#line 365 "c:\\cuda\\include\\vector_types.h"







#line 373 "c:\\cuda\\include\\vector_types.h"
#line 378 "c:\\cuda\\include\\vector_types.h"




#line 383 "c:\\cuda\\include\\vector_types.h"
#line 380 "c:\\cuda\\include\\vector_types.h"




#line 385 "c:\\cuda\\include\\vector_types.h"
#line 382 "c:\\cuda\\include\\vector_types.h"




#line 387 "c:\\cuda\\include\\vector_types.h"
#line 384 "c:\\cuda\\include\\vector_types.h"




#line 389 "c:\\cuda\\include\\vector_types.h"
#line 386 "c:\\cuda\\include\\vector_types.h"




#line 391 "c:\\cuda\\include\\vector_types.h"
#line 388 "c:\\cuda\\include\\vector_types.h"




#line 393 "c:\\cuda\\include\\vector_types.h"
#line 390 "c:\\cuda\\include\\vector_types.h"




#line 395 "c:\\cuda\\include\\vector_types.h"
#line 392 "c:\\cuda\\include\\vector_types.h"




#line 397 "c:\\cuda\\include\\vector_types.h"
#line 394 "c:\\cuda\\include\\vector_types.h"




#line 399 "c:\\cuda\\include\\vector_types.h"
#line 396 "c:\\cuda\\include\\vector_types.h"




#line 401 "c:\\cuda\\include\\vector_types.h"
#line 398 "c:\\cuda\\include\\vector_types.h"




#line 403 "c:\\cuda\\include\\vector_types.h"
#line 400 "c:\\cuda\\include\\vector_types.h"




#line 405 "c:\\cuda\\include\\vector_types.h"
#line 402 "c:\\cuda\\include\\vector_types.h"




#line 407 "c:\\cuda\\include\\vector_types.h"
#line 404 "c:\\cuda\\include\\vector_types.h"




#line 409 "c:\\cuda\\include\\vector_types.h"
#line 406 "c:\\cuda\\include\\vector_types.h"




#line 411 "c:\\cuda\\include\\vector_types.h"
#line 408 "c:\\cuda\\include\\vector_types.h"




#line 413 "c:\\cuda\\include\\vector_types.h"
#line 410 "c:\\cuda\\include\\vector_types.h"




#line 415 "c:\\cuda\\include\\vector_types.h"
#line 412 "c:\\cuda\\include\\vector_types.h"




#line 417 "c:\\cuda\\include\\vector_types.h"
#line 414 "c:\\cuda\\include\\vector_types.h"




#line 419 "c:\\cuda\\include\\vector_types.h"
#line 416 "c:\\cuda\\include\\vector_types.h"




#line 421 "c:\\cuda\\include\\vector_types.h"
#line 418 "c:\\cuda\\include\\vector_types.h"




#line 423 "c:\\cuda\\include\\vector_types.h"
#line 420 "c:\\cuda\\include\\vector_types.h"




#line 425 "c:\\cuda\\include\\vector_types.h"
#line 422 "c:\\cuda\\include\\vector_types.h"




#line 427 "c:\\cuda\\include\\vector_types.h"
#line 424 "c:\\cuda\\include\\vector_types.h"




#line 429 "c:\\cuda\\include\\vector_types.h"
#line 426 "c:\\cuda\\include\\vector_types.h"




#line 431 "c:\\cuda\\include\\vector_types.h"
#line 428 "c:\\cuda\\include\\vector_types.h"




#line 433 "c:\\cuda\\include\\vector_types.h"
#line 430 "c:\\cuda\\include\\vector_types.h"




#line 435 "c:\\cuda\\include\\vector_types.h"
#line 432 "c:\\cuda\\include\\vector_types.h"




#line 437 "c:\\cuda\\include\\vector_types.h"
#line 434 "c:\\cuda\\include\\vector_types.h"




#line 439 "c:\\cuda\\include\\vector_types.h"
#line 436 "c:\\cuda\\include\\vector_types.h"




#line 441 "c:\\cuda\\include\\vector_types.h"
#line 438 "c:\\cuda\\include\\vector_types.h"




#line 443 "c:\\cuda\\include\\vector_types.h"
#line 440 "c:\\cuda\\include\\vector_types.h"




#line 445 "c:\\cuda\\include\\vector_types.h"
#line 442 "c:\\cuda\\include\\vector_types.h"




#line 447 "c:\\cuda\\include\\vector_types.h"
#line 444 "c:\\cuda\\include\\vector_types.h"




#line 449 "c:\\cuda\\include\\vector_types.h"
#line 446 "c:\\cuda\\include\\vector_types.h"




#line 451 "c:\\cuda\\include\\vector_types.h"
#line 448 "c:\\cuda\\include\\vector_types.h"




#line 453 "c:\\cuda\\include\\vector_types.h"
#line 450 "c:\\cuda\\include\\vector_types.h"




#line 455 "c:\\cuda\\include\\vector_types.h"
#line 452 "c:\\cuda\\include\\vector_types.h"




#line 457 "c:\\cuda\\include\\vector_types.h"
#line 454 "c:\\cuda\\include\\vector_types.h"




#line 459 "c:\\cuda\\include\\vector_types.h"
#line 456 "c:\\cuda\\include\\vector_types.h"




#line 461 "c:\\cuda\\include\\vector_types.h"
#line 458 "c:\\cuda\\include\\vector_types.h"




#line 463 "c:\\cuda\\include\\vector_types.h"
#line 460 "c:\\cuda\\include\\vector_types.h"




#line 465 "c:\\cuda\\include\\vector_types.h"
#line 469 "c:\\cuda\\include\\vector_types.h"







#line 477 "c:\\cuda\\include\\vector_types.h"
#line 480 "c:\\cuda\\include\\vector_types.h"




#line 485 "c:\\cuda\\include\\vector_types.h"
#line 89 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaMalloc3D(cudaPitchedPtr *, cudaExtent); } 
extern "C" { extern cudaError_t __stdcall cudaMalloc3DArray(cudaArray **, const cudaChannelFormatDesc *, cudaExtent); } 
extern "C" { extern cudaError_t __stdcall cudaMemset3D(cudaPitchedPtr, int, cudaExtent); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpy3D(const cudaMemcpy3DParms *); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms *, cudaStream_t); } 
#line 102 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaMalloc(void **, size_t); } 
extern "C" { extern cudaError_t __stdcall cudaMallocHost(void **, size_t); } 
extern "C" { extern cudaError_t __stdcall cudaMallocPitch(void **, size_t *, size_t, size_t); } 
extern "C" { extern cudaError_t __stdcall cudaMallocArray(cudaArray **, const cudaChannelFormatDesc *, size_t, size_t = (1)); } 
extern "C" { extern cudaError_t __stdcall cudaFree(void *); } 
extern "C" { extern cudaError_t __stdcall cudaFreeHost(void *); } 
extern "C" { extern cudaError_t __stdcall cudaFreeArray(cudaArray *); } 

extern "C" { extern cudaError_t __stdcall cudaHostAlloc(void **, size_t, unsigned); } 
extern "C" { extern cudaError_t __stdcall cudaHostGetDevicePointer(void **, void *, unsigned); } 
extern "C" { extern cudaError_t __stdcall cudaHostGetFlags(unsigned *, void *); } 
#line 121 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaMemcpy(void *, const void *, size_t, cudaMemcpyKind); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpyToArray(cudaArray *, size_t, size_t, const void *, size_t, cudaMemcpyKind); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromArray(void *, const cudaArray *, size_t, size_t, size_t, cudaMemcpyKind); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpyArrayToArray(cudaArray *, size_t, size_t, const cudaArray *, size_t, size_t, size_t, cudaMemcpyKind = cudaMemcpyDeviceToDevice); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpy2D(void *, size_t, const void *, size_t, size_t, size_t, cudaMemcpyKind); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DToArray(cudaArray *, size_t, size_t, const void *, size_t, size_t, size_t, cudaMemcpyKind); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DFromArray(void *, size_t, const cudaArray *, size_t, size_t, size_t, size_t, cudaMemcpyKind); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DArrayToArray(cudaArray *, size_t, size_t, const cudaArray *, size_t, size_t, size_t, size_t, cudaMemcpyKind = cudaMemcpyDeviceToDevice); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpyToSymbol(const char *, const void *, size_t, size_t = (0), cudaMemcpyKind = cudaMemcpyHostToDevice); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromSymbol(void *, const char *, size_t, size_t = (0), cudaMemcpyKind = cudaMemcpyDeviceToHost); } 
#line 138 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaMemcpyAsync(void *, const void *, size_t, cudaMemcpyKind, cudaStream_t); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpyToArrayAsync(cudaArray *, size_t, size_t, const void *, size_t, cudaMemcpyKind, cudaStream_t); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromArrayAsync(void *, const cudaArray *, size_t, size_t, size_t, cudaMemcpyKind, cudaStream_t); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DAsync(void *, size_t, const void *, size_t, size_t, size_t, cudaMemcpyKind, cudaStream_t); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DToArrayAsync(cudaArray *, size_t, size_t, const void *, size_t, size_t, size_t, cudaMemcpyKind, cudaStream_t); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void *, size_t, const cudaArray *, size_t, size_t, size_t, size_t, cudaMemcpyKind, cudaStream_t); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpyToSymbolAsync(const char *, const void *, size_t, size_t, cudaMemcpyKind, cudaStream_t); } 
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void *, const char *, size_t, size_t, cudaMemcpyKind, cudaStream_t); } 
#line 153 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaMemset(void *, int, size_t); } 
extern "C" { extern cudaError_t __stdcall cudaMemset2D(void *, size_t, int, size_t, size_t); } 
#line 162 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaGetSymbolAddress(void **, const char *); } 
extern "C" { extern cudaError_t __stdcall cudaGetSymbolSize(size_t *, const char *); } 
#line 171 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaGetDeviceCount(int *); } 
extern "C" { extern cudaError_t __stdcall cudaGetDeviceProperties(cudaDeviceProp *, int); } 
extern "C" { extern cudaError_t __stdcall cudaChooseDevice(int *, const cudaDeviceProp *); } 
extern "C" { extern cudaError_t __stdcall cudaSetDevice(int); } 
extern "C" { extern cudaError_t __stdcall cudaGetDevice(int *); } 
extern "C" { extern cudaError_t __stdcall cudaSetValidDevices(int *, int); } 
extern "C" { extern cudaError_t __stdcall cudaSetDeviceFlags(int); } 
#line 185 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaBindTexture(size_t *, const textureReference *, const void *, const cudaChannelFormatDesc *, size_t = (4294967295U)); } 
extern "C" { extern cudaError_t __stdcall cudaBindTexture2D(size_t *, const textureReference *, const void *, const cudaChannelFormatDesc *, size_t, size_t, size_t); } 
extern "C" { extern cudaError_t __stdcall cudaBindTextureToArray(const textureReference *, const cudaArray *, const cudaChannelFormatDesc *); } 
extern "C" { extern cudaError_t __stdcall cudaUnbindTexture(const textureReference *); } 
extern "C" { extern cudaError_t __stdcall cudaGetTextureAlignmentOffset(size_t *, const textureReference *); } 
extern "C" { extern cudaError_t __stdcall cudaGetTextureReference(const textureReference **, const char *); } 
#line 198 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaGetChannelDesc(cudaChannelFormatDesc *, const cudaArray *); } 
extern "C" { extern cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int, int, int, int, cudaChannelFormatKind); } 
#line 207 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaGetLastError(); } 
extern "C" { extern const char *__stdcall cudaGetErrorString(cudaError_t); } 
#line 216 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaConfigureCall(dim3, dim3, size_t = (0), cudaStream_t = (0)); } 
extern "C" { extern cudaError_t __stdcall cudaSetupArgument(const void *, size_t, size_t); } 
extern "C" { extern cudaError_t __stdcall cudaLaunch(const char *); } 
extern "C" { extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes *, const char *); } 
#line 227 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaStreamCreate(cudaStream_t *); } 
extern "C" { extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t); } 
extern "C" { extern cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t); } 
extern "C" { extern cudaError_t __stdcall cudaStreamQuery(cudaStream_t); } 
#line 238 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaEventCreate(cudaEvent_t *); } 
extern "C" { extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t *, int); } 
extern "C" { extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t, cudaStream_t); } 
extern "C" { extern cudaError_t __stdcall cudaEventQuery(cudaEvent_t); } 
extern "C" { extern cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t); } 
extern "C" { extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t); } 
extern "C" { extern cudaError_t __stdcall cudaEventElapsedTime(float *, cudaEvent_t, cudaEvent_t); } 
#line 252 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaSetDoubleForDevice(double *); } 
extern "C" { extern cudaError_t __stdcall cudaSetDoubleForHost(double *); } 
#line 261 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaThreadExit(); } 
extern "C" { extern cudaError_t __stdcall cudaThreadSynchronize(); } 
#line 270 "C:\\CUDA\\bin64/../include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaDriverGetVersion(int *); } 
extern "C" { extern cudaError_t __stdcall cudaRuntimeGetVersion(int *); } 
#line 93 "c:\\cuda\\include\\channel_descriptor.h"
template<class T> __inline cudaChannelFormatDesc cudaCreateChannelDesc() 
{ 
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
{ 
auto int e = (((int)sizeof(char)) * 8); 
#line 105 "c:\\cuda\\include\\channel_descriptor.h"
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 107 "c:\\cuda\\include\\channel_descriptor.h"
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
{ 
auto int e = (((int)sizeof(signed char)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
{ 
auto int e = (((int)sizeof(unsigned char)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
{ 
auto int e = (((int)sizeof(signed char)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
{ 
auto int e = (((int)sizeof(unsigned char)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
{ 
auto int e = (((int)sizeof(signed char)) * 8); 

return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
{ 
auto int e = (((int)sizeof(unsigned char)) * 8); 

return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
{ 
auto int e = (((int)sizeof(signed char)) * 8); 

return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
{ 
auto int e = (((int)sizeof(unsigned char)) * 8); 

return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
{ 
auto int e = (((int)sizeof(short)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
{ 
auto int e = (((int)sizeof(unsigned short)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
{ 
auto int e = (((int)sizeof(short)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
{ 
auto int e = (((int)sizeof(unsigned short)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
{ 
auto int e = (((int)sizeof(short)) * 8); 

return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
{ 
auto int e = (((int)sizeof(unsigned short)) * 8); 

return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
{ 
auto int e = (((int)sizeof(short)) * 8); 

return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
{ 
auto int e = (((int)sizeof(unsigned short)) * 8); 

return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
{ 
auto int e = (((int)sizeof(int)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
{ 
auto int e = (((int)sizeof(unsigned)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
{ 
auto int e = (((int)sizeof(int)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
{ 
auto int e = (((int)sizeof(unsigned)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
{ 
auto int e = (((int)sizeof(int)) * 8); 

return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
{ 
auto int e = (((int)sizeof(unsigned)) * 8); 

return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
{ 
auto int e = (((int)sizeof(int)) * 8); 

return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
{ 
auto int e = (((int)sizeof(unsigned)) * 8); 

return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
} 



template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long> () 
{ 
auto int e = (((int)sizeof(long)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned long> () 
{ 
auto int e = (((int)sizeof(unsigned long)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long1> () 
{ 
auto int e = (((int)sizeof(long)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong1> () 
{ 
auto int e = (((int)sizeof(unsigned long)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long2> () 
{ 
auto int e = (((int)sizeof(long)) * 8); 

return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong2> () 
{ 
auto int e = (((int)sizeof(unsigned long)) * 8); 

return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long4> () 
{ 
auto int e = (((int)sizeof(long)) * 8); 

return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong4> () 
{ 
auto int e = (((int)sizeof(unsigned long)) * 8); 

return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
} 
#line 337 "c:\\cuda\\include\\channel_descriptor.h"
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
{ 
auto int e = (((int)sizeof(float)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
{ 
auto int e = (((int)sizeof(float)) * 8); 

return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
{ 
auto int e = (((int)sizeof(float)) * 8); 

return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
} 

template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
{ 
auto int e = (((int)sizeof(float)) * 8); 

return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
} 
#line 54 "c:\\cuda\\include\\driver_functions.h"
static __inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
{ 
auto cudaPitchedPtr s; 

(s.ptr) = d; 
(s.pitch) = p; 
(s.xsize) = xsz; 
(s.ysize) = ysz; 

return s; 
} 

static __inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
{ 
auto cudaPos p; 

(p.x) = x; 
(p.y) = y; 
(p.z) = z; 

return p; 
} 

static __inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
{ 
auto cudaExtent e; 

(e.width) = w; 
(e.height) = h; 
(e.depth) = d; 

return e; 
} 
#line 54 "c:\\cuda\\include\\vector_functions.h"
static __inline char1 make_char1(signed char x) 
{ 
auto char1 t; (t.x) = x; return t; 
} 

static __inline uchar1 make_uchar1(unsigned char x) 
{ 
auto uchar1 t; (t.x) = x; return t; 
} 

static __inline char2 make_char2(signed char x, signed char y) 
{ 
auto char2 t; (t.x) = x; (t.y) = y; return t; 
} 

static __inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
{ 
auto uchar2 t; (t.x) = x; (t.y) = y; return t; 
} 

static __inline char3 make_char3(signed char x, signed char y, signed char z) 
{ 
auto char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
} 

static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
{ 
auto uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
} 

static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
{ 
auto char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
} 

static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
{ 
auto uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
} 

static __inline short1 make_short1(short x) 
{ 
auto short1 t; (t.x) = x; return t; 
} 

static __inline ushort1 make_ushort1(unsigned short x) 
{ 
auto ushort1 t; (t.x) = x; return t; 
} 

static __inline short2 make_short2(short x, short y) 
{ 
auto short2 t; (t.x) = x; (t.y) = y; return t; 
} 

static __inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
{ 
auto ushort2 t; (t.x) = x; (t.y) = y; return t; 
} 

static __inline short3 make_short3(short x, short y, short z) 
{ 
auto short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
} 

static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
{ 
auto ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
} 

static __inline short4 make_short4(short x, short y, short z, short w) 
{ 
auto short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
} 

static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
{ 
auto ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
} 

static __inline int1 make_int1(int x) 
{ 
auto int1 t; (t.x) = x; return t; 
} 

static __inline uint1 make_uint1(unsigned x) 
{ 
auto uint1 t; (t.x) = x; return t; 
} 

static __inline int2 make_int2(int x, int y) 
{ 
auto int2 t; (t.x) = x; (t.y) = y; return t; 
} 

static __inline uint2 make_uint2(unsigned x, unsigned y) 
{ 
auto uint2 t; (t.x) = x; (t.y) = y; return t; 
} 

static __inline int3 make_int3(int x, int y, int z) 
{ 
auto int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
} 

static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
{ 
auto uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
} 

static __inline int4 make_int4(int x, int y, int z, int w) 
{ 
auto int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
} 

static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
{ 
auto uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
} 

static __inline long1 make_long1(long x) 
{ 
auto long1 t; (t.x) = x; return t; 
} 

static __inline ulong1 make_ulong1(unsigned long x) 
{ 
auto ulong1 t; (t.x) = x; return t; 
} 

static __inline long2 make_long2(long x, long y) 
{ 
auto long2 t; (t.x) = x; (t.y) = y; return t; 
} 

static __inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
{ 
auto ulong2 t; (t.x) = x; (t.y) = y; return t; 
} 



static __inline long3 make_long3(long x, long y, long z) 
{ 
auto long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
} 

static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
{ 
auto ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
} 

static __inline long4 make_long4(long x, long y, long z, long w) 
{ 
auto long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
} 

static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
{ 
auto ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
} 
#line 218 "c:\\cuda\\include\\vector_functions.h"
static __inline float1 make_float1(float x) 
{ 
auto float1 t; (t.x) = x; return t; 
} 

static __inline float2 make_float2(float x, float y) 
{ 
auto float2 t; (t.x) = x; (t.y) = y; return t; 
} 

static __inline float3 make_float3(float x, float y, float z) 
{ 
auto float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
} 

static __inline float4 make_float4(float x, float y, float z, float w) 
{ 
auto float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
} 

static __inline longlong1 make_longlong1(__int64 x) 
{ 
auto longlong1 t; (t.x) = x; return t; 
} 

static __inline ulonglong1 make_ulonglong1(unsigned __int64 x) 
{ 
auto ulonglong1 t; (t.x) = x; return t; 
} 

static __inline longlong2 make_longlong2(__int64 x, __int64 y) 
{ 
auto longlong2 t; (t.x) = x; (t.y) = y; return t; 
} 

static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y) 
{ 
auto ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
} 

static __inline double1 make_double1(double x) 
{ 
auto double1 t; (t.x) = x; return t; 
} 

static __inline double2 make_double2(double x, double y) 
{ 
auto double2 t; (t.x) = x; (t.y) = y; return t; 
} 
#line 35 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.h"
#pragma pack ( push, 8 )
#line 93 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.h"
extern "C" { typedef long clock_t; }
#line 117 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.h"
extern "C" { struct tm { 
int tm_sec; 
int tm_min; 
int tm_hour; 
int tm_mday; 
int tm_mon; 
int tm_year; 
int tm_wday; 
int tm_yday; 
int tm_isdst; 
}; }
#line 142 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.h"
extern "C" { extern int *__cdecl __daylight(); } 



extern "C" { extern long *__cdecl __dstbias(); } 



extern "C" { extern long *__cdecl __timezone(); } 



extern "C" { extern char **__cdecl __tzname(); } 


extern "C" { extern errno_t __cdecl _get_daylight(int *); } 
extern "C" { extern errno_t __cdecl _get_dstbias(long *); } 
extern "C" { extern errno_t __cdecl _get_timezone(long *); } 
extern "C" { extern errno_t __cdecl _get_tzname(size_t *, char *, size_t, int); } 



extern "C" { extern char *__cdecl asctime(const tm *); } 

extern "C" { extern errno_t __cdecl asctime_s(char *, size_t, const tm *); } 
#line 168 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.h"
template < size_t _Size > inline errno_t __cdecl asctime_s ( char ( & _Buffer ) [ _Size ], const struct tm * _Time ) { return asctime_s ( _Buffer, _Size, _Time ); }

extern "C" { extern char *__cdecl _ctime32(const __time32_t *); } 
extern "C" { extern errno_t __cdecl _ctime32_s(char *, size_t, const __time32_t *); } 
template < size_t _Size > inline errno_t __cdecl _ctime32_s ( char ( & _Buffer ) [ _Size ], const __time32_t * _Time ) { return _ctime32_s ( _Buffer, _Size, _Time ); }

extern "C" { extern clock_t __cdecl clock(); } 
extern "C" { extern double __cdecl _difftime32(__time32_t, __time32_t); } 

extern "C" { extern tm *__cdecl _gmtime32(const __time32_t *); } 
extern "C" { extern errno_t __cdecl _gmtime32_s(tm *, const __time32_t *); } 

extern "C" { extern tm *__cdecl _localtime32(const __time32_t *); } 
extern "C" { extern errno_t __cdecl _localtime32_s(tm *, const __time32_t *); } 

extern "C" { extern size_t __cdecl strftime(char *, size_t, const char *, const tm *); } 
extern "C" { extern size_t __cdecl _strftime_l(char *, size_t, const char *, const tm *, _locale_t); } 

extern "C" { extern errno_t __cdecl _strdate_s(char *, size_t); } 
template < size_t _Size > inline errno_t __cdecl _strdate_s ( char ( & _Buffer ) [ _Size ] ) { return _strdate_s ( _Buffer, _Size ); }
extern "C" { extern char *__cdecl _strdate(char *); } 

extern "C" { extern errno_t __cdecl _strtime_s(char *, size_t); } 
template < size_t _Size > inline errno_t __cdecl _strtime_s ( char ( & _Buffer ) [ _Size ] ) { return _strtime_s ( _Buffer, _Size ); }
extern "C" { extern char *__cdecl _strtime(char *); } 

extern "C" { extern __time32_t __cdecl _time32(__time32_t *); } 
extern "C" { extern __time32_t __cdecl _mktime32(tm *); } 
extern "C" { extern __time32_t __cdecl _mkgmtime32(tm *); } 




extern "C" { extern void __cdecl _tzset(); } 
#line 204 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.h"
extern "C" { extern double __cdecl _difftime64(__time64_t, __time64_t); } 
extern "C" { extern char *__cdecl _ctime64(const __time64_t *); } 
extern "C" { extern errno_t __cdecl _ctime64_s(char *, size_t, const __time64_t *); } 
template < size_t _Size > inline errno_t __cdecl _ctime64_s ( char ( & _Buffer ) [ _Size ], const __time64_t * _Time ) { return _ctime64_s ( _Buffer, _Size, _Time ); }

extern "C" { extern tm *__cdecl _gmtime64(const __time64_t *); } 
extern "C" { extern errno_t __cdecl _gmtime64_s(tm *, const __time64_t *); } 

extern "C" { extern tm *__cdecl _localtime64(const __time64_t *); } 
extern "C" { extern errno_t __cdecl _localtime64_s(tm *, const __time64_t *); } 

extern "C" { extern __time64_t __cdecl _mktime64(tm *); } 
extern "C" { extern __time64_t __cdecl _mkgmtime64(tm *); } 
extern "C" { extern __time64_t __cdecl _time64(__time64_t *); } 


extern "C" { extern __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using GetLocalTime instead. See online help for details.")) unsigned __cdecl _getsystime(tm *); } 
extern "C" { extern __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetLocalTime instead. See online help for details.")) unsigned __cdecl _setsystime(tm *, unsigned); } 
#line 233 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.h"
extern "C" { extern __wchar_t *__cdecl _wasctime(const tm *); } 
extern "C" { extern errno_t __cdecl _wasctime_s(__wchar_t *, size_t, const tm *); } 
template < size_t _Size > inline errno_t __cdecl _wasctime_s ( wchar_t ( & _Buffer ) [ _Size ], const struct tm * _Time ) { return _wasctime_s ( _Buffer, _Size, _Time ); }

extern "C" { extern __wchar_t *__cdecl _wctime32(const __time32_t *); } 
extern "C" { extern errno_t __cdecl _wctime32_s(__wchar_t *, size_t, const __time32_t *); } 
template < size_t _Size > inline errno_t __cdecl _wctime32_s ( wchar_t ( & _Buffer ) [ _Size ], const __time32_t * _Time ) { return _wctime32_s ( _Buffer, _Size, _Time ); }

extern "C" { extern size_t __cdecl wcsftime(__wchar_t *, size_t, const __wchar_t *, const tm *); } 
extern "C" { extern size_t __cdecl _wcsftime_l(__wchar_t *, size_t, const __wchar_t *, const tm *, _locale_t); } 

extern "C" { extern errno_t __cdecl _wstrdate_s(__wchar_t *, size_t); } 
template < size_t _Size > inline errno_t __cdecl _wstrdate_s ( wchar_t ( & _Buffer ) [ _Size ] ) { return _wstrdate_s ( _Buffer, _Size ); }
extern "C" { extern __wchar_t *__cdecl _wstrdate(__wchar_t *); } 

extern "C" { extern errno_t __cdecl _wstrtime_s(__wchar_t *, size_t); } 
template < size_t _Size > inline errno_t __cdecl _wstrtime_s ( wchar_t ( & _Buffer ) [ _Size ] ) { return _wstrtime_s ( _Buffer, _Size ); }
extern "C" { extern __wchar_t *__cdecl _wstrtime(__wchar_t *); } 

extern "C" { extern __wchar_t *__cdecl _wctime64(const __time64_t *); } 
extern "C" { extern errno_t __cdecl _wctime64_s(__wchar_t *, size_t, const __time64_t *); } 
template < size_t _Size > inline errno_t __cdecl _wctime64_s ( wchar_t ( & _Buffer ) [ _Size ], const __time64_t * _Time ) { return _wctime64_s ( _Buffer, _Size, _Time ); }
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wtime.inl"
#pragma warning(push)
#pragma warning(disable:4996)
#line 46 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wtime.inl"
extern "C" { static __inline __wchar_t *__cdecl _wctime(const time_t *_Time) 
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _wctime64(_Time); 
#pragma warning( pop )
} } 

extern "C" { static __inline errno_t __cdecl _wctime_s(__wchar_t *_Buffer, size_t _SizeInWords, const time_t *_Time) 
{ 
return _wctime64_s(_Buffer, _SizeInWords, _Time); 
} } 
#line 60 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wtime.inl"
#pragma warning(pop)
#line 84 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.inl"
extern "C" { static __inline double __cdecl difftime(time_t _Time1, time_t _Time2) 
{ 
return _difftime64(_Time1, _Time2); 
} } 
extern "C" { static __inline char *__cdecl ctime(const time_t *_Time) 
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _ctime64(_Time); 
#pragma warning( pop )
} } 

extern "C" { static __inline errno_t __cdecl ctime_s(char *_Buffer, size_t _SizeInBytes, const time_t *_Time) 
{ 
return _ctime64_s(_Buffer, _SizeInBytes, _Time); 
} } 
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.inl"
extern "C" { static __inline tm *__cdecl gmtime(const time_t *_Time) 
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _gmtime64(_Time); 
#pragma warning( pop )
} } 

extern "C" { static __inline errno_t __cdecl gmtime_s(tm *_Tm, const time_t *_Time) 
{ 
return _gmtime64_s(_Tm, _Time); 
} } 
#line 114 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.inl"
extern "C" { static __inline tm *__cdecl localtime(const time_t *_Time) 
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _localtime64(_Time); 
#pragma warning( pop )
} } 
extern "C" { static __inline errno_t __cdecl localtime_s(tm *_Tm, const time_t *_Time) 
{ 
return _localtime64_s(_Tm, _Time); 
} } 
extern "C" { static __inline time_t __cdecl mktime(tm *_Tm) 
{ 
return _mktime64(_Tm); 
} } 
extern "C" { static __inline time_t __cdecl _mkgmtime(tm *_Tm) 
{ 
return _mkgmtime64(_Tm); 
} } 
extern "C" { static __inline time_t __cdecl time(time_t *_Time) 
{ 
return _time64(_Time); 
} } 
#line 279 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.h"
extern "C" int daylight; 
extern "C" long timezone; 
extern "C" char *tzname[2]; 
#line 284 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.h"
extern "C" { extern void __cdecl tzset(); } 
#line 294 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\time.h"
#pragma pack ( pop )
#line 48 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern void *__cdecl _memccpy(void *, const void *, int, size_t); } 
extern "C" { extern const void *__cdecl memchr(const void *, int, size_t); } 
extern "C" { extern int __cdecl _memicmp(const void *, const void *, size_t); } 
extern "C" { extern int __cdecl _memicmp_l(const void *, const void *, size_t, _locale_t); } 
extern "C" { extern int __cdecl memcmp(const void *, const void *, size_t); } 
extern "C" { extern void *__cdecl memcpy(void *, const void *, size_t); } 

extern "C" { extern errno_t __cdecl memcpy_s(void *, rsize_t, const void *, rsize_t); } 
#line 57 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern void *__cdecl memset(void *, int, size_t); } 



extern "C" { extern void *__cdecl memccpy(void *, const void *, int, size_t); } 
extern "C" { extern int __cdecl memicmp(const void *, const void *, size_t); } 
#line 67 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern errno_t __cdecl _strset_s(char *, size_t, int); } 
template < size_t _Size > inline errno_t __cdecl _strset_s ( char ( & _Dest ) [ _Size ], int _Value ) { return _strset_s ( _Dest, _Size, _Value ); }
extern "C" { extern char *__cdecl _strset(char *, int); } 

extern "C" errno_t __cdecl strcpy_s(char *, rsize_t, const char *); 
#line 73 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl strcpy_s ( char ( & _Dest ) [ _Size ], const char * _Source ) { return strcpy_s ( _Dest, _Size, _Source ); }
extern "C" { extern char *__cdecl strcpy(char *, const char *); } 

extern "C" { extern errno_t __cdecl strcat_s(char *, rsize_t, const char *); } 
#line 78 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl strcat_s ( char ( & _Dest ) [ _Size ], const char * _Source ) { return strcat_s ( _Dest, _Size, _Source ); }
extern "C" { extern char *__cdecl strcat(char *, const char *); } 
extern "C" { extern int __cdecl strcmp(const char *, const char *); } 
extern "C" size_t __cdecl strlen(const char *); 
extern "C" { extern size_t __cdecl strnlen(const char *, size_t); } 

extern "C" { static __inline size_t __cdecl strnlen_s(const char *_Str, size_t _MaxCount) 
{ 
return (_Str == (0)) ? (0) : strnlen(_Str, _MaxCount); 
} } 
#line 90 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern errno_t __cdecl memmove_s(void *, rsize_t, const void *, rsize_t); } 
#line 96 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern void *__cdecl memmove(void *, const void *, size_t); } 
#line 104 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern char *__cdecl _strdup(const char *); } 
#line 110 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern const char *__cdecl strchr(const char *, int); } 
extern "C" { extern int __cdecl _stricmp(const char *, const char *); } 
extern "C" { extern int __cdecl _strcmpi(const char *, const char *); } 
extern "C" { extern int __cdecl _stricmp_l(const char *, const char *, _locale_t); } 
extern "C" { extern int __cdecl strcoll(const char *, const char *); } 
extern "C" { extern int __cdecl _strcoll_l(const char *, const char *, _locale_t); } 
extern "C" { extern int __cdecl _stricoll(const char *, const char *); } 
extern "C" { extern int __cdecl _stricoll_l(const char *, const char *, _locale_t); } 
extern "C" { extern int __cdecl _strncoll(const char *, const char *, size_t); } 
extern "C" { extern int __cdecl _strncoll_l(const char *, const char *, size_t, _locale_t); } 
extern "C" { extern int __cdecl _strnicoll(const char *, const char *, size_t); } 
extern "C" { extern int __cdecl _strnicoll_l(const char *, const char *, size_t, _locale_t); } 
extern "C" { extern size_t __cdecl strcspn(const char *, const char *); } 
extern "C" { extern char *__cdecl _strerror(const char *); } 
extern "C" { extern errno_t __cdecl _strerror_s(char *, size_t, const char *); } 
template < size_t _Size > inline errno_t __cdecl _strerror_s ( char ( & _Buffer ) [ _Size ], const char * _ErrorMessage ) { return _strerror_s ( _Buffer, _Size, _ErrorMessage ); }
extern "C" { extern char *__cdecl strerror(int); } 

extern "C" { extern errno_t __cdecl strerror_s(char *, size_t, int); } 
#line 130 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl strerror_s ( char ( & _Buffer ) [ _Size ], int _ErrorMessage ) { return strerror_s ( _Buffer, _Size, _ErrorMessage ); }
extern "C" { extern errno_t __cdecl _strlwr_s(char *, size_t); } 
template < size_t _Size > inline errno_t __cdecl _strlwr_s ( char ( & _String ) [ _Size ] ) { return _strlwr_s ( _String, _Size ); }
extern "C" { extern char *__cdecl _strlwr(char *); } 
extern "C" { extern errno_t __cdecl _strlwr_s_l(char *, size_t, _locale_t); } 
template < size_t _Size > inline errno_t __cdecl _strlwr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) { return _strlwr_s_l ( _String, _Size, _Locale ); }
extern "C" { extern char *__cdecl _strlwr_l(char *, _locale_t); } 

extern "C" { extern errno_t __cdecl strncat_s(char *, rsize_t, const char *, rsize_t); } 
#line 140 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl strncat_s ( char ( & _Dest ) [ _Size ], const char * _Source, size_t _Count ) { return strncat_s ( _Dest, _Size, _Source, _Count ); }
#pragma warning(push)
#pragma warning(disable:6059)

extern "C" { extern char *__cdecl strncat(char *, const char *, size_t); } 
#pragma warning(pop)
#line 149 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern int __cdecl strncmp(const char *, const char *, size_t); } 
#line 151 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern int __cdecl _strnicmp(const char *, const char *, size_t); } 
extern "C" { extern int __cdecl _strnicmp_l(const char *, const char *, size_t, _locale_t); } 

extern "C" { extern errno_t __cdecl strncpy_s(char *, rsize_t, const char *, rsize_t); } 
#line 156 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl strncpy_s ( char ( & _Dest ) [ _Size ], const char * _Source, size_t _Count ) { return strncpy_s ( _Dest, _Size, _Source, _Count ); }
extern "C" { extern char *__cdecl strncpy(char *, const char *, size_t); } 
extern "C" { extern errno_t __cdecl _strnset_s(char *, size_t, int, size_t); } 
template < size_t _Size > inline errno_t __cdecl _strnset_s ( char ( & _Dest ) [ _Size ], int _Val, size_t _Count ) { return _strnset_s ( _Dest, _Size, _Val, _Count ); }
extern "C" { extern char *__cdecl _strnset(char *, int, size_t); } 
extern "C" { extern const char *__cdecl strpbrk(const char *, const char *); } 
extern "C" { extern const char *__cdecl strrchr(const char *, int); } 
extern "C" { extern char *__cdecl _strrev(char *); } 
extern "C" { extern size_t __cdecl strspn(const char *, const char *); } 
extern "C" { extern const char *__cdecl strstr(const char *, const char *); } 
extern "C" { extern char *__cdecl strtok(char *, const char *); } 

extern "C" { extern char *__cdecl strtok_s(char *, const char *, char **); } 
#line 170 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern errno_t __cdecl _strupr_s(char *, size_t); } 
template < size_t _Size > inline errno_t __cdecl _strupr_s ( char ( & _String ) [ _Size ] ) { return _strupr_s ( _String, _Size ); }
extern "C" { extern char *__cdecl _strupr(char *); } 
extern "C" { extern errno_t __cdecl _strupr_s_l(char *, size_t, _locale_t); } 
template < size_t _Size > inline errno_t __cdecl _strupr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) { return _strupr_s_l ( _String, _Size, _Locale ); }
extern "C" { extern char *__cdecl _strupr_l(char *, _locale_t); } 
extern "C" { extern size_t __cdecl strxfrm(char *, const char *, size_t); } 
extern "C" { extern size_t __cdecl _strxfrm_l(char *, const char *, size_t, _locale_t); } 
#line 183 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
inline char *__cdecl strchr(char *_Str, int _Ch) 
{ return (char *)strchr((const char *)_Str, _Ch); } 
inline char *__cdecl strpbrk(char *_Str, const char *_Control) 
{ return (char *)strpbrk((const char *)_Str, _Control); } 
inline char *__cdecl strrchr(char *_Str, int _Ch) 
{ return (char *)strrchr((const char *)_Str, _Ch); } 
inline char *__cdecl strstr(char *_Str, const char *_SubStr) 
{ return (char *)strstr((const char *)_Str, _SubStr); } 
#line 194 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
inline void *__cdecl memchr(void *_Pv, int _C, size_t _N) 
{ return (void *)memchr((const void *)_Pv, _C, _N); } 
#line 207 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern char *__cdecl strdup(const char *); } 
#line 214 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern int __cdecl strcmpi(const char *, const char *); } 
extern "C" { extern int __cdecl stricmp(const char *, const char *); } 
extern "C" { extern char *__cdecl strlwr(char *); } 
extern "C" { extern int __cdecl strnicmp(const char *, const char *, size_t); } 
extern "C" { extern char *__cdecl strnset(char *, int, size_t); } 
extern "C" { extern char *__cdecl strrev(char *); } 
extern "C" { extern char *__cdecl strset(char *, int); } 
extern "C" { extern char *__cdecl strupr(char *); } 
#line 235 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern __wchar_t *__cdecl _wcsdup(const __wchar_t *); } 
#line 242 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern errno_t __cdecl wcscat_s(__wchar_t *, rsize_t, const __wchar_t *); } 
#line 244 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl wcscat_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source ) { return wcscat_s ( _Dest, _Size, _Source ); }
extern "C" { extern __wchar_t *__cdecl wcscat(__wchar_t *, const __wchar_t *); } 
extern "C" { extern const __wchar_t *__cdecl wcschr(const __wchar_t *, __wchar_t); } 
extern "C" { extern int __cdecl wcscmp(const __wchar_t *, const __wchar_t *); } 

extern "C" { extern errno_t __cdecl wcscpy_s(__wchar_t *, rsize_t, const __wchar_t *); } 
#line 251 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl wcscpy_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source ) { return wcscpy_s ( _Dest, _Size, _Source ); }
extern "C" { extern __wchar_t *__cdecl wcscpy(__wchar_t *, const __wchar_t *); } 
extern "C" { extern size_t __cdecl wcscspn(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern size_t __cdecl wcslen(const __wchar_t *); } 
extern "C" { extern size_t __cdecl wcsnlen(const __wchar_t *, size_t); } 

extern "C" { static __inline size_t __cdecl wcsnlen_s(const __wchar_t *_Src, size_t _MaxCount) 
{ 
return (_Src == (0)) ? (0) : wcsnlen(_Src, _MaxCount); 
} } 
#line 263 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern errno_t __cdecl wcsncat_s(__wchar_t *, rsize_t, const __wchar_t *, rsize_t); } 
#line 265 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl wcsncat_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _Count ) { return wcsncat_s ( _Dest, _Size, _Source, _Count ); }
#pragma warning(push)
#pragma warning(disable:6059)
extern "C" { extern __wchar_t *__cdecl wcsncat(__wchar_t *, const __wchar_t *, size_t); } 
#pragma warning(pop)
extern "C" { extern int __cdecl wcsncmp(const __wchar_t *, const __wchar_t *, size_t); } 

extern "C" { extern errno_t __cdecl wcsncpy_s(__wchar_t *, rsize_t, const __wchar_t *, rsize_t); } 
#line 274 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl wcsncpy_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _Count ) { return wcsncpy_s ( _Dest, _Size, _Source, _Count ); }
extern "C" { extern __wchar_t *__cdecl wcsncpy(__wchar_t *, const __wchar_t *, size_t); } 
extern "C" { extern const __wchar_t *__cdecl wcspbrk(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern const __wchar_t *__cdecl wcsrchr(const __wchar_t *, __wchar_t); } 
extern "C" { extern size_t __cdecl wcsspn(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern const __wchar_t *__cdecl wcsstr(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern __wchar_t *__cdecl wcstok(__wchar_t *, const __wchar_t *); } 

extern "C" { extern __wchar_t *__cdecl wcstok_s(__wchar_t *, const __wchar_t *, __wchar_t **); } 
#line 284 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern __wchar_t *__cdecl _wcserror(int); } 
extern "C" { extern errno_t __cdecl _wcserror_s(__wchar_t *, size_t, int); } 
template < size_t _Size > inline errno_t __cdecl _wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], int _Error ) { return _wcserror_s ( _Buffer, _Size, _Error ); }
extern "C" { extern __wchar_t *__cdecl __wcserror(const __wchar_t *); } 
extern "C" { extern errno_t __cdecl __wcserror_s(__wchar_t *, size_t, const __wchar_t *); } 
template < size_t _Size > inline errno_t __cdecl __wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], const wchar_t * _ErrorMessage ) { return __wcserror_s ( _Buffer, _Size, _ErrorMessage ); }

extern "C" { extern int __cdecl _wcsicmp(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern int __cdecl _wcsicmp_l(const __wchar_t *, const __wchar_t *, _locale_t); } 
extern "C" { extern int __cdecl _wcsnicmp(const __wchar_t *, const __wchar_t *, size_t); } 
extern "C" { extern int __cdecl _wcsnicmp_l(const __wchar_t *, const __wchar_t *, size_t, _locale_t); } 
extern "C" { extern errno_t __cdecl _wcsnset_s(__wchar_t *, size_t, __wchar_t, size_t); } 
template < size_t _Size > inline errno_t __cdecl _wcsnset_s ( wchar_t ( & _Dst ) [ _Size ], wchar_t _Val, size_t _MaxCount ) { return _wcsnset_s ( _Dst, _Size, _Val, _MaxCount ); }
extern "C" { extern __wchar_t *__cdecl _wcsnset(__wchar_t *, __wchar_t, size_t); } 
extern "C" { extern __wchar_t *__cdecl _wcsrev(__wchar_t *); } 
extern "C" { extern errno_t __cdecl _wcsset_s(__wchar_t *, size_t, __wchar_t); } 
template < size_t _Size > inline errno_t __cdecl _wcsset_s ( wchar_t ( & _Str ) [ _Size ], wchar_t _Val ) { return _wcsset_s ( _Str, _Size, _Val ); }
extern "C" { extern __wchar_t *__cdecl _wcsset(__wchar_t *, __wchar_t); } 

extern "C" { extern errno_t __cdecl _wcslwr_s(__wchar_t *, size_t); } 
template < size_t _Size > inline errno_t __cdecl _wcslwr_s ( wchar_t ( & _String ) [ _Size ] ) { return _wcslwr_s ( _String, _Size ); }
extern "C" { extern __wchar_t *__cdecl _wcslwr(__wchar_t *); } 
extern "C" { extern errno_t __cdecl _wcslwr_s_l(__wchar_t *, size_t, _locale_t); } 
template < size_t _Size > inline errno_t __cdecl _wcslwr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) { return _wcslwr_s_l ( _String, _Size, _Locale ); }
extern "C" { extern __wchar_t *__cdecl _wcslwr_l(__wchar_t *, _locale_t); } 
extern "C" { extern errno_t __cdecl _wcsupr_s(__wchar_t *, size_t); } 
template < size_t _Size > inline errno_t __cdecl _wcsupr_s ( wchar_t ( & _String ) [ _Size ] ) { return _wcsupr_s ( _String, _Size ); }
extern "C" { extern __wchar_t *__cdecl _wcsupr(__wchar_t *); } 
extern "C" { extern errno_t __cdecl _wcsupr_s_l(__wchar_t *, size_t, _locale_t); } 
template < size_t _Size > inline errno_t __cdecl _wcsupr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) { return _wcsupr_s_l ( _String, _Size, _Locale ); }
extern "C" { extern __wchar_t *__cdecl _wcsupr_l(__wchar_t *, _locale_t); } 
extern "C" { extern size_t __cdecl wcsxfrm(__wchar_t *, const __wchar_t *, size_t); } 
extern "C" { extern size_t __cdecl _wcsxfrm_l(__wchar_t *, const __wchar_t *, size_t, _locale_t); } 
extern "C" { extern int __cdecl wcscoll(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern int __cdecl _wcscoll_l(const __wchar_t *, const __wchar_t *, _locale_t); } 
extern "C" { extern int __cdecl _wcsicoll(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern int __cdecl _wcsicoll_l(const __wchar_t *, const __wchar_t *, _locale_t); } 
extern "C" { extern int __cdecl _wcsncoll(const __wchar_t *, const __wchar_t *, size_t); } 
extern "C" { extern int __cdecl _wcsncoll_l(const __wchar_t *, const __wchar_t *, size_t, _locale_t); } 
extern "C" { extern int __cdecl _wcsnicoll(const __wchar_t *, const __wchar_t *, size_t); } 
extern "C" { extern int __cdecl _wcsnicoll_l(const __wchar_t *, const __wchar_t *, size_t, _locale_t); } 
#line 330 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
inline __wchar_t *__cdecl wcschr(__wchar_t *_Str, __wchar_t _Ch) 
{ return (__wchar_t *)wcschr((const __wchar_t *)_Str, _Ch); } 
inline __wchar_t *__cdecl wcspbrk(__wchar_t *_Str, const __wchar_t *_Control) 
{ return (__wchar_t *)wcspbrk((const __wchar_t *)_Str, _Control); } 
inline __wchar_t *__cdecl wcsrchr(__wchar_t *_Str, __wchar_t _Ch) 
{ return (__wchar_t *)wcsrchr((const __wchar_t *)_Str, _Ch); } 
inline __wchar_t *__cdecl wcsstr(__wchar_t *_Str, const __wchar_t *_SubStr) 
{ return (__wchar_t *)wcsstr((const __wchar_t *)_Str, _SubStr); } 
#line 349 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern __wchar_t *__cdecl wcsdup(const __wchar_t *); } 
#line 359 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\string.h"
extern "C" { extern int __cdecl wcsicmp(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern int __cdecl wcsnicmp(const __wchar_t *, const __wchar_t *, size_t); } 
extern "C" { extern __wchar_t *__cdecl wcsnset(__wchar_t *, __wchar_t, size_t); } 
extern "C" { extern __wchar_t *__cdecl wcsrev(__wchar_t *); } 
extern "C" { extern __wchar_t *__cdecl wcsset(__wchar_t *, __wchar_t); } 
extern "C" { extern __wchar_t *__cdecl wcslwr(__wchar_t *); } 
extern "C" { extern __wchar_t *__cdecl wcsupr(__wchar_t *); } 
extern "C" { extern int __cdecl wcsicoll(const __wchar_t *, const __wchar_t *); } 
#line 56 "c:\\cuda\\include\\common_functions.h"
extern "C" { extern clock_t clock(); } 


extern "C" { extern void *memset(void *, int, size_t); } 


extern "C" { extern void *memcpy(void *, const void *, size_t); } 
#line 65 "c:\\cuda\\include\\math_functions.h"
extern "C" { extern int abs(int); } 

extern "C" { extern long labs(long); } 

extern "C" { extern __int64 llabs(__int64); } 

extern "C" { extern double fabs(double); } 

extern "C" { inline float fabsf(float); } 


extern "C" { extern int min(int, int); } 

extern "C" { extern unsigned umin(unsigned, unsigned); } 

extern "C" { extern __int64 llmin(__int64, __int64); } 

extern "C" { extern unsigned __int64 ullmin(unsigned __int64, unsigned __int64); } 

extern "C" { extern float fminf(float, float); } 

extern "C" { extern double fmin(double, double); } 


extern "C" { extern int max(int, int); } 

extern "C" { extern unsigned umax(unsigned, unsigned); } 

extern "C" { extern __int64 llmax(__int64, __int64); } 

extern "C" { extern unsigned __int64 ullmax(unsigned __int64, unsigned __int64); } 

extern "C" { extern float fmaxf(float, float); } 

extern "C" { extern double fmax(double, double); } 


extern "C" { extern double sin(double); } 

extern "C" { inline float sinf(float); } 


extern "C" { extern double cos(double); } 

extern "C" { inline float cosf(float); } 


extern "C" { extern void sincos(double, double *, double *); } 

extern "C" { extern void sincosf(float, float *, float *); } 


extern "C" { extern double tan(double); } 

extern "C" { inline float tanf(float); } 


extern "C" { extern double sqrt(double); } 

extern "C" { inline float sqrtf(float); } 


extern "C" { extern double rsqrt(double); } 

extern "C" { extern float rsqrtf(float); } 


extern "C" { extern double exp2(double); } 

extern "C" { extern float exp2f(float); } 


extern "C" { extern double exp10(double); } 

extern "C" { extern float exp10f(float); } 


extern "C" { extern double expm1(double); } 

extern "C" { extern float expm1f(float); } 


extern "C" { extern double log2(double); } 

extern "C" { extern float log2f(float); } 


extern "C" { extern double log10(double); } 

extern "C" { inline float log10f(float); } 


extern "C" { extern double log(double); } 

extern "C" { inline float logf(float); } 


extern "C" { extern double log1p(double); } 

extern "C" { extern float log1pf(float); } 


extern "C" { extern double floor(double); } 

extern "C" { inline float floorf(float); } 


extern "C" { extern double exp(double); } 

extern "C" { inline float expf(float); } 


extern "C" { extern double cosh(double); } 

extern "C" { inline float coshf(float); } 


extern "C" { extern double sinh(double); } 

extern "C" { inline float sinhf(float); } 


extern "C" { extern double tanh(double); } 

extern "C" { inline float tanhf(float); } 


extern "C" { extern double acosh(double); } 

extern "C" { extern float acoshf(float); } 


extern "C" { extern double asinh(double); } 

extern "C" { extern float asinhf(float); } 


extern "C" { extern double atanh(double); } 

extern "C" { extern float atanhf(float); } 


extern "C" { extern double ldexp(double, int); } 

extern "C" { inline float ldexpf(float, int); } 


extern "C" { extern double logb(double); } 

extern "C" { extern float logbf(float); } 


extern "C" { extern int ilogb(double); } 

extern "C" { extern int ilogbf(float); } 


extern "C" { extern double scalbn(double, int); } 

extern "C" { extern float scalbnf(float, int); } 


extern "C" { extern double scalbln(double, long); } 

extern "C" { extern float scalblnf(float, long); } 


extern "C" { extern double frexp(double, int *); } 

extern "C" { inline float frexpf(float, int *); } 


extern "C" { extern double round(double); } 

extern "C" { extern float roundf(float); } 


extern "C" { extern long lround(double); } 

extern "C" { extern long lroundf(float); } 


extern "C" { extern __int64 llround(double); } 

extern "C" { extern __int64 llroundf(float); } 


extern "C" { extern double rint(double); } 

extern "C" { extern float rintf(float); } 


extern "C" { extern long lrint(double); } 

extern "C" { extern long lrintf(float); } 


extern "C" { extern __int64 llrint(double); } 

extern "C" { extern __int64 llrintf(float); } 


extern "C" { extern double nearbyint(double); } 

extern "C" { extern float nearbyintf(float); } 


extern "C" { extern double ceil(double); } 

extern "C" { inline float ceilf(float); } 


extern "C" { extern double trunc(double); } 

extern "C" { extern float truncf(float); } 


extern "C" { extern double fdim(double, double); } 

extern "C" { extern float fdimf(float, float); } 


extern "C" { extern double atan2(double, double); } 

extern "C" { inline float atan2f(float, float); } 


extern "C" { extern double atan(double); } 

extern "C" { inline float atanf(float); } 


extern "C" { extern double asin(double); } 

extern "C" { inline float asinf(float); } 


extern "C" { extern double acos(double); } 

extern "C" { inline float acosf(float); } 


extern "C" { extern double hypot(double, double); } 

extern "C" { extern float hypotf(float, float); } 


extern "C" { extern double cbrt(double); } 

extern "C" { extern float cbrtf(float); } 


extern "C" { extern double pow(double, double); } 

extern "C" { inline float powf(float, float); } 


extern "C" { extern double modf(double, double *); } 

extern "C" { inline float modff(float, float *); } 


extern "C" { extern double fmod(double, double); } 

extern "C" { inline float fmodf(float, float); } 


extern "C" { extern double remainder(double, double); } 

extern "C" { extern float remainderf(float, float); } 


extern "C" { extern double remquo(double, double, int *); } 

extern "C" { extern float remquof(float, float, int *); } 


extern "C" { extern double erf(double); } 

extern "C" { extern float erff(float); } 


extern "C" { extern double erfinv(double); } 

extern "C" { extern float erfinvf(float); } 


extern "C" { extern double erfc(double); } 

extern "C" { extern float erfcf(float); } 


extern "C" { extern double erfcinv(double); } 

extern "C" { extern float erfcinvf(float); } 


extern "C" { extern double lgamma(double); } 

extern "C" { extern float lgammaf(float); } 


extern "C" { extern double tgamma(double); } 

extern "C" { extern float tgammaf(float); } 


extern "C" { extern double copysign(double, double); } 

extern "C" { extern float copysignf(float, float); } 


extern "C" { extern double nextafter(double, double); } 

extern "C" { extern float nextafterf(float, float); } 


extern "C" { extern double nan(const char *); } 

extern "C" { extern float nanf(const char *); } 


extern "C" { extern int __isinf(double); } 

extern "C" { extern int __isinff(float); } 


extern "C" { extern int __isnan(double); } 

extern "C" { extern int __isnanf(float); } 
#line 408 "c:\\cuda\\include\\math_functions.h"
extern "C" { extern int __finite(double); } 

extern "C" { extern int __finitef(float); } 

extern "C" { extern int __signbit(double); } 
#line 417 "c:\\cuda\\include\\math_functions.h"
extern "C" { extern int __signbitf(float); } 


extern "C" { extern double fma(double, double, double); } 

extern "C" { extern float fmaf(float, float, float); } 
#line 25 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
#pragma pack ( push, 8 )
#line 39 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" { struct _exception { 
int type; 
char *name; 
double arg1; 
double arg2; 
double retval; 
}; }
#line 56 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" { struct _complex { 
double x; double y; 
}; }
#line 90 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" double _HUGE; 
#line 103 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" { extern int __cdecl abs(int); } 
extern "C" { extern long __cdecl labs(long); } 
#line 107 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" { extern double __cdecl acos(double); } 
extern "C" { extern double __cdecl asin(double); } 
extern "C" { extern double __cdecl atan(double); } 
extern "C" { extern double __cdecl atan2(double, double); } 

extern "C" { extern double __cdecl _copysign(double, double); } 
extern "C" { extern double __cdecl _chgsign(double); } 
#line 116 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" { extern double __cdecl cos(double); } 
extern "C" { extern double __cdecl cosh(double); } 
extern "C" { extern double __cdecl exp(double); } 
extern "C" { extern double __cdecl fabs(double); } 
extern "C" { extern double __cdecl fmod(double, double); } 
extern "C" { extern double __cdecl log(double); } 
extern "C" { extern double __cdecl log10(double); } 
extern "C" { extern double __cdecl pow(double, double); } 
extern "C" { extern double __cdecl sin(double); } 
extern "C" { extern double __cdecl sinh(double); } 
extern "C" { extern double __cdecl tan(double); } 
extern "C" { extern double __cdecl tanh(double); } 
extern "C" { extern double __cdecl sqrt(double); } 


extern "C" { extern double __cdecl atof(const char *); } 
extern "C" { extern double __cdecl _atof_l(const char *, _locale_t); } 
#line 135 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" { extern double __cdecl _cabs(_complex); } 
extern "C" { extern double __cdecl ceil(double); } 
extern "C" { extern double __cdecl floor(double); } 
extern "C" { extern double __cdecl frexp(double, int *); } 
extern "C" { extern double __cdecl _hypot(double, double); } 
extern "C" { extern double __cdecl _j0(double); } 
extern "C" { extern double __cdecl _j1(double); } 
extern "C" { extern double __cdecl _jn(int, double); } 
extern "C" { extern double __cdecl ldexp(double, int); } 
#line 149 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" { extern int __cdecl _matherr(_exception *); } 
#line 152 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" { extern double __cdecl modf(double, double *); } 

extern "C" { extern double __cdecl _y0(double); } 
extern "C" { extern double __cdecl _y1(double); } 
extern "C" { extern double __cdecl _yn(int, double); } 




extern "C" { extern int __cdecl _set_SSE2_enable(int); } 
extern "C" { extern float __cdecl _hypotf(float, float); } 
#line 317 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" { inline long double acosl(long double _X) 
{ return acos((double)_X); } } 
extern "C" { inline long double asinl(long double _X) 
{ return asin((double)_X); } } 
extern "C" { inline long double atanl(long double _X) 
{ return atan((double)_X); } } 
extern "C" { inline long double atan2l(long double _Y, long double _X) 
{ return atan2((double)_Y, (double)_X); } } 
extern "C" { inline long double ceill(long double _X) 
{ return ceil((double)_X); } } 
extern "C" { inline long double cosl(long double _X) 
{ return cos((double)_X); } } 
extern "C" { inline long double coshl(long double _X) 
{ return cosh((double)_X); } } 
extern "C" { inline long double expl(long double _X) 
{ return exp((double)_X); } } 
extern "C" { inline long double fabsl(long double _X) 
{ return fabs((double)_X); } } 
extern "C" { inline long double floorl(long double _X) 
{ return floor((double)_X); } } 
extern "C" { inline long double fmodl(long double _X, long double _Y) 
{ return fmod((double)_X, (double)_Y); } } 
extern "C" { inline long double frexpl(long double _X, int *_Y) 
{ return frexp((double)_X, _Y); } } 
extern "C" { inline long double ldexpl(long double _X, int _Y) 
{ return ldexp((double)_X, _Y); } } 
extern "C" { inline long double logl(long double _X) 
{ return log((double)_X); } } 
extern "C" { inline long double log10l(long double _X) 
{ return log10((double)_X); } } 
extern "C" { inline long double modfl(long double _X, long double *_Y) 
{ auto double _Di; auto double _Df = modf((double)_X, &_Di); 
(*_Y) = (long double)_Di; 
return _Df; } } 
extern "C" { inline long double powl(long double _X, long double _Y) 
{ return pow((double)_X, (double)_Y); } } 
extern "C" { inline long double sinl(long double _X) 
{ return sin((double)_X); } } 
extern "C" { inline long double sinhl(long double _X) 
{ return sinh((double)_X); } } 
extern "C" { inline long double sqrtl(long double _X) 
{ return sqrt((double)_X); } } 

extern "C" { inline long double tanl(long double _X) 
{ return tan((double)_X); } } 
#line 366 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" { inline long double tanhl(long double _X) 
{ return tanh((double)_X); } } 

extern "C" { inline long double _chgsignl(long double _Number) 
{ 
return _chgsign(static_cast< double>(_Number)); 
} } 

extern "C" { inline long double _copysignl(long double _Number, long double _Sign) 
{ 
return _copysign(static_cast< double>(_Number), static_cast< double>(_Sign)); 
} } 

extern "C" { inline float frexpf(float _X, int *_Y) 
{ return (float)frexp((double)_X, _Y); } } 


extern "C" { inline float fabsf(float _X) 
{ return (float)fabs((double)_X); } } 
extern "C" { inline float ldexpf(float _X, int _Y) 
{ return (float)ldexp((double)_X, _Y); } } 

extern "C" { inline float acosf(float _X) 
{ return (float)acos((double)_X); } } 
extern "C" { inline float asinf(float _X) 
{ return (float)asin((double)_X); } } 
extern "C" { inline float atanf(float _X) 
{ return (float)atan((double)_X); } } 
extern "C" { inline float atan2f(float _Y, float _X) 
{ return (float)atan2((double)_Y, (double)_X); } } 
extern "C" { inline float ceilf(float _X) 
{ return (float)ceil((double)_X); } } 
extern "C" { inline float cosf(float _X) 
{ return (float)cos((double)_X); } } 
extern "C" { inline float coshf(float _X) 
{ return (float)cosh((double)_X); } } 
extern "C" { inline float expf(float _X) 
{ return (float)exp((double)_X); } } 
extern "C" { inline float floorf(float _X) 
{ return (float)floor((double)_X); } } 
extern "C" { inline float fmodf(float _X, float _Y) 
{ return (float)fmod((double)_X, (double)_Y); } } 
extern "C" { inline float logf(float _X) 
{ return (float)log((double)_X); } } 
extern "C" { inline float log10f(float _X) 
{ return (float)log10((double)_X); } } 
extern "C" { inline float modff(float _X, float *_Y) 
{ auto double _Di; auto double _Df = modf((double)_X, &_Di); 
(*_Y) = (float)_Di; 
return (float)_Df; } } 
extern "C" { inline float powf(float _X, float _Y) 
{ return (float)pow((double)_X, (double)_Y); } } 
extern "C" { inline float sinf(float _X) 
{ return (float)sin((double)_X); } } 
extern "C" { inline float sinhf(float _X) 
{ return (float)sinh((double)_X); } } 
extern "C" { inline float sqrtf(float _X) 
{ return (float)sqrt((double)_X); } } 
extern "C" { inline float tanf(float _X) 
{ return (float)tan((double)_X); } } 
extern "C" { inline float tanhf(float _X) 
{ return (float)tanh((double)_X); } } 
#line 449 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" double HUGE; 
#line 454 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
extern "C" { extern double __cdecl cabs(_complex); } 
extern "C" { extern double __cdecl hypot(double, double); } 
extern "C" { extern double __cdecl j0(double); } 
extern "C" { extern double __cdecl j1(double); } 
extern "C" { extern double __cdecl jn(int, double); } 
extern "C" { extern double __cdecl y0(double); } 
extern "C" { extern double __cdecl y1(double); } 
extern "C" { extern double __cdecl yn(int, double); } 
#line 472 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
template < class _Ty > inline
        _Ty _Pow_int ( _Ty _X, int _Y )
        { unsigned int _N;
        if ( _Y >= 0 )
                _N = ( unsigned int ) _Y;
        else
                _N = ( unsigned int ) ( - _Y );
        for ( _Ty _Z = _Ty ( 1 );; _X *= _X )
                { if ( ( _N & 1 ) != 0 )
                        _Z *= _X;
                if ( ( _N >>= 1 ) == 0 )
                        return ( _Y < 0 ? _Ty ( 1 ) / _Z : _Z ); } }

inline long __cdecl abs(long _X) 
{ return labs(_X); } 
inline double __cdecl abs(double _X) 
{ return fabs(_X); } 
inline double __cdecl pow(double _X, int _Y) 
{ return _Pow_int(_X, _Y); } 
inline float __cdecl abs(float _X) 
{ return fabsf(_X); } 
inline float __cdecl acos(float _X) 
{ return acosf(_X); } 
inline float __cdecl asin(float _X) 
{ return asinf(_X); } 
inline float __cdecl atan(float _X) 
{ return atanf(_X); } 
inline float __cdecl atan2(float _Y, float _X) 
{ return atan2f(_Y, _X); } 
inline float __cdecl ceil(float _X) 
{ return ceilf(_X); } 
inline float __cdecl cos(float _X) 
{ return cosf(_X); } 
inline float __cdecl cosh(float _X) 
{ return coshf(_X); } 
inline float __cdecl exp(float _X) 
{ return expf(_X); } 
inline float __cdecl fabs(float _X) 
{ return fabsf(_X); } 
inline float __cdecl floor(float _X) 
{ return floorf(_X); } 
inline float __cdecl fmod(float _X, float _Y) 
{ return fmodf(_X, _Y); } 
inline float __cdecl frexp(float _X, int *_Y) 
{ return frexpf(_X, _Y); } 
inline float __cdecl ldexp(float _X, int _Y) 
{ return ldexpf(_X, _Y); } 
inline float __cdecl log(float _X) 
{ return logf(_X); } 
inline float __cdecl log10(float _X) 
{ return log10f(_X); } 
inline float __cdecl modf(float _X, float *_Y) 
{ return modff(_X, _Y); } 
inline float __cdecl pow(float _X, float _Y) 
{ return powf(_X, _Y); } 
inline float __cdecl pow(float _X, int _Y) 
{ return _Pow_int(_X, _Y); } 
inline float __cdecl sin(float _X) 
{ return sinf(_X); } 
inline float __cdecl sinh(float _X) 
{ return sinhf(_X); } 
inline float __cdecl sqrt(float _X) 
{ return sqrtf(_X); } 
inline float __cdecl tan(float _X) 
{ return tanf(_X); } 
inline float __cdecl tanh(float _X) 
{ return tanhf(_X); } 
inline long double __cdecl abs(long double _X) 
{ return fabsl(_X); } 
inline long double __cdecl acos(long double _X) 
{ return acosl(_X); } 
inline long double __cdecl asin(long double _X) 
{ return asinl(_X); } 
inline long double __cdecl atan(long double _X) 
{ return atanl(_X); } 
inline long double __cdecl atan2(long double _Y, long double _X) 
{ return atan2l(_Y, _X); } 
inline long double __cdecl ceil(long double _X) 
{ return ceill(_X); } 
inline long double __cdecl cos(long double _X) 
{ return cosl(_X); } 
inline long double __cdecl cosh(long double _X) 
{ return coshl(_X); } 
inline long double __cdecl exp(long double _X) 
{ return expl(_X); } 
inline long double __cdecl fabs(long double _X) 
{ return fabsl(_X); } 
inline long double __cdecl floor(long double _X) 
{ return floorl(_X); } 
inline long double __cdecl fmod(long double _X, long double _Y) 
{ return fmodl(_X, _Y); } 
inline long double __cdecl frexp(long double _X, int *_Y) 
{ return frexpl(_X, _Y); } 
inline long double __cdecl ldexp(long double _X, int _Y) 
{ return ldexpl(_X, _Y); } 
inline long double __cdecl log(long double _X) 
{ return logl(_X); } 
inline long double __cdecl log10(long double _X) 
{ return log10l(_X); } 
inline long double __cdecl modf(long double _X, long double *_Y) 
{ return modfl(_X, _Y); } 
inline long double __cdecl pow(long double _X, long double _Y) 
{ return powl(_X, _Y); } 
inline long double __cdecl pow(long double _X, int _Y) 
{ return _Pow_int(_X, _Y); } 
inline long double __cdecl sin(long double _X) 
{ return sinl(_X); } 
inline long double __cdecl sinh(long double _X) 
{ return sinhl(_X); } 
inline long double __cdecl sqrt(long double _X) 
{ return sqrtl(_X); } 
inline long double __cdecl tan(long double _X) 
{ return tanl(_X); } 
inline long double __cdecl tanh(long double _X) 
{ return tanhl(_X); } 
#line 592 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\math.h"
#pragma pack ( pop )
#line 31 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
#pragma pack ( push, 8 )
#line 56 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { typedef int (__cdecl *_onexit_t)(void); }
#line 82 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { typedef 
#line 79 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
struct _div_t { 
int quot; 
int rem; 
} div_t; }




extern "C" { typedef 
#line 84 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
struct _ldiv_t { 
long quot; 
long rem; 
} ldiv_t; }
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
#pragma pack ( 4 )


extern "C" { typedef 
#line 102 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
struct _LDOUBLE { 
unsigned char ld[10]; 
} _LDOUBLE; }
#pragma pack ( )
#line 123 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { typedef 
#line 121 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
struct _CRT_DOUBLE { 
double x; 
} _CRT_DOUBLE; }



extern "C" { typedef 
#line 125 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
struct _CRT_FLOAT { 
float f; 
} _CRT_FLOAT; }
#line 138 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { typedef 
#line 133 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
struct _LONGDOUBLE { 



long double x; 
} _LONGDOUBLE; }



#pragma pack ( 4 )


extern "C" { typedef 
#line 143 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
struct _LDBL12 { 
unsigned char ld12[12]; 
} _LDBL12; }
#pragma pack ( )
#line 166 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" int __mb_cur_max; 
#line 171 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern int __cdecl ___mb_cur_max_func(); } 
extern "C" { extern int __cdecl ___mb_cur_max_l_func(_locale_t); } 
#line 211 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { typedef void (__cdecl *_purecall_handler)(void); }


extern "C" { extern _purecall_handler __cdecl _set_purecall_handler(_purecall_handler); } 
extern "C" { extern _purecall_handler __cdecl _get_purecall_handler(); } 
#line 239 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { typedef void (__cdecl *_invalid_parameter_handler)(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); }


extern "C" { extern _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler); } 
extern "C" { extern _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(); } 
#line 274 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern unsigned long *__cdecl __doserrno(); } 


extern "C" { extern errno_t __cdecl _set_doserrno(unsigned long); } 
extern "C" { extern errno_t __cdecl _get_doserrno(unsigned long *); } 


extern "C" { extern char **__cdecl __sys_errlist(); } 


extern "C" { extern int *__cdecl __sys_nerr(); } 
#line 301 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" int __argc; 
extern "C" char **__argv; 
extern "C" __wchar_t **__wargv; 
#line 317 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" char **_environ; 
extern "C" __wchar_t **_wenviron; 
#line 321 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" char *_pgmptr; 
extern "C" __wchar_t *_wpgmptr; 
#line 339 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern errno_t __cdecl _get_pgmptr(char **); } 
extern "C" { extern errno_t __cdecl _get_wpgmptr(__wchar_t **); } 



extern "C" int _fmode; 
#line 350 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern errno_t __cdecl _set_fmode(int); } 
extern "C" { extern errno_t __cdecl _get_fmode(int *); } 
#line 360 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
template<class _CountofType, size_t _SizeOfArray> extern char (*__countof_helper(_CountofType (&)[_SizeOfArray]))[_SizeOfArray]; 
#line 371 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern __declspec( noreturn ) void __cdecl exit(int); } 
extern "C" { extern __declspec( noreturn ) void __cdecl _exit(int); } 
extern "C" { extern void __cdecl abort(); } 
#line 376 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern unsigned __cdecl _set_abort_behavior(unsigned, unsigned); } 
#line 384 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern __int64 __cdecl _abs64(__int64); } 
#line 412 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern int __cdecl atexit(void (__cdecl *)(void)); } 
#line 419 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern int __cdecl atoi(const char *); } 
extern "C" { extern int __cdecl _atoi_l(const char *, _locale_t); } 
extern "C" { extern long __cdecl atol(const char *); } 
extern "C" { extern long __cdecl _atol_l(const char *, _locale_t); } 



extern "C" { extern void *__cdecl bsearch_s(const void *, const void *, rsize_t, rsize_t, int (__cdecl *)(void *, const void *, const void *), void *); } 
#line 430 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern void *__cdecl bsearch(const void *, const void *, size_t, size_t, int (__cdecl *)(const void *, const void *)); } 




extern "C" { extern void __cdecl qsort_s(void *, rsize_t, rsize_t, int (__cdecl *)(void *, const void *, const void *), void *); } 
#line 439 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *, const void *)); } 
#line 443 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern unsigned short __cdecl _byteswap_ushort(unsigned short); } 
extern "C" { extern unsigned long __cdecl _byteswap_ulong(unsigned long); } 
extern "C" { extern unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64); } 
extern "C" { extern div_t __cdecl div(int, int); } 
extern "C" { extern char *__cdecl getenv(const char *); } 

extern "C" { extern errno_t __cdecl getenv_s(size_t *, char *, rsize_t, const char *); } 
#line 451 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
template < size_t _Size > inline errno_t __cdecl getenv_s ( size_t * _ReturnSize, char ( & _Dest ) [ _Size ], const char * _VarName ) { return getenv_s ( _ReturnSize, _Dest, _Size, _VarName ); }
#line 457 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern errno_t __cdecl _dupenv_s(char **, size_t *, const char *); } 
#line 463 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern errno_t __cdecl _itoa_s(int, char *, size_t, int); } 
template < size_t _Size > inline errno_t __cdecl _itoa_s ( int _Value, char ( & _Dest ) [ _Size ], int _Radix ) { return _itoa_s ( _Value, _Dest, _Size, _Radix ); }
extern "C" { extern char *__cdecl _itoa(int, char *, int); } 
extern "C" { extern errno_t __cdecl _i64toa_s(__int64, char *, size_t, int); } 
extern "C" { extern char *__cdecl _i64toa(__int64, char *, int); } 
extern "C" { extern errno_t __cdecl _ui64toa_s(unsigned __int64, char *, size_t, int); } 
extern "C" { extern char *__cdecl _ui64toa(unsigned __int64, char *, int); } 
extern "C" { extern __int64 __cdecl _atoi64(const char *); } 
extern "C" { extern __int64 __cdecl _atoi64_l(const char *, _locale_t); } 
extern "C" { extern __int64 __cdecl _strtoi64(const char *, char **, int); } 
extern "C" { extern __int64 __cdecl _strtoi64_l(const char *, char **, int, _locale_t); } 
extern "C" { extern unsigned __int64 __cdecl _strtoui64(const char *, char **, int); } 
extern "C" { extern unsigned __int64 __cdecl _strtoui64_l(const char *, char **, int, _locale_t); } 
extern "C" { extern ldiv_t __cdecl ldiv(long, long); } 



inline ldiv_t div(long _A1, long _A2) 
{ 
return ldiv(_A1, _A2); 
} 
#line 486 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern errno_t __cdecl _ltoa_s(long, char *, size_t, int); } 
template < size_t _Size > inline errno_t __cdecl _ltoa_s ( long _Value, char ( & _Dest ) [ _Size ], int _Radix ) { return _ltoa_s ( _Value, _Dest, _Size, _Radix ); }
extern "C" { extern char *__cdecl _ltoa(long, char *, int); } 
extern "C" { extern int __cdecl mblen(const char *, size_t); } 
extern "C" { extern int __cdecl _mblen_l(const char *, size_t, _locale_t); } 
extern "C" { extern size_t __cdecl _mbstrlen(const char *); } 
extern "C" { extern size_t __cdecl _mbstrlen_l(const char *, _locale_t); } 
extern "C" { extern size_t __cdecl _mbstrnlen(const char *, size_t); } 
extern "C" { extern size_t __cdecl _mbstrnlen_l(const char *, size_t, _locale_t); } 
extern "C" { extern int __cdecl mbtowc(__wchar_t *, const char *, size_t); } 
extern "C" { extern int __cdecl _mbtowc_l(__wchar_t *, const char *, size_t, _locale_t); } 
extern "C" { extern errno_t __cdecl mbstowcs_s(size_t *, __wchar_t *, size_t, const char *, size_t); } 
template < size_t _Size > inline errno_t __cdecl mbstowcs_s ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], const char * _Source, size_t _MaxCount ) { return mbstowcs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }
extern "C" { extern size_t __cdecl mbstowcs(__wchar_t *, const char *, size_t); } 

extern "C" { extern errno_t __cdecl _mbstowcs_s_l(size_t *, __wchar_t *, size_t, const char *, size_t, _locale_t); } 
template < size_t _Size > inline errno_t __cdecl _mbstowcs_s_l ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], const char * _Source, size_t _MaxCount, _locale_t _Locale ) { return _mbstowcs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }
extern "C" { extern size_t __cdecl _mbstowcs_l(__wchar_t *, const char *, size_t, _locale_t); } 

extern "C" { extern int __cdecl rand(); } 
#line 510 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern int __cdecl _set_error_mode(int); } 

extern "C" { extern void __cdecl srand(unsigned); } 
extern "C" { extern double __cdecl strtod(const char *, char **); } 
extern "C" { extern double __cdecl _strtod_l(const char *, char **, _locale_t); } 
extern "C" { extern long __cdecl strtol(const char *, char **, int); } 
extern "C" { extern long __cdecl _strtol_l(const char *, char **, int, _locale_t); } 
extern "C" { extern unsigned long __cdecl strtoul(const char *, char **, int); } 
extern "C" { extern unsigned long __cdecl _strtoul_l(const char *, char **, int, _locale_t); } 


extern "C" { extern int __cdecl system(const char *); } 
#line 523 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern errno_t __cdecl _ultoa_s(unsigned long, char *, size_t, int); } 
template < size_t _Size > inline errno_t __cdecl _ultoa_s ( unsigned long _Value, char ( & _Dest ) [ _Size ], int _Radix ) { return _ultoa_s ( _Value, _Dest, _Size, _Radix ); }
extern "C" { extern char *__cdecl _ultoa(unsigned long, char *, int); } 
extern "C" { extern int __cdecl wctomb(char *, __wchar_t); } 
extern "C" { extern int __cdecl _wctomb_l(char *, __wchar_t, _locale_t); } 

extern "C" { extern errno_t __cdecl wctomb_s(int *, char *, rsize_t, __wchar_t); } 
#line 531 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern errno_t __cdecl _wctomb_s_l(int *, char *, size_t, __wchar_t, _locale_t); } 
extern "C" { extern errno_t __cdecl wcstombs_s(size_t *, char *, size_t, const __wchar_t *, size_t); } 
template < size_t _Size > inline errno_t __cdecl wcstombs_s ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _MaxCount ) { return wcstombs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }
extern "C" { extern size_t __cdecl wcstombs(char *, const __wchar_t *, size_t); } 
extern "C" { extern errno_t __cdecl _wcstombs_s_l(size_t *, char *, size_t, const __wchar_t *, size_t, _locale_t); } 
template < size_t _Size > inline errno_t __cdecl _wcstombs_s_l ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _MaxCount, _locale_t _Locale ) { return _wcstombs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }
extern "C" { extern size_t __cdecl _wcstombs_l(char *, const __wchar_t *, size_t, _locale_t); } 
#line 599 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern void *__cdecl calloc(size_t, size_t); } 
extern "C" { extern void __cdecl free(void *); } 
extern "C" { extern void *__cdecl malloc(size_t); } 
extern "C" { extern void *__cdecl realloc(void *, size_t); } 
extern "C" { extern void *__cdecl _recalloc(void *, size_t, size_t); } 
extern "C" { extern void __cdecl _aligned_free(void *); } 
extern "C" { extern void *__cdecl _aligned_malloc(size_t, size_t); } 
extern "C" { extern void *__cdecl _aligned_offset_malloc(size_t, size_t, size_t); } 
extern "C" { extern void *__cdecl _aligned_realloc(void *, size_t, size_t); } 
extern "C" { extern void *__cdecl _aligned_recalloc(void *, size_t, size_t, size_t); } 
extern "C" { extern void *__cdecl _aligned_offset_realloc(void *, size_t, size_t, size_t); } 
extern "C" { extern void *__cdecl _aligned_offset_recalloc(void *, size_t, size_t, size_t, size_t); } 
extern "C" { extern size_t __cdecl _aligned_msize(void *, size_t, size_t); } 
#line 638 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern errno_t __cdecl _itow_s(int, __wchar_t *, size_t, int); } 
template < size_t _Size > inline errno_t __cdecl _itow_s ( int _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) { return _itow_s ( _Value, _Dest, _Size, _Radix ); }
extern "C" { extern __wchar_t *__cdecl _itow(int, __wchar_t *, int); } 
extern "C" { extern errno_t __cdecl _ltow_s(long, __wchar_t *, size_t, int); } 
template < size_t _Size > inline errno_t __cdecl _ltow_s ( long _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) { return _ltow_s ( _Value, _Dest, _Size, _Radix ); }
extern "C" { extern __wchar_t *__cdecl _ltow(long, __wchar_t *, int); } 
extern "C" { extern errno_t __cdecl _ultow_s(unsigned long, __wchar_t *, size_t, int); } 
template < size_t _Size > inline errno_t __cdecl _ultow_s ( unsigned long _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) { return _ultow_s ( _Value, _Dest, _Size, _Radix ); }
extern "C" { extern __wchar_t *__cdecl _ultow(unsigned long, __wchar_t *, int); } 
extern "C" { extern double __cdecl wcstod(const __wchar_t *, __wchar_t **); } 
extern "C" { extern double __cdecl _wcstod_l(const __wchar_t *, __wchar_t **, _locale_t); } 
extern "C" { extern long __cdecl wcstol(const __wchar_t *, __wchar_t **, int); } 
extern "C" { extern long __cdecl _wcstol_l(const __wchar_t *, __wchar_t **, int, _locale_t); } 
extern "C" { extern unsigned long __cdecl wcstoul(const __wchar_t *, __wchar_t **, int); } 
extern "C" { extern unsigned long __cdecl _wcstoul_l(const __wchar_t *, __wchar_t **, int, _locale_t); } 
extern "C" { extern __wchar_t *__cdecl _wgetenv(const __wchar_t *); } 
extern "C" { extern errno_t __cdecl _wgetenv_s(size_t *, __wchar_t *, size_t, const __wchar_t *); } 
template < size_t _Size > inline errno_t __cdecl _wgetenv_s ( size_t * _ReturnSize, wchar_t ( & _Dest ) [ _Size ], const wchar_t * _VarName ) { return _wgetenv_s ( _ReturnSize, _Dest, _Size, _VarName ); }
#line 662 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern errno_t __cdecl _wdupenv_s(__wchar_t **, size_t *, const __wchar_t *); } 
#line 670 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern int __cdecl _wsystem(const __wchar_t *); } 
#line 672 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern double __cdecl _wtof(const __wchar_t *); } 
extern "C" { extern double __cdecl _wtof_l(const __wchar_t *, _locale_t); } 
extern "C" { extern int __cdecl _wtoi(const __wchar_t *); } 
extern "C" { extern int __cdecl _wtoi_l(const __wchar_t *, _locale_t); } 
extern "C" { extern long __cdecl _wtol(const __wchar_t *); } 
extern "C" { extern long __cdecl _wtol_l(const __wchar_t *, _locale_t); } 

extern "C" { extern errno_t __cdecl _i64tow_s(__int64, __wchar_t *, size_t, int); } 
extern "C" { extern __wchar_t *__cdecl _i64tow(__int64, __wchar_t *, int); } 
extern "C" { extern errno_t __cdecl _ui64tow_s(unsigned __int64, __wchar_t *, size_t, int); } 
extern "C" { extern __wchar_t *__cdecl _ui64tow(unsigned __int64, __wchar_t *, int); } 
extern "C" { extern __int64 __cdecl _wtoi64(const __wchar_t *); } 
extern "C" { extern __int64 __cdecl _wtoi64_l(const __wchar_t *, _locale_t); } 
extern "C" { extern __int64 __cdecl _wcstoi64(const __wchar_t *, __wchar_t **, int); } 
extern "C" { extern __int64 __cdecl _wcstoi64_l(const __wchar_t *, __wchar_t **, int, _locale_t); } 
extern "C" { extern unsigned __int64 __cdecl _wcstoui64(const __wchar_t *, __wchar_t **, int); } 
extern "C" { extern unsigned __int64 __cdecl _wcstoui64_l(const __wchar_t *, __wchar_t **, int, _locale_t); } 
#line 708 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern char *__cdecl _fullpath(char *, const char *, size_t); } 
#line 716 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern errno_t __cdecl _ecvt_s(char *, size_t, double, int, int *, int *); } 
template < size_t _Size > inline errno_t __cdecl _ecvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits, int * _PtDec, int * _PtSign ) { return _ecvt_s ( _Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign ); }
extern "C" { extern char *__cdecl _ecvt(double, int, int *, int *); } 
extern "C" { extern errno_t __cdecl _fcvt_s(char *, size_t, double, int, int *, int *); } 
template < size_t _Size > inline errno_t __cdecl _fcvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits, int * _PtDec, int * _PtSign ) { return _fcvt_s ( _Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign ); }
extern "C" { extern char *__cdecl _fcvt(double, int, int *, int *); } 
extern "C" { extern errno_t __cdecl _gcvt_s(char *, size_t, double, int); } 
template < size_t _Size > inline errno_t __cdecl _gcvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits ) { return _gcvt_s ( _Dest, _Size, _Value, _NumOfDigits ); }
extern "C" { extern char *__cdecl _gcvt(double, int, char *); } 

extern "C" { extern int __cdecl _atodbl(_CRT_DOUBLE *, char *); } 
extern "C" { extern int __cdecl _atoldbl(_LDOUBLE *, char *); } 
extern "C" { extern int __cdecl _atoflt(_CRT_FLOAT *, char *); } 
extern "C" { extern int __cdecl _atodbl_l(_CRT_DOUBLE *, char *, _locale_t); } 
extern "C" { extern int __cdecl _atoldbl_l(_LDOUBLE *, char *, _locale_t); } 
extern "C" { extern int __cdecl _atoflt_l(_CRT_FLOAT *, char *, _locale_t); } 
extern "C" { extern unsigned long __cdecl _lrotl(unsigned long, int); } 
extern "C" { extern unsigned long __cdecl _lrotr(unsigned long, int); } 
extern "C" { extern errno_t __cdecl _makepath_s(char *, size_t, const char *, const char *, const char *, const char *); } 

template < size_t _Size > inline errno_t __cdecl _makepath_s ( char ( & _Path ) [ _Size ], const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext ) { return _makepath_s ( _Path, _Size, _Drive, _Dir, _Filename, _Ext ); }
extern "C" { extern void __cdecl _makepath(char *, const char *, const char *, const char *, const char *); } 
#line 764 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern _onexit_t __cdecl _onexit(_onexit_t); } 
#line 769 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern void __cdecl perror(const char *); } 
#line 772 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
#pragma warning (push)
#pragma warning (disable:6540)
extern "C" { extern int __cdecl _putenv(const char *); } 
extern "C" { extern errno_t __cdecl _putenv_s(const char *, const char *); } 
extern "C" { extern unsigned __cdecl _rotl(unsigned, int); } 
extern "C" { extern unsigned __int64 __cdecl _rotl64(unsigned __int64, int); } 
extern "C" { extern unsigned __cdecl _rotr(unsigned, int); } 
extern "C" { extern unsigned __int64 __cdecl _rotr64(unsigned __int64, int); } 
#pragma warning (pop)

extern "C" { extern errno_t __cdecl _searchenv_s(const char *, const char *, char *, size_t); } 
template < size_t _Size > inline errno_t __cdecl _searchenv_s ( const char * _Filename, const char * _EnvVar, char ( & _ResultPath ) [ _Size ] ) { return _searchenv_s ( _Filename, _EnvVar, _ResultPath, _Size ); }
extern "C" { extern void __cdecl _searchenv(const char *, const char *, char *); } 

extern "C" { extern void __cdecl _splitpath(const char *, char *, char *, char *, char *); } 
extern "C" { extern errno_t __cdecl _splitpath_s(const char *, char *, size_t, char *, size_t, char *, size_t, char *, size_t); } 




template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _splitpath_s ( const char * _Dest, char ( & _Drive ) [ _DriveSize ], char ( & _Dir ) [ _DirSize ], char ( & _Name ) [ _NameSize ], char ( & _Ext ) [ _ExtSize ] ) { return _splitpath_s ( _Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }

extern "C" { extern void __cdecl _swab(char *, char *, int); } 
#line 805 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern __wchar_t *__cdecl _wfullpath(__wchar_t *, const __wchar_t *, size_t); } 
#line 811 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern errno_t __cdecl _wmakepath_s(__wchar_t *, size_t, const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *); } 

template < size_t _Size > inline errno_t __cdecl _wmakepath_s ( wchar_t ( & _ResultPath ) [ _Size ], const wchar_t * _Drive, const wchar_t * _Dir, const wchar_t * _Filename, const wchar_t * _Ext ) { return _wmakepath_s ( _ResultPath, _Size, _Drive, _Dir, _Filename, _Ext ); }
extern "C" { extern void __cdecl _wmakepath(__wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *); } 


extern "C" { extern void __cdecl _wperror(const __wchar_t *); } 
#line 819 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern int __cdecl _wputenv(const __wchar_t *); } 
extern "C" { extern errno_t __cdecl _wputenv_s(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern errno_t __cdecl _wsearchenv_s(const __wchar_t *, const __wchar_t *, __wchar_t *, size_t); } 
template < size_t _Size > inline errno_t __cdecl _wsearchenv_s ( const wchar_t * _Filename, const wchar_t * _EnvVar, wchar_t ( & _ResultPath ) [ _Size ] ) { return _wsearchenv_s ( _Filename, _EnvVar, _ResultPath, _Size ); }
extern "C" { extern void __cdecl _wsearchenv(const __wchar_t *, const __wchar_t *, __wchar_t *); } 
extern "C" { extern void __cdecl _wsplitpath(const __wchar_t *, __wchar_t *, __wchar_t *, __wchar_t *, __wchar_t *); } 
extern "C" { extern errno_t __cdecl _wsplitpath_s(const __wchar_t *, __wchar_t *, size_t, __wchar_t *, size_t, __wchar_t *, size_t, __wchar_t *, size_t); } 




template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _wsplitpath_s ( const wchar_t * _Path, wchar_t ( & _Drive ) [ _DriveSize ], wchar_t ( & _Dir ) [ _DirSize ], wchar_t ( & _Name ) [ _NameSize ], wchar_t ( & _Ext ) [ _ExtSize ] ) { return _wsplitpath_s ( _Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }
#line 836 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
extern "C" { extern __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode instead. See online help for details.")) void __cdecl _seterrormode(int); } 
extern "C" { extern __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. See online help for details.")) void __cdecl _beep(unsigned, unsigned); } 
extern "C" { extern __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. See online help for details.")) void __cdecl _sleep(unsigned long); } 
#line 857 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 4141)
extern "C" { extern char *__cdecl ecvt(double, int, int *, int *); } 
extern "C" { extern char *__cdecl fcvt(double, int, int *, int *); } 
extern "C" { extern char *__cdecl gcvt(double, int, char *); } 
extern "C" { extern char *__cdecl itoa(int, char *, int); } 
extern "C" { extern char *__cdecl ltoa(long, char *, int); } 
extern "C" { extern int __cdecl putenv(const char *); } 
extern "C" { extern void __cdecl swab(char *, char *, int); } 
extern "C" { extern char *__cdecl ultoa(unsigned long, char *, int); } 
#pragma warning(pop)
extern "C" { extern _onexit_t __cdecl onexit(_onexit_t); } 
#line 114 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\use_ansi.h"
#pragma comment(lib,"libcpmt")
#line 880 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdlib.h"
#pragma pack ( pop )
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
#pragma pack ( push, 8 )
#line 528 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
namespace std { 
typedef bool _Bool; 
}
#line 546 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
typedef __int64 _Longlong; 
typedef unsigned __int64 _ULonglong; 
#line 569 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
namespace std { 



#pragma warning(push)
#pragma warning(disable:4412)
class _Lockit { 
#line 595 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
public: explicit __thiscall _Lockit(); 
explicit __thiscall _Lockit(int); 
__thiscall ~_Lockit(); 
#line 600 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
static void __cdecl _Lockit_ctor(int); 
static void __cdecl _Lockit_dtor(int); 


private: static void __cdecl _Lockit_ctor(_Lockit *); 
static void __cdecl _Lockit_ctor(_Lockit *, int); 
static void __cdecl _Lockit_dtor(_Lockit *); 

_Lockit(const _Lockit &); 
_Lockit &operator=(const _Lockit &); 

int _Locktype; 
#line 628 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
}; 
#line 722 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
class _Mutex { 
#line 746 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
public: __thiscall _Mutex(); 
__thiscall ~_Mutex(); 
void __thiscall _Lock(); 
void __thiscall _Unlock(); 
#line 753 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
private: static void __cdecl _Mutex_ctor(_Mutex *); 
static void __cdecl _Mutex_dtor(_Mutex *); 
static void __cdecl _Mutex_Lock(_Mutex *); 
static void __cdecl _Mutex_Unlock(_Mutex *); 

_Mutex(const _Mutex &); 
_Mutex &operator=(const _Mutex &); 
void *_Mtx; 
#line 772 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
}; 

class _Init_locks { 
#line 790 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
public: __thiscall _Init_locks(); 
__thiscall ~_Init_locks(); 
#line 795 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
private: static void __cdecl _Init_locks_ctor(_Init_locks *); 
static void __cdecl _Init_locks_dtor(_Init_locks *); 
#line 808 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
}; 
#pragma warning(pop)
}
#line 819 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
extern void __cdecl _Atexit(void (__cdecl *)(void)); 

typedef int _Mbstatet; 
#line 830 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\yvals.h"
#pragma pack ( pop )
#line 20 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\cmath"
namespace std { 
using ::acosf;using ::asinf;
using ::atanf;using ::atan2f;using ::ceilf;
using ::cosf;using ::coshf;using ::expf;
using ::fabsf;using ::floorf;using ::fmodf;
using ::frexpf;using ::ldexpf;using ::logf;
using ::log10f;using ::modff;using ::powf;
using ::sinf;using ::sinhf;using ::sqrtf;
using ::tanf;using ::tanhf;

using ::acosl;using ::asinl;
using ::atanl;using ::atan2l;using ::ceill;
using ::cosl;using ::coshl;using ::expl;
using ::fabsl;using ::floorl;using ::fmodl;
using ::frexpl;using ::ldexpl;using ::logl;
using ::log10l;using ::modfl;using ::powl;
using ::sinl;using ::sinhl;using ::sqrtl;
using ::tanl;using ::tanhl;

using ::abs;

using ::acos;using ::asin;
using ::atan;using ::atan2;using ::ceil;
using ::cos;using ::cosh;using ::exp;
using ::fabs;using ::floor;using ::fmod;
using ::frexp;using ::ldexp;using ::log;
using ::log10;using ::modf;using ::pow;
using ::sin;using ::sinh;using ::sqrt;
using ::tan;using ::tanh;


}
#line 19 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\cstdlib"
namespace std { 

using ::size_t;using ::div_t;using ::ldiv_t;

using ::abort;using ::atexit;
using ::atof;using ::atoi;using ::atol;
using ::bsearch;using ::calloc;using ::div;
using ::exit;using ::free;using ::getenv;
using ::labs;using ::ldiv;using ::malloc;
using ::mblen;using ::mbstowcs;using ::mbtowc;
using ::qsort;using ::rand;using ::realloc;
using ::srand;using ::strtod;using ::strtol;
using ::strtoul;using ::system;
using ::wcstombs;using ::wctomb;


}
#line 518 "c:\\cuda\\include\\math_functions.h"
static __inline __int64 abs(__int64 a) 
{ 
return llabs(a); 
} 

static __inline int signbit(double a) 
{ 
return __signbit(a); 
} 

static __inline int signbit(float a) 
{ 
return __signbitf(a); 
} 

static __inline int isinf(double a) 
{ 
return __isinf(a); 
} 

static __inline int isinf(float a) 
{ 
return __isinff(a); 
} 

static __inline int isnan(double a) 
{ 
return __isnan(a); 
} 

static __inline int isnan(float a) 
{ 
return __isnanf(a); 
} 

static __inline int isfinite(double a) 
{ 
return __finite(a); 
} 

static __inline int isfinite(float a) 
{ 
return __finitef(a); 
} 

template<class T> inline T _Pow_int(T, int); 
#line 571 "c:\\cuda\\include\\math_functions.h"
inline long abs(long); 
inline float abs(float); 
inline double abs(double); 
inline float fabs(float); 
inline float ceil(float); 
inline float floor(float); 
inline float sqrt(float); 
inline float pow(float, float); 
inline float pow(float, int); 
inline double pow(double, int); 
inline float log(float); 
inline float log10(float); 
inline float fmod(float, float); 
inline float modf(float, float *); 
inline float exp(float); 
inline float frexp(float, int *); 
inline float ldexp(float, int); 
inline float asin(float); 
inline float sin(float); 
inline float sinh(float); 
inline float acos(float); 
inline float cos(float); 
inline float cosh(float); 
inline float atan(float); 
inline float atan2(float, float); 
inline float tan(float); 
inline float tanh(float); 
#line 603 "c:\\cuda\\include\\math_functions.h"
static __inline float logb(float a) 
{ 
return logbf(a); 
} 

static __inline int ilogb(float a) 
{ 
return ilogbf(a); 
} 

static __inline float scalbn(float a, int b) 
{ 
return scalbnf(a, b); 
} 

static __inline float scalbln(float a, long b) 
{ 
return scalblnf(a, b); 
} 

static __inline float exp2(float a) 
{ 
return exp2f(a); 
} 

static __inline float exp10(float a) 
{ 
return exp10f(a); 
} 

static __inline float expm1(float a) 
{ 
return expm1f(a); 
} 

static __inline float log2(float a) 
{ 
return log2f(a); 
} 

static __inline float log1p(float a) 
{ 
return log1pf(a); 
} 

static __inline float rsqrt(float a) 
{ 
return rsqrtf(a); 
} 

static __inline float acosh(float a) 
{ 
return acoshf(a); 
} 

static __inline float asinh(float a) 
{ 
return asinhf(a); 
} 

static __inline float atanh(float a) 
{ 
return atanhf(a); 
} 

static __inline float hypot(float a, float b) 
{ 
return hypotf(a, b); 
} 

static __inline float cbrt(float a) 
{ 
return cbrtf(a); 
} 

static __inline void sincos(float a, float *sptr, float *cptr) 
{ 
sincosf(a, sptr, cptr); 
} 

static __inline float erf(float a) 
{ 
return erff(a); 
} 

static __inline float erfinv(float a) 
{ 
return erfinvf(a); 
} 

static __inline float erfc(float a) 
{ 
return erfcf(a); 
} 

static __inline float erfcinv(float a) 
{ 
return erfcinvf(a); 
} 

static __inline float lgamma(float a) 
{ 
return lgammaf(a); 
} 

static __inline float tgamma(float a) 
{ 
return tgammaf(a); 
} 

static __inline float copysign(float a, float b) 
{ 
return copysignf(a, b); 
} 

static __inline double copysign(double a, float b) 
{ 
return copysign(a, (double)b); 
} 

static __inline float copysign(float a, double b) 
{ 
return copysignf(a, (float)b); 
} 

static __inline float nextafter(float a, float b) 
{ 
return nextafterf(a, b); 
} 

static __inline float remainder(float a, float b) 
{ 
return remainderf(a, b); 
} 

static __inline float remquo(float a, float b, int *quo) 
{ 
return remquof(a, b, quo); 
} 

static __inline float round(float a) 
{ 
return roundf(a); 
} 

static __inline long lround(float a) 
{ 
return lroundf(a); 
} 

static __inline __int64 llround(float a) 
{ 
return llroundf(a); 
} 

static __inline float trunc(float a) 
{ 
return truncf(a); 
} 

static __inline float rint(float a) 
{ 
return rintf(a); 
} 

static __inline long lrint(float a) 
{ 
return lrintf(a); 
} 

static __inline __int64 llrint(float a) 
{ 
return llrintf(a); 
} 

static __inline float nearbyint(float a) 
{ 
return nearbyintf(a); 
} 

static __inline float fdim(float a, float b) 
{ 
return fdimf(a, b); 
} 

static __inline float fma(float a, float b, float c) 
{ 
return fmaf(a, b, c); 
} 

static __inline unsigned min(unsigned a, unsigned b) 
{ 
return umin(a, b); 
} 

static __inline unsigned min(int a, unsigned b) 
{ 
return umin((unsigned)a, b); 
} 

static __inline unsigned min(unsigned a, int b) 
{ 
return umin(a, (unsigned)b); 
} 

static __inline __int64 min(__int64 a, __int64 b) 
{ 
return llmin(a, b); 
} 

static __inline unsigned __int64 min(unsigned __int64 a, unsigned __int64 b) 
{ 
return ullmin(a, b); 
} 

static __inline unsigned __int64 min(__int64 a, unsigned __int64 b) 
{ 
return ullmin((unsigned __int64)a, b); 
} 

static __inline unsigned __int64 min(unsigned __int64 a, __int64 b) 
{ 
return ullmin(a, (unsigned __int64)b); 
} 

static __inline float min(float a, float b) 
{ 
return fminf(a, b); 
} 

static __inline double min(double a, double b) 
{ 
return fmin(a, b); 
} 

static __inline double min(float a, double b) 
{ 
return fmin((double)a, b); 
} 

static __inline double min(double a, float b) 
{ 
return fmin(a, (double)b); 
} 

static __inline unsigned max(unsigned a, unsigned b) 
{ 
return umax(a, b); 
} 

static __inline unsigned max(int a, unsigned b) 
{ 
return umax((unsigned)a, b); 
} 

static __inline unsigned max(unsigned a, int b) 
{ 
return umax(a, (unsigned)b); 
} 

static __inline __int64 max(__int64 a, __int64 b) 
{ 
return llmax(a, b); 
} 

static __inline unsigned __int64 max(unsigned __int64 a, unsigned __int64 b) 
{ 
return ullmax(a, b); 
} 

static __inline unsigned __int64 max(__int64 a, unsigned __int64 b) 
{ 
return ullmax((unsigned __int64)a, b); 
} 

static __inline unsigned __int64 max(unsigned __int64 a, __int64 b) 
{ 
return ullmax(a, (unsigned __int64)b); 
} 

static __inline float max(float a, float b) 
{ 
return fmaxf(a, b); 
} 

static __inline double max(double a, double b) 
{ 
return fmax(a, b); 
} 

static __inline double max(float a, double b) 
{ 
return fmax((double)a, b); 
} 

static __inline double max(double a, float b) 
{ 
return fmax(a, (double)b); 
} 
#line 59 "c:\\cuda\\include\\cuda_texture_types.h"
template<class T, int dim = 1, cudaTextureReadMode mode = cudaReadModeElementType> 
struct texture : public textureReference { 

texture(int norm = 0, cudaTextureFilterMode 
fMode = cudaFilterModePoint, cudaTextureAddressMode 
aMode = cudaAddressModeClamp) 
{ 
(this->normalized) = norm; 
(this->filterMode) = fMode; 
((this->addressMode)[0]) = aMode; 
((this->addressMode)[1]) = aMode; 
((this->addressMode)[2]) = aMode; 
(this->channelDesc) = cudaCreateChannelDesc< T> (); 
} 

texture(int norm, cudaTextureFilterMode 
fMode, cudaTextureAddressMode 
aMode, cudaChannelFormatDesc 
desc) 
{ 
(this->normalized) = norm; 
(this->filterMode) = fMode; 
((this->addressMode)[0]) = aMode; 
((this->addressMode)[1]) = aMode; 
((this->addressMode)[2]) = aMode; 
(this->channelDesc) = desc; 
} 
}; 

#line 89 "c:\\cuda\\include\\cuda_texture_types.h"

#line 91 "c:\\cuda\\include\\cuda_texture_types.h"

#line 93 "c:\\cuda\\include\\cuda_texture_types.h"

#line 95 "c:\\cuda\\include\\cuda_texture_types.h"

#line 97 "c:\\cuda\\include\\cuda_texture_types.h"

#line 99 "c:\\cuda\\include\\cuda_texture_types.h"
#line 53 "c:\\cuda\\include\\device_launch_parameters.h"




#line 58 "c:\\cuda\\include\\device_launch_parameters.h"
#line 55 "c:\\cuda\\include\\device_launch_parameters.h"




#line 60 "c:\\cuda\\include\\device_launch_parameters.h"
#line 57 "c:\\cuda\\include\\device_launch_parameters.h"




#line 62 "c:\\cuda\\include\\device_launch_parameters.h"
#line 59 "c:\\cuda\\include\\device_launch_parameters.h"




#line 64 "c:\\cuda\\include\\device_launch_parameters.h"
#line 61 "c:\\cuda\\include\\device_launch_parameters.h"




#line 66 "c:\\cuda\\include\\device_launch_parameters.h"
#line 101 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
template<class T> __inline cudaError_t 
cudaSetupArgument(T 
arg, size_t 
offset) 

{ 
return cudaSetupArgument((const void *)(&arg), sizeof(T), offset); 
} 

template<class T> __inline cudaError_t 
cudaHostAlloc(T **
ptr, size_t 
size, unsigned 
flags) 

{ 
return cudaHostAlloc((void **)((void *)ptr), size, flags); 
} 

template<class T> __inline cudaError_t 
cudaHostGetDevicePointer(T **
pDevice, void *
pHost, unsigned 
flags) 

{ 
return cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
} 

template<class T> __inline cudaError_t 
cudaMalloc(T **
devPtr, size_t 
size) 

{ 
return cudaMalloc((void **)((void *)devPtr), size); 
} 

template<class T> __inline cudaError_t 
cudaMallocHost(T **
ptr, size_t 
size) 

{ 
return cudaMallocHost((void **)((void *)ptr), size); 
} 

template<class T> __inline cudaError_t 
cudaMallocPitch(T **
devPtr, size_t *
pitch, size_t 
width, size_t 
height) 

{ 
return cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
} 
#line 172 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
static __inline cudaError_t cudaMemcpyToSymbol(char *
symbol, const void *
src, size_t 
count, size_t 
offset = (0), cudaMemcpyKind 
kind = cudaMemcpyHostToDevice) 

{ 
return cudaMemcpyToSymbol((const char *)symbol, src, count, offset, kind); 
} 

template<class T> __inline cudaError_t 
cudaMemcpyToSymbol(const T &
symbol, const void *
src, size_t 
count, size_t 
offset = (0), cudaMemcpyKind 
kind = cudaMemcpyHostToDevice) 

{ 
return cudaMemcpyToSymbol((const char *)(&symbol), src, count, offset, kind); 
} 

static __inline cudaError_t cudaMemcpyToSymbolAsync(char *
symbol, const void *
src, size_t 
count, size_t 
offset, cudaMemcpyKind 
kind, cudaStream_t 
stream) 

{ 
return cudaMemcpyToSymbolAsync((const char *)symbol, src, count, offset, kind, stream); 
} 

template<class T> __inline cudaError_t 
cudaMemcpyToSymbolAsync(const T &
symbol, const void *
src, size_t 
count, size_t 
offset, cudaMemcpyKind 
kind, cudaStream_t 
stream) 

{ 
return cudaMemcpyToSymbolAsync((const char *)(&symbol), src, count, offset, kind, stream); 
} 
#line 226 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
static __inline cudaError_t cudaMemcpyFromSymbol(void *
dst, char *
symbol, size_t 
count, size_t 
offset = (0), cudaMemcpyKind 
kind = cudaMemcpyDeviceToHost) 

{ 
return cudaMemcpyFromSymbol(dst, (const char *)symbol, count, offset, kind); 
} 

template<class T> __inline cudaError_t 
cudaMemcpyFromSymbol(void *
dst, const T &
symbol, size_t 
count, size_t 
offset = (0), cudaMemcpyKind 
kind = cudaMemcpyDeviceToHost) 

{ 
return cudaMemcpyFromSymbol(dst, (const char *)(&symbol), count, offset, kind); 
} 

static __inline cudaError_t cudaMemcpyFromSymbolAsync(void *
dst, char *
symbol, size_t 
count, size_t 
offset, cudaMemcpyKind 
kind, cudaStream_t 
stream) 

{ 
return cudaMemcpyFromSymbolAsync(dst, (const char *)symbol, count, offset, kind, stream); 
} 

template<class T> __inline cudaError_t 
cudaMemcpyFromSymbolAsync(void *
dst, const T &
symbol, size_t 
count, size_t 
offset, cudaMemcpyKind 
kind, cudaStream_t 
stream) 

{ 
return cudaMemcpyFromSymbolAsync(dst, (const char *)(&symbol), count, offset, kind, stream); 
} 

static __inline cudaError_t cudaGetSymbolAddress(void **
devPtr, char *
symbol) 

{ 
return cudaGetSymbolAddress(devPtr, (const char *)symbol); 
} 
#line 304 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
template<class T> __inline cudaError_t 
cudaGetSymbolAddress(void **
devPtr, const T &
symbol) 

{ 
return cudaGetSymbolAddress(devPtr, (const char *)(&symbol)); 
} 
#line 319 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
static __inline cudaError_t cudaGetSymbolSize(size_t *
size, char *
symbol) 

{ 
return cudaGetSymbolSize(size, (const char *)symbol); 
} 
#line 348 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
template<class T> __inline cudaError_t 
cudaGetSymbolSize(size_t *
size, const T &
symbol) 

{ 
return cudaGetSymbolSize(size, (const char *)(&symbol)); 
} 
#line 404 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
template<class T, int dim, cudaTextureReadMode readMode> __inline cudaError_t 
cudaBindTexture(size_t *
offset, const texture< T, dim, readMode>  &
tex, const void *
devPtr, const cudaChannelFormatDesc &
desc, size_t 
size = (4294967295U)) 

{ 
return cudaBindTexture(offset, &tex, devPtr, (&desc), size); 
} 
#line 448 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
template<class T, int dim, cudaTextureReadMode readMode> __inline cudaError_t 
cudaBindTexture(size_t *
offset, const texture< T, dim, readMode>  &
tex, const void *
devPtr, size_t 
size = (4294967295U)) 

{ 
return cudaBindTexture(offset, tex, devPtr, (tex.channelDesc), size); 
} 
#line 503 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
template<class T, int dim, cudaTextureReadMode readMode> __inline cudaError_t 
cudaBindTexture2D(size_t *
offset, const texture< T, dim, readMode>  &
tex, const void *
devPtr, const cudaChannelFormatDesc &
desc, size_t 
width, size_t 
height, size_t 
pitch) 

{ 
return cudaBindTexture2D(offset, &tex, devPtr, (&desc), width, height, pitch); 
} 
#line 545 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
template<class T, int dim, cudaTextureReadMode readMode> __inline cudaError_t 
cudaBindTextureToArray(const texture< T, dim, readMode>  &
tex, const cudaArray *
array, const cudaChannelFormatDesc &
desc) 

{ 
return cudaBindTextureToArray(&tex, array, (&desc)); 
} 
#line 582 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
template<class T, int dim, cudaTextureReadMode readMode> __inline cudaError_t 
cudaBindTextureToArray(const texture< T, dim, readMode>  &
tex, const cudaArray *
array) 

{ 
auto cudaChannelFormatDesc desc; 
auto cudaError_t err = cudaGetChannelDesc(&desc, array); 

return (err == (cudaSuccess)) ? (cudaBindTextureToArray(tex, array, desc)) : err; 
} 
#line 620 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
template<class T, int dim, cudaTextureReadMode readMode> __inline cudaError_t 
cudaUnbindTexture(const texture< T, dim, readMode>  &
tex) 

{ 
return cudaUnbindTexture(&tex); 
} 
#line 659 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
template<class T, int dim, cudaTextureReadMode readMode> __inline cudaError_t 
cudaGetTextureAlignmentOffset(size_t *
offset, const texture< T, dim, readMode>  &
tex) 

{ 
return cudaGetTextureAlignmentOffset(offset, &tex); 
} 
#line 708 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
template<class T> __inline cudaError_t 
cudaLaunch(T *
entry) 

{ 
return cudaLaunch((const char *)entry); 
} 
#line 744 "C:\\CUDA\\bin64/../include\\cuda_runtime.h"
template<class T> __inline cudaError_t 
cudaFuncGetAttributes(cudaFuncAttributes *
attr, T *
entry) 

{ 
return cudaFuncGetAttributes(attr, (const char *)entry); 
} 
#line 37 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
#pragma warning( disable : 4996 )
#line 64 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
enum CUTBoolean { 

CUTFalse, 
CUTTrue
}; 
#line 76 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) void __stdcall cutFree(void *); } 
#line 94 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) void __stdcall cutCheckBankAccess(unsigned, unsigned, unsigned, unsigned, unsigned, unsigned, const char *, const int, const char *, const int); } 
#line 107 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) char *__stdcall cutFindFilePath(const char *, const char *); } 
#line 122 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutReadFilef(const char *, float **, unsigned *, bool = false); } 
#line 138 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutReadFiled(const char *, double **, unsigned *, bool = false); } 
#line 154 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutReadFilei(const char *, int **, unsigned *, bool = false); } 
#line 169 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutReadFileui(const char *, unsigned **, unsigned *, bool = false); } 
#line 185 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutReadFileb(const char *, char **, unsigned *, bool = false); } 
#line 201 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutReadFileub(const char *, unsigned char **, unsigned *, bool = false); } 
#line 215 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutWriteFilef(const char *, const float *, unsigned, const float, bool = false); } 
#line 229 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutWriteFiled(const char *, const float *, unsigned, const double, bool = false); } 
#line 241 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutWriteFilei(const char *, const int *, unsigned, bool = false); } 
#line 253 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutWriteFileui(const char *, const unsigned *, unsigned, bool = false); } 
#line 265 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutWriteFileb(const char *, const char *, unsigned, bool = false); } 
#line 277 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutWriteFileub(const char *, const unsigned char *, unsigned, bool = false); } 
#line 293 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutLoadPGMub(const char *, unsigned char **, unsigned *, unsigned *); } 
#line 306 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutLoadPPMub(const char *, unsigned char **, unsigned *, unsigned *); } 
#line 320 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutLoadPPM4ub(const char *, unsigned char **, unsigned *, unsigned *); } 
#line 336 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutLoadPGMi(const char *, unsigned **, unsigned *, unsigned *); } 
#line 352 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutLoadPGMs(const char *, unsigned short **, unsigned *, unsigned *); } 
#line 367 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutLoadPGMf(const char *, float **, unsigned *, unsigned *); } 
#line 379 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutSavePGMub(const char *, unsigned char *, unsigned, unsigned); } 
#line 391 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutSavePPMub(const char *, unsigned char *, unsigned, unsigned); } 
#line 404 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutSavePPM4ub(const char *, unsigned char *, unsigned, unsigned); } 
#line 416 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutSavePGMi(const char *, unsigned *, unsigned, unsigned); } 
#line 428 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutSavePGMs(const char *, unsigned short *, unsigned, unsigned); } 
#line 440 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutSavePGMf(const char *, float *, unsigned, unsigned); } 
#line 461 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutCheckCmdLineFlag(const int, const char **, const char *); } 
#line 475 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutGetCmdLineArgumenti(const int, const char **, const char *, int *); } 
#line 489 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutGetCmdLineArgumentf(const int, const char **, const char *, float *); } 
#line 503 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutGetCmdLineArgumentstr(const int, const char **, const char *, char **); } 
#line 518 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutGetCmdLineArgumentListstr(const int, const char **, const char *, char **, unsigned *); } 
#line 532 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutCheckCondition(int, const char *, const int); } 
#line 544 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutComparef(const float *, const float *, const unsigned); } 
#line 557 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutComparei(const int *, const int *, const unsigned); } 
#line 570 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutCompareub(const unsigned char *, const unsigned char *, const unsigned); } 
#line 584 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutCompareube(const unsigned char *, const unsigned char *, const unsigned, const float); } 
#line 598 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutComparefe(const float *, const float *, const unsigned, const float); } 
#line 613 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutCompareL2fe(const float *, const float *, const unsigned, const float); } 
#line 627 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutComparePPM(const char *, const char *, const float, bool = false); } 
#line 640 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutCreateTimer(unsigned *); } 
#line 649 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutDeleteTimer(unsigned); } 
#line 657 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutStartTimer(const unsigned); } 
#line 665 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutStopTimer(const unsigned); } 
#line 673 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) CUTBoolean __stdcall cutResetTimer(const unsigned); } 
#line 682 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) float __stdcall cutGetTimerValue(const unsigned); } 
#line 693 "C:/ProgramData/NVIDIA Corporation/NVIDIA CUDA SDK/common/inc\\cutil.h"
extern "C" { extern __declspec( dllimport ) float __stdcall cutGetAverageTimerValue(const unsigned); } 
#line 26 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDADefines.h"
typedef unsigned uint; 
typedef unsigned char uchar; 
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\climits"
#pragma warning(disable: 4514)
#line 28 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
#pragma pack ( push, 8 )
#line 59 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { struct _iobuf { 
char *_ptr; 
int _cnt; 
char *_base; 
int _flag; 
int _file; 
int _charbuf; 
int _bufsiz; 
char *_tmpfname; 
}; }
extern "C" { typedef _iobuf FILE; }
#line 132 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern FILE *__cdecl __iob_func(); } 
#line 148 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { typedef __int64 fpos_t; }
#line 189 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl _filbuf(FILE *); } 
extern "C" { extern int __cdecl _flsbuf(int, FILE *); } 




extern "C" { extern FILE *__cdecl _fsopen(const char *, const char *, int); } 
#line 198 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern void __cdecl clearerr(FILE *); } 

extern "C" { extern errno_t __cdecl clearerr_s(FILE *); } 
#line 202 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl fclose(FILE *); } 
extern "C" { extern int __cdecl _fcloseall(); } 




extern "C" { extern FILE *__cdecl _fdopen(int, const char *); } 
#line 211 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl feof(FILE *); } 
extern "C" { extern int __cdecl ferror(FILE *); } 
extern "C" { extern int __cdecl fflush(FILE *); } 
extern "C" { extern int __cdecl fgetc(FILE *); } 
extern "C" { extern int __cdecl _fgetchar(); } 
extern "C" { extern int __cdecl fgetpos(FILE *, fpos_t *); } 
extern "C" { extern char *__cdecl fgets(char *, int, FILE *); } 




extern "C" { extern int __cdecl _fileno(FILE *); } 
#line 230 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern char *__cdecl _tempnam(const char *, const char *); } 
#line 236 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl _flushall(); } 
extern "C" { extern FILE *__cdecl fopen(const char *, const char *); } 

extern "C" { extern errno_t __cdecl fopen_s(FILE **, const char *, const char *); } 
#line 241 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl fprintf(FILE *, const char *, ...); } 

extern "C" { extern int __cdecl fprintf_s(FILE *, const char *, ...); } 
#line 245 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl fputc(int, FILE *); } 
extern "C" { extern int __cdecl _fputchar(int); } 
extern "C" { extern int __cdecl fputs(const char *, FILE *); } 
extern "C" { extern size_t __cdecl fread(void *, size_t, size_t, FILE *); } 

extern "C" { extern size_t __cdecl fread_s(void *, size_t, size_t, size_t, FILE *); } 
#line 252 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern FILE *__cdecl freopen(const char *, const char *, FILE *); } 

extern "C" { extern errno_t __cdecl freopen_s(FILE **, const char *, const char *, FILE *); } 
#line 256 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl fscanf(FILE *, const char *, ...); } 
extern "C" { extern int __cdecl _fscanf_l(FILE *, const char *, _locale_t, ...); } 
#pragma warning(push)
#pragma warning(disable:6530)

extern "C" { extern int __cdecl fscanf_s(FILE *, const char *, ...); } 
#line 263 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl _fscanf_s_l(FILE *, const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl fsetpos(FILE *, const fpos_t *); } 
extern "C" { extern int __cdecl fseek(FILE *, long, int); } 
extern "C" { extern long __cdecl ftell(FILE *); } 

extern "C" { extern int __cdecl _fseeki64(FILE *, __int64, int); } 
extern "C" { extern __int64 __cdecl _ftelli64(FILE *); } 

extern "C" { extern size_t __cdecl fwrite(const void *, size_t, size_t, FILE *); } 
extern "C" { extern int __cdecl getc(FILE *); } 
extern "C" { extern int __cdecl getchar(); } 
extern "C" { extern int __cdecl _getmaxstdio(); } 

extern "C" { extern char *__cdecl gets_s(char *, rsize_t); } 
#line 278 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
template < size_t _Size > inline char * __cdecl gets_s ( char ( & _Buffer ) [ _Size ] ) { return gets_s ( _Buffer, _Size ); }
extern "C" { extern char *__cdecl gets(char *); } 
extern "C" { extern int __cdecl _getw(FILE *); } 




extern "C" { extern int __cdecl _pclose(FILE *); } 
extern "C" { extern FILE *__cdecl _popen(const char *, const char *); } 
extern "C" { extern int __cdecl printf(const char *, ...); } 

extern "C" { extern int __cdecl printf_s(const char *, ...); } 
#line 291 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl putc(int, FILE *); } 
extern "C" { extern int __cdecl putchar(int); } 
extern "C" { extern int __cdecl puts(const char *); } 
extern "C" { extern int __cdecl _putw(int, FILE *); } 


extern "C" { extern int __cdecl remove(const char *); } 
extern "C" { extern int __cdecl rename(const char *, const char *); } 
extern "C" { extern int __cdecl _unlink(const char *); } 

extern "C" { extern int __cdecl unlink(const char *); } 
#line 304 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern void __cdecl rewind(FILE *); } 
extern "C" { extern int __cdecl _rmtmp(); } 
extern "C" { extern int __cdecl scanf(const char *, ...); } 
extern "C" { extern int __cdecl _scanf_l(const char *, _locale_t, ...); } 

extern "C" { extern int __cdecl scanf_s(const char *, ...); } 
#line 311 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl _scanf_s_l(const char *, _locale_t, ...); } 
extern "C" { extern void __cdecl setbuf(FILE *, char *); } 
extern "C" { extern int __cdecl _setmaxstdio(int); } 
extern "C" { extern unsigned __cdecl _set_output_format(unsigned); } 
extern "C" { extern unsigned __cdecl _get_output_format(); } 
extern "C" { extern int __cdecl setvbuf(FILE *, char *, int, size_t); } 
extern "C" { extern int __cdecl _snprintf_s(char *, size_t, size_t, const char *, ...); } 
__pragma(warning(push)) __pragma(warning(disable: 4793)) template < size_t _Size > inline int __cdecl _snprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, ... ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return _vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _ArgList ); }__pragma(warning(pop)) 

extern "C" { extern int __cdecl sprintf_s(char *, size_t, const char *, ...); } 
#line 322 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
__pragma(warning(push)) __pragma(warning(disable: 4793)) template < size_t _Size > inline int __cdecl sprintf_s ( char ( & _Dest ) [ _Size ], const char * _Format, ... ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return vsprintf_s ( _Dest, _Size, _Format, _ArgList ); }__pragma(warning(pop)) 
extern "C" { extern int __cdecl _scprintf(const char *, ...); } 
extern "C" { extern int __cdecl sscanf(const char *, const char *, ...); } 
extern "C" { extern int __cdecl _sscanf_l(const char *, const char *, _locale_t, ...); } 

extern "C" { extern int __cdecl sscanf_s(const char *, const char *, ...); } 
#line 329 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl _sscanf_s_l(const char *, const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _snscanf(const char *, size_t, const char *, ...); } 
extern "C" { extern int __cdecl _snscanf_l(const char *, size_t, const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _snscanf_s(const char *, size_t, const char *, ...); } 
extern "C" { extern int __cdecl _snscanf_s_l(const char *, size_t, const char *, _locale_t, ...); } 
extern "C" { extern FILE *__cdecl tmpfile(); } 

extern "C" { extern errno_t __cdecl tmpfile_s(FILE **); } 
extern "C" { extern errno_t __cdecl tmpnam_s(char *, rsize_t); } 
#line 339 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
template < size_t _Size > inline errno_t __cdecl tmpnam_s ( char ( & _Buf ) [ _Size ] ) { return tmpnam_s ( _Buf, _Size ); }
extern "C" { extern char *__cdecl tmpnam(char *); } 
extern "C" { extern int __cdecl ungetc(int, FILE *); } 
extern "C" { extern int __cdecl vfprintf(FILE *, const char *, va_list); } 

extern "C" { extern int __cdecl vfprintf_s(FILE *, const char *, va_list); } 
#line 346 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl vprintf(const char *, va_list); } 

extern "C" { extern int __cdecl vprintf_s(const char *, va_list); } 
#line 350 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl vsnprintf(char *, size_t, const char *, va_list); } 

extern "C" { extern int __cdecl vsnprintf_s(char *, size_t, size_t, const char *, va_list); } 
#line 354 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl _vsnprintf_s(char *, size_t, size_t, const char *, va_list); } 
template < size_t _Size > inline int __cdecl _vsnprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, va_list _Args ) { return _vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _Args ); }
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { extern int __cdecl _snprintf(char *, size_t, const char *, ...); } extern "C" { extern int __cdecl _vsnprintf(char *, size_t, const char *, va_list); } 
#pragma warning(pop)

extern "C" { extern int __cdecl vsprintf_s(char *, size_t, const char *, va_list); } 
#line 363 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
template < size_t _Size > inline int __cdecl vsprintf_s ( char ( & _Dest ) [ _Size ], const char * _Format, va_list _Args ) { return vsprintf_s ( _Dest, _Size, _Format, _Args ); }
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { extern int __cdecl sprintf(char *, const char *, ...); } extern "C" { extern int __cdecl vsprintf(char *, const char *, va_list); } 
#pragma warning(pop)
extern "C" { extern int __cdecl _vscprintf(const char *, va_list); } 
extern "C" { extern int __cdecl _snprintf_c(char *, size_t, const char *, ...); } 
extern "C" { extern int __cdecl _vsnprintf_c(char *, size_t, const char *, va_list); } 

extern "C" { extern int __cdecl _fprintf_p(FILE *, const char *, ...); } 
extern "C" { extern int __cdecl _printf_p(const char *, ...); } 
extern "C" { extern int __cdecl _sprintf_p(char *, size_t, const char *, ...); } 
extern "C" { extern int __cdecl _vfprintf_p(FILE *, const char *, va_list); } 
extern "C" { extern int __cdecl _vprintf_p(const char *, va_list); } 
extern "C" { extern int __cdecl _vsprintf_p(char *, size_t, const char *, va_list); } 
extern "C" { extern int __cdecl _scprintf_p(const char *, ...); } 
extern "C" { extern int __cdecl _vscprintf_p(const char *, va_list); } 
extern "C" { extern int __cdecl _set_printf_count_output(int); } 
extern "C" { extern int __cdecl _get_printf_count_output(); } 

extern "C" { extern int __cdecl _printf_l(const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _printf_p_l(const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _printf_s_l(const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vprintf_l(const char *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vprintf_p_l(const char *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vprintf_s_l(const char *, _locale_t, va_list); } 

extern "C" { extern int __cdecl _fprintf_l(FILE *, const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _fprintf_p_l(FILE *, const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _fprintf_s_l(FILE *, const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vfprintf_l(FILE *, const char *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vfprintf_p_l(FILE *, const char *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vfprintf_s_l(FILE *, const char *, _locale_t, va_list); } 

extern "C" { extern int __cdecl _sprintf_l(char *, const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _sprintf_p_l(char *, size_t, const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _sprintf_s_l(char *, size_t, const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vsprintf_l(char *, const char *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vsprintf_p_l(char *, size_t, const char *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vsprintf_s_l(char *, size_t, const char *, _locale_t, va_list); } 

extern "C" { extern int __cdecl _scprintf_l(const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _scprintf_p_l(const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vscprintf_l(const char *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vscprintf_p_l(const char *, _locale_t, va_list); } 

extern "C" { extern int __cdecl _snprintf_l(char *, size_t, const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _snprintf_c_l(char *, size_t, const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _snprintf_s_l(char *, size_t, size_t, const char *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vsnprintf_l(char *, size_t, const char *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vsnprintf_c_l(char *, size_t, const char *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vsnprintf_s_l(char *, size_t, size_t, const char *, _locale_t, va_list); } 
#line 427 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern FILE *__cdecl _wfsopen(const __wchar_t *, const __wchar_t *, int); } 
#line 430 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern wint_t __cdecl fgetwc(FILE *); } 
extern "C" { extern wint_t __cdecl _fgetwchar(); } 
extern "C" { extern wint_t __cdecl fputwc(__wchar_t, FILE *); } 
extern "C" { extern wint_t __cdecl _fputwchar(__wchar_t); } 
extern "C" { extern wint_t __cdecl getwc(FILE *); } 
extern "C" { inline wint_t __cdecl getwchar(); } 
extern "C" { extern wint_t __cdecl putwc(__wchar_t, FILE *); } 
extern "C" { inline wint_t __cdecl putwchar(__wchar_t); } 
extern "C" { extern wint_t __cdecl ungetwc(wint_t, FILE *); } 

extern "C" { extern __wchar_t *__cdecl fgetws(__wchar_t *, int, FILE *); } 
extern "C" { extern int __cdecl fputws(const __wchar_t *, FILE *); } 
extern "C" { extern __wchar_t *__cdecl _getws_s(__wchar_t *, size_t); } 
template < size_t _Size > inline wchar_t * __cdecl _getws_s ( wchar_t ( & _String ) [ _Size ] ) { return _getws_s ( _String, _Size ); }
extern "C" { extern __wchar_t *__cdecl _getws(__wchar_t *); } 
extern "C" { extern int __cdecl _putws(const __wchar_t *); } 

extern "C" { extern int __cdecl fwprintf(FILE *, const __wchar_t *, ...); } 

extern "C" { extern int __cdecl fwprintf_s(FILE *, const __wchar_t *, ...); } 
#line 451 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl wprintf(const __wchar_t *, ...); } 

extern "C" { extern int __cdecl wprintf_s(const __wchar_t *, ...); } 
#line 455 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl _scwprintf(const __wchar_t *, ...); } 
extern "C" { extern int __cdecl vfwprintf(FILE *, const __wchar_t *, va_list); } 

extern "C" { extern int __cdecl vfwprintf_s(FILE *, const __wchar_t *, va_list); } 
#line 460 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl vwprintf(const __wchar_t *, va_list); } 

extern "C" { extern int __cdecl vwprintf_s(const __wchar_t *, va_list); } 
#line 466 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl swprintf_s(__wchar_t *, size_t, const __wchar_t *, ...); } 
#line 468 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
__pragma(warning(push)) __pragma(warning(disable: 4793)) template < size_t _Size > inline int __cdecl swprintf_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Format, ... ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return vswprintf_s ( _Dest, _Size, _Format, _ArgList ); }__pragma(warning(pop)) 

extern "C" { extern int __cdecl vswprintf_s(__wchar_t *, size_t, const __wchar_t *, va_list); } 
#line 472 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
template < size_t _Size > inline int __cdecl vswprintf_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Format, va_list _Args ) { return vswprintf_s ( _Dest, _Size, _Format, _Args ); }

extern "C" { extern int __cdecl _swprintf_c(__wchar_t *, size_t, const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _vswprintf_c(__wchar_t *, size_t, const __wchar_t *, va_list); } 

extern "C" { extern int __cdecl _snwprintf_s(__wchar_t *, size_t, size_t, const __wchar_t *, ...); } 
__pragma(warning(push)) __pragma(warning(disable: 4793)) template < size_t _Size > inline int __cdecl _snwprintf_s ( wchar_t ( & _Dest ) [ _Size ], size_t _Count, const wchar_t * _Format, ... ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return _vsnwprintf_s ( _Dest, _Size, _Count, _Format, _ArgList ); }__pragma(warning(pop)) 
extern "C" { extern int __cdecl _vsnwprintf_s(__wchar_t *, size_t, size_t, const __wchar_t *, va_list); } 
template < size_t _Size > inline int __cdecl _vsnwprintf_s ( wchar_t ( & _Dest ) [ _Size ], size_t _Count, const wchar_t * _Format, va_list _Args ) { return _vsnwprintf_s ( _Dest, _Size, _Count, _Format, _Args ); }
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { extern int __cdecl _snwprintf(__wchar_t *, size_t, const __wchar_t *, ...); } extern "C" { extern int __cdecl _vsnwprintf(__wchar_t *, size_t, const __wchar_t *, va_list); } 
#pragma warning(pop)

extern "C" { extern int __cdecl _fwprintf_p(FILE *, const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _wprintf_p(const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _vfwprintf_p(FILE *, const __wchar_t *, va_list); } 
extern "C" { extern int __cdecl _vwprintf_p(const __wchar_t *, va_list); } 
extern "C" { extern int __cdecl _swprintf_p(__wchar_t *, size_t, const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _vswprintf_p(__wchar_t *, size_t, const __wchar_t *, va_list); } 
extern "C" { extern int __cdecl _scwprintf_p(const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _vscwprintf_p(const __wchar_t *, va_list); } 

extern "C" { extern int __cdecl _wprintf_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _wprintf_p_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _wprintf_s_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vwprintf_l(const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vwprintf_p_l(const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vwprintf_s_l(const __wchar_t *, _locale_t, va_list); } 

extern "C" { extern int __cdecl _fwprintf_l(FILE *, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _fwprintf_p_l(FILE *, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _fwprintf_s_l(FILE *, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vfwprintf_l(FILE *, const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vfwprintf_p_l(FILE *, const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vfwprintf_s_l(FILE *, const __wchar_t *, _locale_t, va_list); } 

extern "C" { extern int __cdecl _swprintf_c_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _swprintf_p_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _swprintf_s_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vswprintf_c_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vswprintf_p_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vswprintf_s_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, va_list); } 

extern "C" { extern int __cdecl _scwprintf_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _scwprintf_p_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vscwprintf_p_l(const __wchar_t *, _locale_t, va_list); } 

extern "C" { extern int __cdecl _snwprintf_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _snwprintf_s_l(__wchar_t *, size_t, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vsnwprintf_l(__wchar_t *, size_t, const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vsnwprintf_s_l(__wchar_t *, size_t, size_t, const __wchar_t *, _locale_t, va_list); } 
#line 537 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
#pragma warning(push)
#pragma warning(disable:4141 4996 4793)
extern "C" { extern __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) int __cdecl _swprintf(__wchar_t *, const __wchar_t *, ...); } extern "C" { extern __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) int __cdecl _vswprintf(__wchar_t *, const __wchar_t *, va_list); } 
extern "C" { extern __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) int __cdecl __swprintf_l(__wchar_t *, const __wchar_t *, _locale_t, ...); } extern "C" { extern __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) int __cdecl __vswprintf_l(__wchar_t *, const __wchar_t *, _locale_t, va_list); } 
#pragma warning(pop)
#line 34 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\swprintf.inl"
#pragma warning( push )
#pragma warning( disable : 4793 4412 )
extern "C" { static __inline int swprintf(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, ...) 
{ 
auto va_list _Arglist; 
auto int _Ret; 
_Arglist = (va_list)(&(reinterpret_cast< const char &>(_Format))) + (((sizeof(_Format) + sizeof(int)) - (1)) & (~(sizeof(int) - (1)))); 
_Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist); 
_Arglist = ((va_list)0); 
return _Ret; 
} } 
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
extern "C" { static __inline int __cdecl vswprintf(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, va_list _Ap) 
{ 
return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap); 
} } 
#pragma warning( pop )
#line 58 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\swprintf.inl"
#pragma warning( push )
#pragma warning( disable : 4793 4412 )
extern "C" { static __inline int _swprintf_l(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, _locale_t _Plocinfo, ...) 
{ 
auto va_list _Arglist; 
auto int _Ret; 
_Arglist = (va_list)(&(reinterpret_cast< const char &>(_Plocinfo))) + (((sizeof(_Plocinfo) + sizeof(int)) - (1)) & (~(sizeof(int) - (1)))); 
_Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist); 
_Arglist = ((va_list)0); 
return _Ret; 
} } 
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
extern "C" { static __inline int __cdecl _vswprintf_l(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, _locale_t _Plocinfo, va_list _Ap) 
{ 
return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap); 
} } 
#pragma warning( pop )


#pragma warning( push )
#pragma warning( disable : 4996 )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
__inline __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) int swprintf(__wchar_t *_String, const __wchar_t *_Format, ...) 
{ 
auto va_list _Arglist; 
_Arglist = (va_list)(&(reinterpret_cast< const char &>(_Format))) + (((sizeof(_Format) + sizeof(int)) - (1)) & (~(sizeof(int) - (1)))); 
auto int _Ret = _vswprintf(_String, _Format, _Arglist); 
_Arglist = ((va_list)0); 
return _Ret; 
} 
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
__inline __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) int __cdecl vswprintf(__wchar_t *_String, const __wchar_t *_Format, va_list _Ap) 
{ 
return _vswprintf(_String, _Format, _Ap); 
} 
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
__inline __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) int _swprintf_l(__wchar_t *_String, const __wchar_t *_Format, _locale_t _Plocinfo, ...) 
{ 
auto va_list _Arglist; 
_Arglist = (va_list)(&(reinterpret_cast< const char &>(_Plocinfo))) + (((sizeof(_Plocinfo) + sizeof(int)) - (1)) & (~(sizeof(int) - (1)))); 
auto int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist); 
_Arglist = ((va_list)0); 
return _Ret; 
} 
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
__inline __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) int __cdecl _vswprintf_l(__wchar_t *_String, const __wchar_t *_Format, _locale_t _Plocinfo, va_list _Ap) 
{ 
return __vswprintf_l(_String, _Format, _Plocinfo, _Ap); 
} 
#pragma warning( pop )

#pragma warning( pop )
#line 561 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern __wchar_t *__cdecl _wtempnam(const __wchar_t *, const __wchar_t *); } 
#line 567 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl _vscwprintf(const __wchar_t *, va_list); } 
extern "C" { extern int __cdecl _vscwprintf_l(const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern int __cdecl fwscanf(FILE *, const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _fwscanf_l(FILE *, const __wchar_t *, _locale_t, ...); } 

extern "C" { extern int __cdecl fwscanf_s(FILE *, const __wchar_t *, ...); } 
#line 574 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl _fwscanf_s_l(FILE *, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl swscanf(const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _swscanf_l(const __wchar_t *, const __wchar_t *, _locale_t, ...); } 

extern "C" { extern int __cdecl swscanf_s(const __wchar_t *, const __wchar_t *, ...); } 
#line 580 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl _swscanf_s_l(const __wchar_t *, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _snwscanf(const __wchar_t *, size_t, const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _snwscanf_l(const __wchar_t *, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _snwscanf_s(const __wchar_t *, size_t, const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _snwscanf_s_l(const __wchar_t *, size_t, const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl wscanf(const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _wscanf_l(const __wchar_t *, _locale_t, ...); } 

extern "C" { extern int __cdecl wscanf_s(const __wchar_t *, ...); } 
#line 590 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl _wscanf_s_l(const __wchar_t *, _locale_t, ...); } 
#pragma warning(pop)

extern "C" { extern FILE *__cdecl _wfdopen(int, const __wchar_t *); } 
extern "C" { extern FILE *__cdecl _wfopen(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern errno_t __cdecl _wfopen_s(FILE **, const __wchar_t *, const __wchar_t *); } 
extern "C" { extern FILE *__cdecl _wfreopen(const __wchar_t *, const __wchar_t *, FILE *); } 
extern "C" { extern errno_t __cdecl _wfreopen_s(FILE **, const __wchar_t *, const __wchar_t *, FILE *); } 
#line 603 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern FILE *__cdecl _wpopen(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern int __cdecl _wremove(const __wchar_t *); } 
extern "C" { extern errno_t __cdecl _wtmpnam_s(__wchar_t *, size_t); } 
template < size_t _Size > inline errno_t __cdecl _wtmpnam_s ( wchar_t ( & _Buffer ) [ _Size ] ) { return _wtmpnam_s ( _Buffer, _Size ); }
extern "C" { extern __wchar_t *__cdecl _wtmpnam(__wchar_t *); } 

extern "C" { extern wint_t __cdecl _fgetwc_nolock(FILE *); } 
extern "C" { extern wint_t __cdecl _fputwc_nolock(__wchar_t, FILE *); } 
extern "C" { extern wint_t __cdecl _ungetwc_nolock(wint_t, FILE *); } 
#line 619 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { inline wint_t __cdecl getwchar() 
{ return fgetwc(__iob_func() + 0); } } 
extern "C" { inline wint_t __cdecl putwchar(__wchar_t _C) 
{ return fputwc(_C, __iob_func() + 1); } } 
#line 669 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern void __cdecl _lock_file(FILE *); } 
extern "C" { extern void __cdecl _unlock_file(FILE *); } 
#line 677 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl _fclose_nolock(FILE *); } 
extern "C" { extern int __cdecl _fflush_nolock(FILE *); } 
extern "C" { extern size_t __cdecl _fread_nolock(void *, size_t, size_t, FILE *); } 
extern "C" { extern size_t __cdecl _fread_nolock_s(void *, size_t, size_t, size_t, FILE *); } 
extern "C" { extern int __cdecl _fseek_nolock(FILE *, long, int); } 
extern "C" { extern long __cdecl _ftell_nolock(FILE *); } 
extern "C" { extern int __cdecl _fseeki64_nolock(FILE *, __int64, int); } 
extern "C" { extern __int64 __cdecl _ftelli64_nolock(FILE *); } 
extern "C" { extern size_t __cdecl _fwrite_nolock(const void *, size_t, size_t, FILE *); } 
extern "C" { extern int __cdecl _ungetc_nolock(int, FILE *); } 
#line 713 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern char *__cdecl tempnam(const char *, const char *); } 
#line 719 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
extern "C" { extern int __cdecl fcloseall(); } 
extern "C" { extern FILE *__cdecl fdopen(int, const char *); } 
extern "C" { extern int __cdecl fgetchar(); } 
extern "C" { extern int __cdecl fileno(FILE *); } 
extern "C" { extern int __cdecl flushall(); } 
extern "C" { extern int __cdecl fputchar(int); } 
extern "C" { extern int __cdecl getw(FILE *); } 
extern "C" { extern int __cdecl putw(int, FILE *); } 
extern "C" { extern int __cdecl rmtmp(); } 
#line 736 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdio.h"
#pragma pack ( pop )
#line 34 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\cstdio"
typedef FILE _iobuf; 



namespace std { 
using ::_iobuf;

using ::fpos_t;using ::FILE;
using ::clearerr;using ::fclose;using ::feof;
using ::ferror;using ::fflush;using ::fgetc;
using ::fgetpos;using ::fgets;using ::fopen;
using ::fprintf;using ::fputc;using ::fputs;
using ::fread;using ::freopen;using ::fscanf;
using ::fseek;using ::fsetpos;using ::ftell;
using ::fwrite;using ::getc;using ::getchar;
using ::gets;using ::perror;
using ::putc;using ::putchar;
using ::printf;using ::puts;using ::remove;
using ::rename;using ::rewind;using ::scanf;
using ::setbuf;using ::setvbuf;using ::sprintf;
using ::sscanf;using ::tmpfile;using ::tmpnam;
using ::ungetc;using ::vfprintf;using ::vprintf;
using ::vsprintf;


}
#line 18 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\cstring"
namespace std { 
using ::memchr;using ::memcmp;

using ::memcpy;using ::memmove;using ::memset;
using ::strcat;using ::strchr;using ::strcmp;
using ::strcoll;using ::strcpy;using ::strcspn;
using ::strerror;using ::strlen;using ::strncat;
using ::strncmp;using ::strncpy;using ::strpbrk;
using ::strrchr;using ::strspn;using ::strstr;
using ::strtok;using ::strxfrm;

}
#line 17 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\cstddef"
namespace std { 
using ::ptrdiff_t;
}
#line 14 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstddef"
#pragma warning(push,3)
#line 13 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstddef"
#pragma pack ( push, 8 )
#line 17 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstddef"
namespace std { 
#line 92 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstddef"
enum _Uninitialized { 

_Noinit}; 




struct _Bool_struct { 

int _Member; 
}; 

typedef int _Bool_struct::*_Bool_type; 
#line 106 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstddef"
}

#pragma warning(pop)
#line 11 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
#pragma warning(push,3)
#line 109 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstddef"
#pragma pack ( pop )
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
#pragma pack ( push, 8 )
#line 23 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
namespace std { 
#line 36 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
}
#line 26 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\eh.h"
#pragma pack ( push, 8 )
#line 35 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\eh.h"
typedef void (__cdecl *terminate_function)(void); 
typedef void (__cdecl *terminate_handler)(void); 
typedef void (__cdecl *unexpected_function)(void); 
typedef void (__cdecl *unexpected_handler)(void); 
#line 53 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\eh.h"
struct _EXCEPTION_POINTERS; 

typedef void (__cdecl *_se_translator_function)(unsigned, _EXCEPTION_POINTERS *); 
#line 58 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\eh.h"
extern __declspec( noreturn ) void __cdecl terminate(); 
extern void __cdecl unexpected(); 

extern int __cdecl _is_exception_typeof(const class type_info &, _EXCEPTION_POINTERS *); 



extern terminate_function __cdecl set_terminate(terminate_function); 
extern "C" terminate_function __cdecl _get_terminate(); 
extern unexpected_function __cdecl set_unexpected(unexpected_function); 
extern "C" unexpected_function __cdecl _get_unexpected(); 
#line 73 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\eh.h"
extern _se_translator_function __cdecl _set_se_translator(_se_translator_function); 
#line 75 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\eh.h"
extern bool __cdecl __uncaught_exception(); 
#line 91 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\eh.h"
#pragma pack ( pop )
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\malloc.h"
#pragma pack ( push, 8 )
#line 66 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\malloc.h"
extern "C" { typedef 
#line 62 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\malloc.h"
struct _heapinfo { 
int *_pentry; 
size_t _size; 
int _useflag; 
} _HEAPINFO; }
#line 73 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\malloc.h"
extern "C" unsigned _amblksiz; 
#line 149 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\malloc.h"
extern "C" { extern int __cdecl _resetstkoflw(); } 



extern "C" { extern unsigned long __cdecl _set_malloc_crt_max_wait(unsigned long); } 
#line 164 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\malloc.h"
extern "C" { extern void *__cdecl _expand(void *, size_t); } 
extern "C" { extern size_t __cdecl _msize(void *); } 
#line 172 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\malloc.h"
extern "C" { extern void *__cdecl _alloca(size_t); } 
extern "C" { extern size_t __cdecl _get_sbh_threshold(); } 
extern "C" { extern int __cdecl _set_sbh_threshold(size_t); } 
extern "C" { extern errno_t __cdecl _set_amblksiz(size_t); } 
extern "C" { extern errno_t __cdecl _get_amblksiz(size_t *); } 
extern "C" { extern int __cdecl _heapadd(void *, size_t); } 
extern "C" { extern int __cdecl _heapchk(); } 
extern "C" { extern int __cdecl _heapmin(); } 
extern "C" { extern int __cdecl _heapset(unsigned); } 
extern "C" { extern int __cdecl _heapwalk(_HEAPINFO *); } 
extern "C" { extern size_t __cdecl _heapused(size_t *, size_t *); } 

extern "C" { extern intptr_t __cdecl _get_heap_handle(); } 
#line 198 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\malloc.h"
extern "C" { typedef char __static_assert_t[(sizeof(unsigned) <= (8))]; }


#pragma warning(push)
#pragma warning(disable:6540)
extern "C" { __inline void *_MarkAllocaS(void *_Ptr, unsigned _Marker) 
{ 
if (_Ptr) 
{ 
(*((unsigned *)_Ptr)) = _Marker; 
_Ptr = (char *)_Ptr + 8; 
}  
return _Ptr; 
} } 
#pragma warning(pop)
#line 238 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\malloc.h"
extern "C" { __inline void __cdecl _freea(void *_Memory) 
{ 
auto unsigned _Marker; 
if (_Memory) 
{ 
_Memory = (char *)_Memory - 8; 
_Marker = *((unsigned *)_Memory); 
if (_Marker == (56797)) 
{ 
free(_Memory); 
}  
#line 255 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\malloc.h"
}  
} } 
#line 292 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\malloc.h"
#pragma pack ( pop )
#line 82 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
typedef const char *__exString; 
extern "C" size_t __cdecl strlen(const char *); 

extern "C" errno_t __cdecl strcpy_s(char *, size_t, const char *); 
#line 92 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
namespace std { 

class exception { 
#line 195 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
public: exception(); 
exception(const char *const &); 
exception(const char *const &, int); 
exception(const exception &); 
exception &operator=(const exception &); 
virtual ~exception(); 
virtual const char *what() const; 
#line 204 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
private: const char *_m_what; 
int _m_doFree; 
}; 

using ::set_terminate;using ::terminate_handler;using ::terminate;using ::set_unexpected;using ::unexpected_handler;using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception &); 
#line 216 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
extern bool __cdecl uncaught_exception(); 
#line 219 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
}
#line 333 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
namespace std { 
#line 339 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
class bad_exception : public exception { 


public: bad_exception(const char *_Message = ("bad exception")) throw() : exception(_Message) 


{ 
} 

virtual ~bad_exception() throw() 
{ 
} 
#line 360 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
}; 


static const char *_bad_alloc_Message = ("bad allocation"); 


class bad_alloc : public exception { 


public: bad_alloc(const char *_Message) throw() : exception(_Message) 

{ 
} 

bad_alloc() throw() : exception(_bad_alloc_Message, 1) 

{ 
} 

virtual ~bad_alloc() throw() 
{ 
} 
#line 391 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
}; 


}
#line 413 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
#pragma warning(pop)
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\new"
#pragma warning(push,3)
#line 414 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\exception"
#pragma pack ( pop )
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\new"
#pragma pack ( push, 8 )
#line 25 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\new"
namespace std { 
#line 33 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\new"
typedef void (__cdecl *new_handler)(void); 
#line 38 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\new"
struct nothrow_t { 

}; 

extern const nothrow_t nothrow; 
#line 46 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\new"
extern new_handler __cdecl set_new_handler(new_handler) throw(); 

}


extern void __cdecl operator delete(void *) throw(); 
#pragma warning (suppress: 4985)
extern void *__cdecl operator new(size_t); 



inline void *__cdecl operator new(size_t, void *_Where) throw() 
{ 
return _Where; 
} 

inline void __cdecl operator delete(void *, void *) throw() 
{ 
} 
#line 69 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\new"
inline void *__cdecl operator new[](size_t, void *_Where) throw() 
{ 
return _Where; 
} 

inline void __cdecl operator delete[](void *, void *) throw() 
{ 
} 
#line 79 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\new"
extern void __cdecl operator delete[](void *) throw(); 

extern void *__cdecl operator new[](size_t); 




extern void *__cdecl operator new(size_t, const std::nothrow_t &) throw(); 


extern void *__cdecl operator new[](size_t, const std::nothrow_t &) throw(); 


extern void __cdecl operator delete(void *, const std::nothrow_t &) throw(); 


extern void __cdecl operator delete[](void *, const std::nothrow_t &) throw(); 
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\new"
using std::new_handler;
#line 106 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\new"
#pragma warning(pop)
#pragma pack ( pop )
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
#pragma pack ( push, 8 )
#line 88 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { typedef unsigned long _fsize_t; }
#line 94 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { struct _wfinddata32_t { 
unsigned attrib; 
__time32_t time_create; 
__time32_t time_access; 
__time32_t time_write; 
_fsize_t size; 
__wchar_t name[260]; 
}; }

extern "C" { struct _wfinddata32i64_t { 
unsigned attrib; 
__time32_t time_create; 
__time32_t time_access; 
__time32_t time_write; 
__int64 size; 
__wchar_t name[260]; 
}; }

extern "C" { struct _wfinddata64i32_t { 
unsigned attrib; 
__time64_t time_create; 
__time64_t time_access; 
__time64_t time_write; 
_fsize_t size; 
__wchar_t name[260]; 
}; }

extern "C" { struct _wfinddata64_t { 
unsigned attrib; 
__time64_t time_create; 
__time64_t time_access; 
__time64_t time_write; 
__int64 size; 
__wchar_t name[260]; 
}; }
#line 187 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { extern const unsigned short *__cdecl __pctype_func(); } 

extern "C" const unsigned short *_pctype; 
#line 200 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" const unsigned short _wctype[]; 
#line 203 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { extern const wctype_t *__cdecl __pwctype_func(); } 

extern "C" const wctype_t *_pwctype; 
#line 235 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { extern int __cdecl iswalpha(wint_t); } 
extern "C" { extern int __cdecl _iswalpha_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl iswupper(wint_t); } 
extern "C" { extern int __cdecl _iswupper_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl iswlower(wint_t); } 
extern "C" { extern int __cdecl _iswlower_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl iswdigit(wint_t); } 
extern "C" { extern int __cdecl _iswdigit_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl iswxdigit(wint_t); } 
extern "C" { extern int __cdecl _iswxdigit_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl iswspace(wint_t); } 
extern "C" { extern int __cdecl _iswspace_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl iswpunct(wint_t); } 
extern "C" { extern int __cdecl _iswpunct_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl iswalnum(wint_t); } 
extern "C" { extern int __cdecl _iswalnum_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl iswprint(wint_t); } 
extern "C" { extern int __cdecl _iswprint_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl iswgraph(wint_t); } 
extern "C" { extern int __cdecl _iswgraph_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl iswcntrl(wint_t); } 
extern "C" { extern int __cdecl _iswcntrl_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl iswascii(wint_t); } 
extern "C" { extern int __cdecl isleadbyte(int); } 
extern "C" { extern int __cdecl _isleadbyte_l(int, _locale_t); } 

extern "C" { extern wint_t __cdecl towupper(wint_t); } 
extern "C" { extern wint_t __cdecl _towupper_l(wint_t, _locale_t); } 
extern "C" { extern wint_t __cdecl towlower(wint_t); } 
extern "C" { extern wint_t __cdecl _towlower_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl iswctype(wint_t, wctype_t); } 
extern "C" { extern int __cdecl _iswctype_l(wint_t, wctype_t, _locale_t); } 

extern "C" { extern int __cdecl __iswcsymf(wint_t); } 
extern "C" { extern int __cdecl _iswcsymf_l(wint_t, _locale_t); } 
extern "C" { extern int __cdecl __iswcsym(wint_t); } 
extern "C" { extern int __cdecl _iswcsym_l(wint_t, _locale_t); } 

extern "C" { extern __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using iswctype instead. See online help for details.")) int __cdecl is_wctype(wint_t, wctype_t); } 
#line 291 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { extern __wchar_t *__cdecl _wgetcwd(__wchar_t *, int); } 
extern "C" { extern __wchar_t *__cdecl _wgetdcwd(int, __wchar_t *, int); } 
extern "C" { extern __wchar_t *__cdecl _wgetdcwd_nolock(int, __wchar_t *, int); } 
#line 301 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { extern int __cdecl _wchdir(const __wchar_t *); } 
extern "C" { extern int __cdecl _wmkdir(const __wchar_t *); } 
extern "C" { extern int __cdecl _wrmdir(const __wchar_t *); } 
#line 310 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { extern int __cdecl _waccess(const __wchar_t *, int); } 
extern "C" { extern errno_t __cdecl _waccess_s(const __wchar_t *, int); } 
extern "C" { extern int __cdecl _wchmod(const __wchar_t *, int); } 
extern "C" { extern int __cdecl _wcreat(const __wchar_t *, int); } 
extern "C" { extern intptr_t __cdecl _wfindfirst32(const __wchar_t *, _wfinddata32_t *); } 
extern "C" { extern int __cdecl _wfindnext32(intptr_t, _wfinddata32_t *); } 
extern "C" { extern int __cdecl _wunlink(const __wchar_t *); } 
extern "C" { extern int __cdecl _wrename(const __wchar_t *, const __wchar_t *); } 
extern "C" { extern errno_t __cdecl _wmktemp_s(__wchar_t *, size_t); } 
template < size_t _Size > inline errno_t __cdecl _wmktemp_s ( wchar_t ( & _TemplateName ) [ _Size ] ) { return _wmktemp_s ( _TemplateName, _Size ); }
extern "C" { extern __wchar_t *__cdecl _wmktemp(__wchar_t *); } 

extern "C" { extern intptr_t __cdecl _wfindfirst32i64(const __wchar_t *, _wfinddata32i64_t *); } 
extern "C" { extern intptr_t __cdecl _wfindfirst64i32(const __wchar_t *, _wfinddata64i32_t *); } 
extern "C" { extern intptr_t __cdecl _wfindfirst64(const __wchar_t *, _wfinddata64_t *); } 
extern "C" { extern int __cdecl _wfindnext32i64(intptr_t, _wfinddata32i64_t *); } 
extern "C" { extern int __cdecl _wfindnext64i32(intptr_t, _wfinddata64i32_t *); } 
extern "C" { extern int __cdecl _wfindnext64(intptr_t, _wfinddata64_t *); } 

extern "C" { extern errno_t __cdecl _wsopen_s(int *, const __wchar_t *, int, int, int); } 
#line 339 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern int __cdecl _wopen(const __wchar_t *, int, int = 0); 
extern int __cdecl _wsopen(const __wchar_t *, int, int, int = 0); 
#line 351 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { extern __wchar_t *__cdecl _wsetlocale(int, const __wchar_t *); } 
#line 360 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { extern intptr_t __cdecl _wexecl(const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern intptr_t __cdecl _wexecle(const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern intptr_t __cdecl _wexeclp(const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern intptr_t __cdecl _wexeclpe(const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern intptr_t __cdecl _wexecv(const __wchar_t *, const __wchar_t *const *); } 
extern "C" { extern intptr_t __cdecl _wexecve(const __wchar_t *, const __wchar_t *const *, const __wchar_t *const *); } 

extern "C" { extern intptr_t __cdecl _wexecvp(const __wchar_t *, const __wchar_t *const *); } 
extern "C" { extern intptr_t __cdecl _wexecvpe(const __wchar_t *, const __wchar_t *const *, const __wchar_t *const *); } 

extern "C" { extern intptr_t __cdecl _wspawnl(int, const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern intptr_t __cdecl _wspawnle(int, const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern intptr_t __cdecl _wspawnlp(int, const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern intptr_t __cdecl _wspawnlpe(int, const __wchar_t *, const __wchar_t *, ...); } 
extern "C" { extern intptr_t __cdecl _wspawnv(int, const __wchar_t *, const __wchar_t *const *); } 
extern "C" { extern intptr_t __cdecl _wspawnve(int, const __wchar_t *, const __wchar_t *const *, const __wchar_t *const *); } 

extern "C" { extern intptr_t __cdecl _wspawnvp(int, const __wchar_t *, const __wchar_t *const *); } 
extern "C" { extern intptr_t __cdecl _wspawnvpe(int, const __wchar_t *, const __wchar_t *const *, const __wchar_t *const *); } 
#line 458 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { typedef unsigned short _ino_t; }


extern "C" { typedef unsigned short ino_t; }
#line 467 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { typedef unsigned _dev_t; }


extern "C" { typedef unsigned dev_t; }
#line 476 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { typedef long _off_t; }


extern "C" { typedef long off_t; }
#line 486 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { struct _stat32 { 
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
_off_t st_size; 
__time32_t st_atime; 
__time32_t st_mtime; 
__time32_t st_ctime; 
}; }



extern "C" { struct stat { 
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
_off_t st_size; 
time_t st_atime; 
time_t st_mtime; 
time_t st_ctime; 
}; }
#line 518 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { struct _stat32i64 { 
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
__int64 st_size; 
__time32_t st_atime; 
__time32_t st_mtime; 
__time32_t st_ctime; 
}; }

extern "C" { struct _stat64i32 { 
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
_off_t st_size; 
__time64_t st_atime; 
__time64_t st_mtime; 
__time64_t st_ctime; 
}; }

extern "C" { struct _stat64 { 
_dev_t st_dev; 
_ino_t st_ino; 
unsigned short st_mode; 
short st_nlink; 
short st_uid; 
short st_gid; 
_dev_t st_rdev; 
__int64 st_size; 
__time64_t st_atime; 
__time64_t st_mtime; 
__time64_t st_ctime; 
}; }
#line 592 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { extern int __cdecl _wstat32(const __wchar_t *, _stat32 *); } 

extern "C" { extern int __cdecl _wstat32i64(const __wchar_t *, _stat32i64 *); } 
extern "C" { extern int __cdecl _wstat64i32(const __wchar_t *, _stat64i32 *); } 
extern "C" { extern int __cdecl _wstat64(const __wchar_t *, _stat64 *); } 
#line 612 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { extern errno_t __cdecl _cgetws_s(__wchar_t *, size_t, size_t *); } 
template < size_t _Size > inline errno_t __cdecl _cgetws_s ( wchar_t ( & _Buffer ) [ _Size ], size_t * _Size ) { return _cgetws_s ( _Buffer, _Size, _Size ); }
extern "C" { extern __wchar_t *__cdecl _cgetws(__wchar_t *); } 
extern "C" { extern wint_t __cdecl _getwch(); } 
extern "C" { extern wint_t __cdecl _getwche(); } 
extern "C" { extern wint_t __cdecl _putwch(__wchar_t); } 
extern "C" { extern wint_t __cdecl _ungetwch(wint_t); } 
extern "C" { extern int __cdecl _cputws(const __wchar_t *); } 
extern "C" { extern int __cdecl _cwprintf(const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _cwprintf_s(const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _cwscanf(const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _cwscanf_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _cwscanf_s(const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _cwscanf_s_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vcwprintf(const __wchar_t *, va_list); } 
extern "C" { extern int __cdecl _vcwprintf_s(const __wchar_t *, va_list); } 

extern "C" { extern int __cdecl _cwprintf_p(const __wchar_t *, ...); } 
extern "C" { extern int __cdecl _vcwprintf_p(const __wchar_t *, va_list); } 

extern "C" { extern int __cdecl _cwprintf_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _cwprintf_s_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vcwprintf_l(const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _vcwprintf_s_l(const __wchar_t *, _locale_t, va_list); } 
extern "C" { extern int __cdecl _cwprintf_p_l(const __wchar_t *, _locale_t, ...); } 
extern "C" { extern int __cdecl _vcwprintf_p_l(const __wchar_t *, _locale_t, va_list); } 

extern "C" { extern wint_t __cdecl _putwch_nolock(__wchar_t); } 
extern "C" { extern wint_t __cdecl _getwch_nolock(); } 
extern "C" { extern wint_t __cdecl _getwche_nolock(); } 
extern "C" { extern wint_t __cdecl _ungetwch_nolock(wint_t); } 
#line 1171 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { typedef int mbstate_t; }
extern "C" { typedef __wchar_t _Wint_t; }

extern "C" { extern wint_t __cdecl btowc(int); } 
extern "C" { extern size_t __cdecl mbrlen(const char *, size_t, mbstate_t *); } 

extern "C" { extern size_t __cdecl mbrtowc(__wchar_t *, const char *, size_t, mbstate_t *); } 

extern "C" { extern errno_t __cdecl mbsrtowcs_s(size_t *, __wchar_t *, size_t, const char **, size_t, mbstate_t *); } 
template < size_t _Size > inline errno_t __cdecl mbsrtowcs_s ( size_t * _Retval, wchar_t ( & _Dest ) [ _Size ], const char * * _PSource, size_t _Count, mbstate_t * _State ) { return mbsrtowcs_s ( _Retval, _Dest, _Size, _PSource, _Count, _State ); }
extern "C" { extern size_t __cdecl mbsrtowcs(__wchar_t *, const char **, size_t, mbstate_t *); } 

extern "C" { extern errno_t __cdecl wcrtomb_s(size_t *, char *, size_t, __wchar_t, mbstate_t *); } 

template < size_t _Size > inline errno_t __cdecl wcrtomb_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], wchar_t _Source, mbstate_t * _State ) { return wcrtomb_s ( _Retval, _Dest, _Size, _Source, _State ); }
extern "C" { extern size_t __cdecl wcrtomb(char *, __wchar_t, mbstate_t *); } 
extern "C" { extern errno_t __cdecl wcsrtombs_s(size_t *, char *, size_t, const __wchar_t **, size_t, mbstate_t *); } 

template < size_t _Size > inline errno_t __cdecl wcsrtombs_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], const wchar_t * * _PSrc, size_t _Count, mbstate_t * _State ) { return wcsrtombs_s ( _Retval, _Dest, _Size, _PSrc, _Count, _State ); }
extern "C" { extern size_t __cdecl wcsrtombs(char *, const __wchar_t **, size_t, mbstate_t *); } 
extern "C" { extern int __cdecl wctob(wint_t); } 
#line 1199 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { extern void *__cdecl memmove(void *, const void *, size_t); } 
#line 1201 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { extern void *__cdecl memcpy(void *, const void *, size_t); } 

extern "C" { extern errno_t __cdecl memcpy_s(void *, rsize_t, const void *, rsize_t); } 
extern "C" { extern errno_t __cdecl memmove_s(void *, rsize_t, const void *, rsize_t); } 
#line 1206 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { __inline int __cdecl fwide(FILE *_F, int _M) 
{ (void)_F; return _M; } } 
extern "C" { __inline int __cdecl mbsinit(const mbstate_t *_P) 
{ return (_P == (0)) || ((*_P) == 0); } } 
extern "C" { __inline const __wchar_t *__cdecl wmemchr(const __wchar_t *_S, __wchar_t _C, size_t _N) 
{ for (; (0) < _N; (++_S), (--_N)) { 
if ((*_S) == _C) { 
return _S; }  }  
return 0; } } 
extern "C" { __inline int __cdecl wmemcmp(const __wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
{ for (; (0) < _N; ((++_S1), (++_S2)), (--_N)) { 
if ((*_S1) != (*_S2)) { 
return ((*_S1) < (*_S2)) ? (-1) : (+1); }  }  
return 0; } } 

extern "C" { __inline __wchar_t *__cdecl wmemcpy(__wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
{ 
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
return (__wchar_t *)memcpy(_S1, _S2, _N * sizeof(__wchar_t)); 
#pragma warning( pop )
} } 


extern "C" { __inline errno_t __cdecl wmemcpy_s(__wchar_t *_S1, rsize_t _N1, const __wchar_t *_S2, rsize_t _N) 
{ 
#pragma warning( push )
#pragma warning( disable : 6386 )
return memcpy_s(_S1, _N1 * sizeof(__wchar_t), _S2, _N * sizeof(__wchar_t)); 
} } 
#pragma warning( pop )
#line 1239 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { __inline __wchar_t *__cdecl wmemmove(__wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
{ 
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
#pragma warning( disable : 6387)

return (__wchar_t *)memmove(_S1, _S2, _N * sizeof(__wchar_t)); 
#pragma warning( pop )
} } 


extern "C" { __inline errno_t __cdecl wmemmove_s(__wchar_t *_S1, rsize_t _N1, const __wchar_t *_S2, rsize_t _N) 
{ 
#pragma warning( push )
#pragma warning( disable : 6386 )
return memmove_s(_S1, _N1 * sizeof(__wchar_t), _S2, _N * sizeof(__wchar_t)); 
#pragma warning( pop )
} } 
#line 1259 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
extern "C" { __inline __wchar_t *__cdecl wmemset(__wchar_t *_S, __wchar_t _C, size_t _N) 
{ 
auto __wchar_t *_Su = _S; 
for (; (0) < _N; (++_Su), (--_N)) 
{ 
(*_Su) = _C; 
}  
return _S; 
} } 



inline __wchar_t *__cdecl wmemchr(__wchar_t *_S, __wchar_t _C, size_t _N) 
{ return (__wchar_t *)wmemchr((const __wchar_t *)_S, _C, _N); } 
#line 1282 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\wchar.h"
#pragma pack ( pop )
#line 16 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\cwchar"
typedef mbstate_t _Mbstatet; 




typedef mbstate_t _Mbstatet; 


namespace std { 
using ::_Mbstatet;

using ::mbstate_t;
using ::tm;using ::wint_t;


using ::btowc;using ::fgetwc;using ::fgetws;using ::fputwc;
using ::fputws;using ::fwide;using ::fwprintf;
using ::fwscanf;using ::getwc;using ::getwchar;
using ::mbrlen;using ::mbrtowc;using ::mbsrtowcs;
using ::mbsinit;using ::putwc;using ::putwchar;
using ::swprintf;using ::swscanf;using ::ungetwc;
using ::vfwprintf;using ::vswprintf;using ::vwprintf;
using ::wcrtomb;using ::wprintf;using ::wscanf;
using ::wcsrtombs;using ::wcstol;using ::wcscat;
using ::wcschr;using ::wcscmp;using ::wcscoll;
using ::wcscpy;using ::wcscspn;using ::wcslen;
using ::wcsncat;using ::wcsncmp;using ::wcsncpy;
using ::wcspbrk;using ::wcsrchr;using ::wcsspn;

using ::wcstod;using ::wcstoul;using ::wcsstr;

using ::wcstok;using ::wcsxfrm;using ::wctob;
using ::wmemchr;using ::wmemcmp;using ::wmemcpy;
using ::wmemmove;using ::wmemset;using ::wcsftime;


}
#line 23 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdbg.h"
#pragma pack ( push, 8 )
#line 46 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdbg.h"
extern "C" { typedef void *_HFILE; }
#line 65 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdbg.h"
extern "C" { typedef int (__cdecl *_CRT_REPORT_HOOK)(int, char *, int *); }
extern "C" { typedef int (__cdecl *_CRT_REPORT_HOOKW)(int, __wchar_t *, int *); }
#line 97 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdbg.h"
extern "C" { typedef int (__cdecl *_CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int); }
#line 158 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdbg.h"
extern "C" { typedef void (__cdecl *_CRT_DUMP_CLIENT)(void *, size_t); }
#line 166 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdbg.h"
struct _CrtMemBlockHeader; 
#line 174 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdbg.h"
extern "C" { typedef 
#line 167 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdbg.h"
struct _CrtMemState { 

_CrtMemBlockHeader *pBlockHeader; 
size_t lCounts[5]; 
size_t lSizes[5]; 
size_t lHighWaterCount; 
size_t lTotalCount; 
} _CrtMemState; }
#line 1122 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdbg.h"
#pragma warning(suppress: 4985)
extern void *__cdecl operator new[](size_t); 


extern void *__cdecl operator new(size_t, int, const char *, int); 
#line 1133 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdbg.h"
#pragma warning(suppress: 4985)
extern void *__cdecl operator new[](size_t, int, const char *, int); 
#line 1144 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdbg.h"
extern void __cdecl operator delete[](void *); 

inline void __cdecl operator delete(void *_P, int, const char *, int) 
{ ::operator delete(_P); } 
inline void __cdecl operator delete[](void *_P, int, const char *, int) 
{ ::operator delete[](_P); } 
#line 14 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iosfwd"
#pragma warning(push,3)
#line 1219 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\crtdbg.h"
#pragma pack ( pop )
#line 13 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iosfwd"
#pragma pack ( push, 8 )
#line 16 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iosfwd"
namespace std { 
#line 24 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iosfwd"
typedef long streamoff; 
typedef int streamsize; 
#line 41 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iosfwd"
extern fpos_t _Fpz; 
extern const streamoff _BADOFF; 
#line 46 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iosfwd"
template < class _Statetype >
 class fpos
 {
 typedef fpos < _Statetype > _Myt;

public :
  fpos ( streamoff _Off = 0 )
  : _Myoff ( _Off ), _Fpos ( 0 ), _Mystate ( _Stz )
  {
  }

  fpos ( _Statetype _State, fpos_t _Fileposition )
  : _Myoff ( 0 ), _Fpos ( _Fileposition ), _Mystate ( _State )
  {
  }

 _Statetype state ( ) const
  {
  return ( _Mystate );
  }

 void state ( _Statetype _State )
  {
  _Mystate = _State;
  }

 fpos_t seekpos ( ) const
  {
  return ( _Fpos );
  }

  operator streamoff ( ) const
  {
  return ( ( streamoff ) ( _Myoff + ( ( long ) ( _Fpos ) ) ) );
  }

 streamoff operator - ( const _Myt & _Right ) const
  {
  return ( ( streamoff ) * this - ( streamoff ) _Right );
  }

 _Myt & operator += ( streamoff _Off )
  {
  _Myoff += _Off;
  return ( * this );
  }

 _Myt & operator -= ( streamoff _Off )
  {
  _Myoff -= _Off;
  return ( * this );
  }

 _Myt operator + ( streamoff _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt operator - ( streamoff _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 bool operator == ( const _Myt & _Right ) const
  {
  return ( ( streamoff ) * this == ( streamoff ) _Right );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

private :
  static const _Statetype _Stz;
 streamoff _Myoff;
 fpos_t _Fpos;
 _Statetype _Mystate;
 };


template<class _Statetype> const _Statetype 
fpos< _Statetype> ::_Stz = (_Statetype()); 
#line 137 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iosfwd"
typedef fpos< int>  streampos; 
typedef streampos wstreampos; 


struct _Unsecure_char_traits_tag { 

}; 
struct _Secure_char_traits_tag { 

}; 
#line 153 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iosfwd"
struct _Char_traits_base { 

typedef _Unsecure_char_traits_tag _Secure_char_traits; 
}; 




template < class _Elem >
 struct char_traits :
  public _Char_traits_base
 {
 typedef _Elem char_type;
 typedef long int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static void __cdecl assign ( _Elem & _Left, const _Elem & _Right )
  {
  _Left = _Right;
  }

 static bool __cdecl eq ( const _Elem & _Left, const _Elem & _Right )
  {
  return ( _Left == _Right );
  }

 static bool __cdecl lt ( const _Elem & _Left, const _Elem & _Right )
  {
  return ( _Left < _Right );
  }

 static int __cdecl compare ( const _Elem * _First1,
     const _Elem * _First2, size_t _Count )
  {


  for (; 0 < _Count; -- _Count, ++ _First1, ++ _First2 )
   if ( ! eq ( * _First1, * _First2 ) )
    return ( lt ( * _First1, * _First2 ) ? - 1 : + 1 );
  return ( 0 );
  }

 static size_t __cdecl length ( const _Elem * _First )
  {

  size_t _Count;
  for ( _Count = 0; ! eq ( * _First, _Elem ( ) ); ++ _First )
   ++ _Count;
  return ( _Count );
  }

 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 static _Elem * __cdecl copy ( _Elem * _First1,
     const _Elem * _First2, size_t _Count )
  {

  return _Copy_s ( _First1, _Count, _First2, _Count );
  }

 static _Elem * __cdecl _Copy_s ( _Elem * _First1, size_t _Dest_size,
     const _Elem * _First2, size_t _Count )
  {


  { if ( ! ( _Dest_size >= _Count ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); return ( 0 ); } };
  _Elem * _Next = _First1;
  for (; 0 < _Count; -- _Count, ++ _Next, ++ _First2 )
   assign ( * _Next, * _First2 );
  return ( _First1 );
  }

 static const _Elem * __cdecl find ( const _Elem * _First,
  size_t _Count, const _Elem & _Ch )
  {

  for (; 0 < _Count; -- _Count, ++ _First )
   if ( eq ( * _First, _Ch ) )
    return ( _First );
  return ( 0 );
  }

 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 static _Elem * __cdecl move ( _Elem * _First1,
     const _Elem * _First2, size_t _Count )
  {

  return _Move_s ( _First1, _Count, _First2, _Count );
  }

 static _Elem * __cdecl _Move_s ( _Elem * _First1, size_t _Dest_size,
     const _Elem * _First2, size_t _Count )
  {


  { if ( ! ( _Dest_size >= _Count ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); return ( 0 ); } };
  _Elem * _Next = _First1;
  if ( _First2 < _Next && _Next < _First2 + _Count )
   for ( _Next += _Count, _First2 += _Count; 0 < _Count; -- _Count )
    assign ( * -- _Next, * -- _First2 );
  else
   for (; 0 < _Count; -- _Count, ++ _Next, ++ _First2 )
    assign ( * _Next, * _First2 );
  return ( _First1 );
  }

 static _Elem * __cdecl assign ( _Elem * _First,
  size_t _Count, _Elem _Ch )
  {

  _Elem * _Next = _First;
  for (; 0 < _Count; -- _Count, ++ _Next )
   assign ( * _Next, _Ch );
  return ( _First );
  }

 static _Elem __cdecl to_char_type ( const int_type & _Meta )
  {
  return ( ( _Elem ) _Meta );
  }

 static int_type __cdecl to_int_type ( const _Elem & _Ch )
  {
  return ( ( int_type ) _Ch );
  }

 static bool __cdecl eq_int_type ( const int_type & _Left,
  const int_type & _Right )
  {
  return ( _Left == _Right );
  }

 static int_type __cdecl eof ( )
  {
  return ( ( int_type ) ( - 1 ) );
  }

 static int_type __cdecl not_eof ( const int_type & _Meta )
  {
  return ( _Meta != eof ( ) ? ( int_type ) _Meta : ( int_type ) ! eof ( ) );
  }
 };


template<> struct char_traits< __wchar_t>  : public _Char_traits_base { 


typedef __wchar_t _Elem; 
typedef _Elem char_type; 
typedef wint_t int_type; 
typedef streampos pos_type; 
typedef streamoff off_type; 
typedef _Mbstatet state_type; 

static void __cdecl assign(_Elem &_Left, const _Elem &_Right) 
{ 
_Left = _Right; 
} 

static bool __cdecl eq(const _Elem &_Left, const _Elem &_Right) 
{ 
return (_Left) == (_Right); 
} 

static bool __cdecl lt(const _Elem &_Left, const _Elem &_Right) 
{ 
return (_Left) < (_Right); 
} 

static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 


return ::wmemcmp(_First1, _First2, _Count); 
} 

static size_t __cdecl length(const _Elem *_First) 
{ 

return ::wcslen(_First); 
} 


static __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 

return _Copy_s(_First1, _Count, _First2, _Count); 
} 

static _Elem *__cdecl _Copy_s(_Elem *_First1, size_t _Size_in_words, const _Elem *_First2, size_t 
_Count) 
{ 


::wmemcpy_s(_First1, _Size_in_words, _First2, _Count); 
return _First1; 
} 

static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
_Ch) 
{ 

return (const _Elem *)::wmemchr(_First, _Ch, _Count); 
} 


static __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 

return _Move_s(_First1, _Count, _First2, _Count); 
} 

static _Elem *__cdecl _Move_s(_Elem *_First1, size_t _Size_in_words, const _Elem *_First2, size_t 
_Count) 
{ 


::wmemmove_s(_First1, _Size_in_words, _First2, _Count); 
return _First1; 
} 

static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch) 
{ 

return (_Elem *)::wmemset(_First, _Ch, _Count); 
} 

static _Elem __cdecl to_char_type(const int_type &_Meta) 
{ 
return _Meta; 
} 

static int_type __cdecl to_int_type(const _Elem &_Ch) 
{ 
return _Ch; 
} 

static bool __cdecl eq_int_type(const int_type &_Left, const int_type &
_Right) 
{ 
return (_Left) == (_Right); 
} 

static int_type __cdecl eof() 
{ 
return (wint_t)65535; 
} 

static int_type __cdecl not_eof(const int_type &_Meta) 
{ 
return ((_Meta) != (eof())) ? (_Meta) : (!(eof())); 
} 
}; 



template<> struct char_traits< char>  : public _Char_traits_base { 


typedef char _Elem; 
typedef _Elem char_type; 
typedef int int_type; 
typedef streampos pos_type; 
typedef streamoff off_type; 
typedef _Mbstatet state_type; 

static void __cdecl assign(_Elem &_Left, const _Elem &_Right) 
{ 
_Left = _Right; 
} 

static bool __cdecl eq(const _Elem &_Left, const _Elem &_Right) 
{ 
return (_Left) == (_Right); 
} 

static bool __cdecl lt(const _Elem &_Left, const _Elem &_Right) 
{ 
return (_Left) < (_Right); 
} 

static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 


return ::memcmp(_First1, _First2, _Count); 
} 

static size_t __cdecl length(const _Elem *_First) 
{ 

return ::strlen(_First); 
} 


static __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 

return _Copy_s(_First1, _Count, _First2, _Count); 
} 

static _Elem *__cdecl _Copy_s(_Elem *_First1, size_t _Size_in_bytes, const _Elem *_First2, size_t 
_Count) 
{ 


::memcpy_s(_First1, _Size_in_bytes, _First2, _Count); 
return _First1; 
} 

static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
_Ch) 
{ 

return (const _Elem *)::memchr(_First, _Ch, _Count); 
} 


static __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
_Count) 
{ 

return _Move_s(_First1, _Count, _First2, _Count); 
} 

static _Elem *__cdecl _Move_s(_Elem *_First1, size_t _Size_in_bytes, const _Elem *_First2, size_t 
_Count) 
{ 


::memmove_s(_First1, _Size_in_bytes, _First2, _Count); 
return _First1; 
} 

static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch) 
{ 

return (_Elem *)::memset(_First, _Ch, _Count); 
} 

static _Elem __cdecl to_char_type(const int_type &_Meta) 
{ 
return (_Elem)(_Meta); 
} 

static int_type __cdecl to_int_type(const _Elem &_Ch) 
{ 
return (unsigned char)(_Ch); 
} 

static bool __cdecl eq_int_type(const int_type &_Left, const int_type &
_Right) 
{ 
return (_Left) == (_Right); 
} 

static int_type __cdecl eof() 
{ 
return -1; 
} 

static int_type __cdecl not_eof(const int_type &_Meta) 
{ 
return ((_Meta) != eof()) ? (_Meta) : (!(eof())); 
} 
}; 


template<class _Traits> 
class _Inherits_from_char_traits_base { 

typedef char _True; 
class _False { char _Dummy[2]; }; 
static _True _Inherits(_Char_traits_base); 
static _False _Inherits(...); 
static _Traits _Make_traits(); 


public: enum __cuda__Exists { _Exists = (sizeof((_Inherits(_Make_traits()))) == sizeof(_True))}; 
}; 

template<class _Traits, bool _Inherits_from_char_traits_base> 
class _Char_traits_category_helper { 


public: typedef _Unsecure_char_traits_tag _Secure_char_traits; 
}; 



template<class _Elem> 
class _Char_traits_category_helper< char_traits< _Elem> , true>  { 


public: typedef _Secure_char_traits_tag _Secure_char_traits; 
}; 

template<class _Traits> 
class _Char_traits_category_helper< _Traits, true>  { 


public: typedef typename _Traits::_Secure_char_traits _Secure_char_traits; 
}; 

template<class _Traits> 
class _Char_traits_category { 


public: typedef typename _Char_traits_category_helper< _Traits, _Inherits_from_char_traits_base< _Traits> ::_Exists> ::_Secure_char_traits _Secure_char_traits; 
}; 



template < class _Traits >
 inline
 typename _Char_traits_category < _Traits > :: _Secure_char_traits _Char_traits_cat ( )
 {
  typename _Char_traits_category < _Traits > :: _Secure_char_traits _Secure;
  return ( _Secure );
 }

namespace _Traits_helper { 



template < class _Traits >
 inline
 typename _Traits :: char_type * copy_s ( typename _Traits :: char_type * _First1, size_t _Size,
     const typename _Traits :: char_type * _First2, size_t _Count )
 {
  return copy_s < _Traits > ( _First1, _Size, _First2, _Count, _Char_traits_cat < _Traits > ( ) );
 }

template < class _Traits >
 inline
 typename _Traits :: char_type * copy_s ( typename _Traits :: char_type * _First1, size_t _Size,
     const typename _Traits :: char_type * _First2, size_t _Count, _Secure_char_traits_tag )
 {
  return _Traits :: _Copy_s ( _First1, _Size, _First2, _Count );
 }


template < class _Traits >
 inline
 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 typename _Traits :: char_type * copy_s ( typename _Traits :: char_type * _First1, size_t _Size,
     const typename _Traits :: char_type * _First2, size_t _Count, _Unsecure_char_traits_tag )
 {
  return _Traits :: copy ( _First1, _First2, _Count );
 }


template < class _Traits >
 inline
 typename _Traits :: char_type * move_s ( typename _Traits :: char_type * _First1, size_t _Size,
     const typename _Traits :: char_type * _First2, size_t _Count )
 {
  return move_s < _Traits > ( _First1, _Size, _First2, _Count, _Char_traits_cat < _Traits > ( ) );
 }

template < class _Traits >
 inline
 typename _Traits :: char_type * move_s ( typename _Traits :: char_type * _First1, size_t _Size,
     const typename _Traits :: char_type * _First2, size_t _Count, _Secure_char_traits_tag )
 {
  return _Traits :: _Move_s ( _First1, _Size, _First2, _Count );
 }


template < class _Traits >
 inline
 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 typename _Traits :: char_type * move_s ( typename _Traits :: char_type * _First1, size_t _Size,
     const typename _Traits :: char_type * _First2, size_t _Count, _Unsecure_char_traits_tag )
 {
  return _Traits :: move ( _First1, _First2, _Count );
 }

}


template < class _Ty >
 class allocator;
class ios_base; 
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ios;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class istreambuf_iterator;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class ostreambuf_iterator;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_streambuf;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_istream;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ostream;
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_iostream;
template<class _Elem, class 
_Traits, class 
_Alloc> class basic_stringbuf; 

template<class _Elem, class 
_Traits, class 
_Alloc> class basic_istringstream; 

template<class _Elem, class 
_Traits, class 
_Alloc> class basic_ostringstream; 

template<class _Elem, class 
_Traits, class 
_Alloc> class basic_stringstream; 

template<class _Elem, class 
_Traits> class basic_filebuf; 

template<class _Elem, class 
_Traits> class basic_ifstream; 

template<class _Elem, class 
_Traits> class basic_ofstream; 

template<class _Elem, class 
_Traits> class basic_fstream; 
#line 705 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iosfwd"
typedef basic_ios< char, char_traits< char> >  ios; 
typedef basic_streambuf< char, char_traits< char> >  streambuf; 
typedef basic_istream< char, char_traits< char> >  istream; 
typedef basic_ostream< char, char_traits< char> >  ostream; 
typedef basic_iostream< char, char_traits< char> >  iostream; 

typedef basic_stringbuf< char, char_traits< char> , allocator< char> >  stringbuf; 

typedef basic_istringstream< char, char_traits< char> , allocator< char> >  istringstream; 

typedef basic_ostringstream< char, char_traits< char> , allocator< char> >  ostringstream; 

typedef basic_stringstream< char, char_traits< char> , allocator< char> >  stringstream; 
typedef basic_filebuf< char, char_traits< char> >  filebuf; 
typedef basic_ifstream< char, char_traits< char> >  ifstream; 
typedef basic_ofstream< char, char_traits< char> >  ofstream; 
typedef basic_fstream< char, char_traits< char> >  fstream; 


typedef basic_ios< __wchar_t, char_traits< __wchar_t> >  wios; 

typedef basic_streambuf< __wchar_t, char_traits< __wchar_t> >  wstreambuf; 
typedef basic_istream< __wchar_t, char_traits< __wchar_t> >  wistream; 
typedef basic_ostream< __wchar_t, char_traits< __wchar_t> >  wostream; 
typedef basic_iostream< __wchar_t, char_traits< __wchar_t> >  wiostream; 

typedef basic_stringbuf< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstringbuf; 

typedef basic_istringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wistringstream; 

typedef basic_ostringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wostringstream; 

typedef basic_stringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstringstream; 
typedef basic_filebuf< __wchar_t, char_traits< __wchar_t> >  wfilebuf; 
typedef basic_ifstream< __wchar_t, char_traits< __wchar_t> >  wifstream; 
typedef basic_ofstream< __wchar_t, char_traits< __wchar_t> >  wofstream; 
typedef basic_fstream< __wchar_t, char_traits< __wchar_t> >  wfstream; 
#line 758 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iosfwd"
}


#pragma warning(pop)
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\utility"
#pragma warning(push,3)
#line 762 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iosfwd"
#pragma pack ( pop )
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\utility"
#pragma pack ( push, 8 )
#line 13 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\utility"
namespace std { 

template < class _Ty > inline
 void swap ( _Ty & _Left, _Ty & _Right )
 {
 if ( & _Left != & _Right )
  {
  _Ty _Tmp = _Left;

  _Left = _Right;
  _Right = _Tmp;
  }
 }


template < class _Ty > inline
 void _Swap_adl ( _Ty & _Left, _Ty & _Right )
 {
 swap ( _Left, _Right );
 }


template < class _Ty1,
 class _Ty2 >
 struct pair
 {
 typedef pair < _Ty1, _Ty2 > _Myt;
 typedef _Ty1 first_type;
 typedef _Ty2 second_type;

 pair ( )
  : first ( _Ty1 ( ) ), second ( _Ty2 ( ) )
  {
  }

 pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
  : first ( _Val1 ), second ( _Val2 )
  {
  }

 template < class _Other1,
  class _Other2 >
  pair ( const pair < _Other1, _Other2 > & _Right )
  : first ( _Right . first ), second ( _Right . second )
  {
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   :: std :: _Swap_adl ( first, _Right . first );
   :: std :: _Swap_adl ( second, _Right . second );
   }
  }

 _Ty1 first;
 _Ty2 second;
 };


template < class _Ty1,
 class _Ty2 > inline
 void swap ( pair < _Ty1, _Ty2 > & _Left, pair < _Ty1, _Ty2 > & _Right )
 {
 _Left . swap ( _Right );
 }

template < class _Ty1,
 class _Ty2 > inline
 bool operator == ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Left . first == _Right . first && _Left . second == _Right . second );
 }

template < class _Ty1,
 class _Ty2 > inline
 bool operator != ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }

template < class _Ty1,
 class _Ty2 > inline
 bool operator < ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Left . first < _Right . first ||
  ! ( _Right . first < _Left . first ) && _Left . second < _Right . second );
 }

template < class _Ty1,
 class _Ty2 > inline
 bool operator > ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Right < _Left );
 }

template < class _Ty1,
 class _Ty2 > inline
 bool operator <= ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }

template < class _Ty1,
 class _Ty2 > inline
 bool operator >= ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }

template < class _Ty1,
 class _Ty2 > inline
 pair < _Ty1, _Ty2 > make_pair ( _Ty1 _Val1, _Ty2 _Val2 )
 {
 return ( pair < _Ty1, _Ty2 > ( _Val1, _Val2 ) );
 }


namespace rel_ops { 

template < class _Ty > inline
 bool operator != ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }

template < class _Ty > inline
 bool operator > ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( _Right < _Left );
 }

template < class _Ty > inline
 bool operator <= ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }

template < class _Ty > inline
 bool operator >= ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
}
}


namespace std { 
namespace tr1 { 


template<class _Tuple> struct tuple_size; 

template<int _Idx, class 
_Tuple> struct tuple_element; 

template<class _Ty1, class 
_Ty2> 
struct tuple_size< pair< _Ty1, _Ty2> >  { 

static const int value = 2; 
}; 

template<int _Idx, class 
_Ty> struct _Pair_data; 

template < class _Ty1,
 class _Ty2 >
 struct _Pair_data < 0, std :: pair < _Ty1, _Ty2 > >
 {
 typedef _Ty1 & _Type;
 typedef const _Ty1 & _CType;

 static _Type _Val ( std :: pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . first );
  }

 static _CType _Val ( const std :: pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . first );
  }
 };

template < class _Ty1,
 class _Ty2 >
 struct _Pair_data < 1, std :: pair < _Ty1, _Ty2 > >
 {
 typedef _Ty2 & _Type;
 typedef const _Ty2 & _CType;

 static _Type _Val ( std :: pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . second );
  }

 static _CType _Val ( const std :: pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . second );
  }
 };

template<class _Ty1, class 
_Ty2> 
struct tuple_element< 0, pair< _Ty1, _Ty2> >  { 

typedef _Ty1 type; 
}; 

template<class _Ty1, class 
_Ty2> 
struct tuple_element< 1, pair< _Ty1, _Ty2> >  { 

typedef _Ty2 type; 
}; 

template < int _Idx,
 class _Ty1,
 class _Ty2 >
 typename _Pair_data < _Idx, std :: pair < _Ty1, _Ty2 > > :: _Type
  get ( std :: pair < _Ty1, _Ty2 > & _Pr )
 {
 return ( _Pair_data < _Idx, std :: pair < _Ty1, _Ty2 > > :: _Val ( _Pr ) );
 }

template < int _Idx,
 class _Ty1,
 class _Ty2 >
 typename _Pair_data < _Idx, std :: pair < _Ty1, _Ty2 > > :: _CType
  get ( const std :: pair < _Ty1, _Ty2 > & _Pr )
 {
 return ( _Pair_data < _Idx, std :: pair < _Ty1, _Ty2 > > :: _Val ( _Pr ) );
 }

}
}
#line 259 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\utility"
#pragma warning(pop)
#line 12 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
#pragma warning(push,3)
#line 260 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\utility"
#pragma pack ( pop )
#line 11 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
#pragma pack ( push, 8 )
#line 15 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
namespace std { 


struct _Unchecked_iterator_tag { 

}; 
struct _Range_checked_iterator_tag { 

}; 


struct _Unchanged_checked_iterator_base_type_tag { 

}; 

struct _Different_checked_iterator_base_type_tag { 

}; 


struct _Undefined_inner_type_tag { 

}; 


struct _Undefined_move_tag { 

}; 

struct _Swap_move_tag { 

}; 


class _Iterator_base_universal { 


public: typedef _Unchecked_iterator_tag _Checked_iterator_category; 
typedef _Unchanged_checked_iterator_base_type_tag _Checked_iterator_base_type; 
typedef _Undefined_inner_type_tag _Inner_type; 
}; 
#line 359 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
class _Container_base_aux; 

class _Aux_cont { 


public: explicit _Aux_cont(const _Container_base_aux *const _Pcont) : _Mycontainer(_Pcont) 
{ } 

const _Container_base_aux *_Getcont() const 
{ 
return this->_Mycontainer; 
} 


private: const _Container_base_aux *_Mycontainer; 
}; 

class _Container_base_aux { 


public: _Container_base_aux() 
{ 

} 

_Container_base_aux(const _Container_base_aux &) 
{ 

} 

_Container_base_aux &operator=(const _Container_base_aux &) 
{ 

return *this; 
} 

void _Swap_aux(_Container_base_aux &_Right) 
{ 
::std::swap(this->_Myownedaux, _Right._Myownedaux); 
::std::swap(*(this->_Myownedaux), *(_Right._Myownedaux)); 
} 

~_Container_base_aux() 
{ 

} 


friend class _Iterator_base_aux; 

protected: _Aux_cont *_Myownedaux; 
}; 

template < class _Alloc >
 class _Container_base_aux_alloc_real
  : public _Container_base_aux
 {
 protected :
 explicit _Container_base_aux_alloc_real ( _Alloc _Al )
  : _Alaux ( _Al )
  {
  _Myownedaux = new ( _Alaux . allocate ( 1 ) ) _Aux_cont ( this );
  }

 _Container_base_aux_alloc_real ( const _Container_base_aux_alloc_real & _Right )
  : _Alaux ( _Right . _Alaux )
  {
  _Myownedaux = new ( _Alaux . allocate ( 1 ) ) _Aux_cont ( this );
  }

 _Container_base_aux_alloc_real & operator = ( const _Container_base_aux_alloc_real & )
  {

  return * this;
  }

 ~ _Container_base_aux_alloc_real ( )
  {
  _Myownedaux -> ~ _Aux_cont ( );

  _Alaux . deallocate ( _Myownedaux, 1 );
  }

 typename _Alloc :: template rebind < _Aux_cont > :: other _Alaux;
 };

class _Iterator_base_aux : public _Iterator_base_universal { 


public: _Iterator_base_aux() : _Myaux((0)) 
{ } 

void _Set_container(const _Container_base_aux *const _Pcont) 
{ 
(this->_Myaux) = _Pcont->_Myownedaux; 
} 

const _Container_base_aux *_Getmycont() const 
{ 
return (this->_Myaux) ? (*(this->_Myaux))._Getcont() : (0); 
} 

bool _Same_container(const _Iterator_base_aux &_Other) const 
{ 
return (this->_Myaux) == (_Other._Myaux); 
} 

bool _Has_container() const 
{ 
return (this->_Myaux) != (0); 
} 


private: const _Aux_cont *_Myaux; 
}; 
#line 547 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
class _Container_base_secure { 

}; 
#line 561 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
class _Iterator_base_secure : public _Iterator_base_universal { 



public: _Iterator_base_secure() : _Mycont((0)) 

{ 
} 

const _Container_base_secure *_Getmycont() const 
{ 
return this->_Mycont; 
} 

bool _Same_container(const _Iterator_base_secure &_Other) const 
{ 
return (this->_Mycont) == (_Other._Mycont); 
} 

bool _Has_container() const 
{ 
return (this->_Mycont) != (0); 
} 

const _Container_base_secure *_Mycont; 
}; 




typedef _Container_base_aux _Container_base; 
typedef _Iterator_base_aux _Iterator_base; 
#line 613 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _Alloc >
 class _Container_base_aux_alloc_empty
  : public _Container_base
 {
 protected :
 explicit _Container_base_aux_alloc_empty ( _Alloc ) { }

 _Container_base_aux_alloc_empty ( const _Container_base_aux_alloc_empty & ) { }

 _Container_base_aux_alloc_empty & operator = ( const _Container_base_aux_alloc_empty & )
  {
  return * this;
  }

 ~ _Container_base_aux_alloc_empty ( ) { }
 };
#line 642 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
struct input_iterator_tag { 

}; 

struct output_iterator_tag { 

}; 

struct forward_iterator_tag : public input_iterator_tag { 


}; 

struct bidirectional_iterator_tag : public forward_iterator_tag { 


}; 

struct random_access_iterator_tag : public bidirectional_iterator_tag { 


}; 

struct _Int_iterator_tag { 

}; 

struct _Float_iterator_tag { 

}; 


struct _Nonscalar_ptr_iterator_tag { 

}; 
struct _Scalar_ptr_iterator_tag { 

}; 


template<class _Category, class 
_Ty, class 
_Diff, class 
_Pointer, class 
_Reference> 
struct iterator : public _Iterator_base_universal { 



typedef _Category iterator_category; 
typedef _Ty value_type; 
typedef _Diff difference_type; 
typedef _Diff distance_type; 
typedef _Pointer pointer; 
typedef _Reference reference; 
}; 

template<class _Category, class 
_Ty, class 
_Diff, class 
_Pointer, class 
_Reference, class 
_Base_class> 
struct _Iterator_with_base : public _Base_class { 



typedef _Category iterator_category; 
typedef _Ty value_type; 
typedef _Diff difference_type; 
typedef _Diff distance_type; 
typedef _Pointer pointer; 
typedef _Reference reference; 
}; 

template<class _Ty, class 
_Diff, class 
_Pointer, class 
_Reference> 
struct _Bidit : public _Iterator_with_base< bidirectional_iterator_tag, _Ty, _Diff, _Pointer, _Reference, _Iterator_base_aux>  { 



}; 

template<class _Ty, class 
_Diff, class 
_Pointer, class 
_Reference> 
struct _Ranit : public _Iterator_with_base< random_access_iterator_tag, _Ty, _Diff, _Pointer, _Reference, _Iterator_base_aux>  { 



}; 

template<class _Ty, class 
_Diff, class 
_Pointer, class 
_Reference, class 
_Base_class> 
struct _Ranit_base : public _Base_class { 



typedef random_access_iterator_tag iterator_category; 
typedef _Ty value_type; 
typedef _Diff difference_type; 
typedef _Diff distance_type; 
typedef _Pointer pointer; 
typedef _Reference reference; 
}; 

struct _Outit : public iterator< output_iterator_tag, void, void, void, void>  { 



}; 


template<class _Iter> 
struct iterator_traits { 

typedef typename _Iter::iterator_category iterator_category; 
typedef typename _Iter::value_type value_type; 
typedef typename _Iter::difference_type difference_type; 
typedef difference_type distance_type; 
typedef typename _Iter::pointer pointer; 
typedef typename _Iter::reference reference; 
}; 

template<class _Ty> 
struct iterator_traits< _Ty *>  { 

typedef random_access_iterator_tag iterator_category; 
typedef _Ty value_type; 
typedef ptrdiff_t difference_type; 
typedef ptrdiff_t distance_type; 
typedef _Ty *pointer; 
typedef _Ty &reference; 
}; 

template<class _Ty> 
struct iterator_traits< const _Ty *>  { 

typedef random_access_iterator_tag iterator_category; 
typedef _Ty value_type; 
typedef ptrdiff_t difference_type; 
typedef ptrdiff_t distance_type; 
typedef const _Ty *pointer; 
typedef const _Ty &reference; 
}; 

template<> struct iterator_traits< bool>  { 

typedef _Int_iterator_tag iterator_category; 
typedef _Bool value_type; 
typedef _Bool difference_type; 
typedef _Bool distance_type; 
typedef _Bool *pointer; 
typedef _Bool &reference; 
}; 

template<> struct iterator_traits< char>  { 

typedef _Int_iterator_tag iterator_category; 
typedef char value_type; 
typedef char difference_type; 
typedef char distance_type; 
typedef char *pointer; 
typedef char &reference; 
}; 

template<> struct iterator_traits< signed char>  { 

typedef _Int_iterator_tag iterator_category; 
typedef signed char value_type; 
typedef signed char difference_type; 
typedef signed char distance_type; 
typedef signed char *pointer; 
typedef signed char &reference; 
}; 

template<> struct iterator_traits< unsigned char>  { 

typedef _Int_iterator_tag iterator_category; 
typedef unsigned char value_type; 
typedef unsigned char difference_type; 
typedef unsigned char distance_type; 
typedef unsigned char *pointer; 
typedef unsigned char &reference; 
}; 


template<> struct iterator_traits< __wchar_t>  { 

typedef _Int_iterator_tag iterator_category; 
typedef __wchar_t value_type; 
typedef __wchar_t difference_type; 
typedef __wchar_t distance_type; 
typedef __wchar_t *pointer; 
typedef __wchar_t &reference; 
}; 
#line 846 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template<> struct iterator_traits< short>  { 

typedef _Int_iterator_tag iterator_category; 
typedef short value_type; 
typedef short difference_type; 
typedef short distance_type; 
typedef short *pointer; 
typedef short &reference; 
}; 

template<> struct iterator_traits< unsigned short>  { 

typedef _Int_iterator_tag iterator_category; 
typedef unsigned short value_type; 
typedef unsigned short difference_type; 
typedef unsigned short distance_type; 
typedef unsigned short *pointer; 
typedef unsigned short &reference; 
}; 

template<> struct iterator_traits< int>  { 

typedef _Int_iterator_tag iterator_category; 
typedef int value_type; 
typedef int difference_type; 
typedef int distance_type; 
typedef int *pointer; 
typedef int &reference; 
}; 

template<> struct iterator_traits< unsigned>  { 

typedef _Int_iterator_tag iterator_category; 
typedef unsigned value_type; 
typedef unsigned difference_type; 
typedef unsigned distance_type; 
typedef unsigned *pointer; 
typedef unsigned &reference; 
}; 

template<> struct iterator_traits< long>  { 

typedef _Int_iterator_tag iterator_category; 
typedef long value_type; 
typedef long difference_type; 
typedef long distance_type; 
typedef long *pointer; 
typedef long &reference; 
}; 

template<> struct iterator_traits< unsigned long>  { 

typedef _Int_iterator_tag iterator_category; 
typedef unsigned long value_type; 
typedef unsigned long difference_type; 
typedef unsigned long distance_type; 
typedef unsigned long *pointer; 
typedef unsigned long &reference; 
}; 

template<> struct iterator_traits< double>  { 

typedef _Float_iterator_tag iterator_category; 
typedef double value_type; 
typedef double difference_type; 
typedef double distance_type; 
typedef double *pointer; 
typedef double &reference; 
}; 

template<> struct iterator_traits< float>  { 

typedef _Float_iterator_tag iterator_category; 
typedef float value_type; 
typedef float difference_type; 
typedef float distance_type; 
typedef float *pointer; 
typedef float &reference; 
}; 


template<> struct iterator_traits< __int64>  { 

typedef _Int_iterator_tag iterator_category; 
typedef __int64 value_type; 
typedef __int64 difference_type; 
typedef __int64 distance_type; 
typedef __int64 *pointer; 
typedef __int64 &reference; 
}; 

template<> struct iterator_traits< unsigned __int64>  { 

typedef _Int_iterator_tag iterator_category; 
typedef unsigned __int64 value_type; 
typedef unsigned __int64 difference_type; 
typedef unsigned __int64 distance_type; 
typedef unsigned __int64 *pointer; 
typedef unsigned __int64 &reference; 
}; 
#line 949 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _Iter > inline
 typename iterator_traits < _Iter > :: iterator_category
  __cdecl _Iter_cat ( const _Iter & )
 {
 typename iterator_traits < _Iter > :: iterator_category _Cat;
 return ( _Cat );
 }




template<class _Cat1, class _Cat2> 
class _Iter_random_helper { 


public: typedef forward_iterator_tag _Iter_random_cat; 
}; 


template<> class _Iter_random_helper< random_access_iterator_tag, random_access_iterator_tag>  { 


public: typedef random_access_iterator_tag _Iter_random_cat; 
}; 

template<class _Cat1, class _Cat2, class _Cat3> 
class _Iter_random_helper3 { 


public: typedef forward_iterator_tag _Iter_random_cat; 
}; 


template<> class _Iter_random_helper3< random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag>  { 


public: typedef random_access_iterator_tag _Iter_random_cat; 
}; 

template < class _Iter1, class _Iter2 > inline
 typename _Iter_random_helper <
  typename iterator_traits < _Iter1 > :: iterator_category,
  typename iterator_traits < _Iter2 > :: iterator_category > :: _Iter_random_cat
  __cdecl _Iter_random ( const _Iter1 &, const _Iter2 & )
 {
 typename _Iter_random_helper <
  iterator_traits < _Iter1 > :: iterator_category,
  iterator_traits < _Iter2 > :: iterator_category > :: _Iter_random_cat _Cat;
 return ( _Cat );
 }

template < class _Iter1, class _Iter2, class _Iter3 > inline
 typename _Iter_random_helper3 <
  typename iterator_traits < _Iter1 > :: iterator_category,
  typename iterator_traits < _Iter2 > :: iterator_category,
  typename iterator_traits < _Iter3 > :: iterator_category > :: _Iter_random_cat
  __cdecl _Iter_random ( const _Iter1 &, const _Iter2 &, const _Iter3 & )
 {
 typename _Iter_random_helper3 <
  iterator_traits < _Iter1 > :: iterator_category,
  iterator_traits < _Iter2 > :: iterator_category,
  iterator_traits < _Iter3 > :: iterator_category > :: _Iter_random_cat _Cat;
 return ( _Cat );
 }



template<bool _Cond, class _Ty1, class _Ty2> 
class _If { 


public: typedef _Ty2 _Result; 
}; 

template<class _Ty1, class _Ty2> 
class _If< true, _Ty1, _Ty2>  { 


public: typedef _Ty1 _Result; 
}; 


template<bool _Secure_validation> 
class _Secure_validation_helper { 


public: typedef _Unchecked_iterator_tag _Checked_iterator_category; 
}; 


template<> class _Secure_validation_helper< true>  { 


public: typedef _Range_checked_iterator_tag _Checked_iterator_category; 
}; 



template<class _Iter, bool _Inherits_from_iterator_base> 
class _Checked_iterator_category_helper { 


public: typedef _Unchecked_iterator_tag _Checked_cat; 
}; 

template<class _Iter> 
class _Checked_iterator_category_helper< _Iter, true>  { 


public: typedef typename _Iter::_Checked_iterator_category _Checked_cat; 
}; 

template<class _Iter> 
class _Checked_iterator_category { 


public: typedef typename _Checked_iterator_category_helper< _Iter, __is_base_of(_Iterator_base_universal, _Iter)> ::_Checked_cat _Checked_cat; 
}; 

template < class _Iter >
 inline
 typename _Checked_iterator_category < _Iter > :: _Checked_cat _Checked_cat ( const _Iter & )
 {
  typename _Checked_iterator_category < _Iter > :: _Checked_cat _Cat;
  return ( _Cat );
 }


template<class _Iter, bool _Inherits_from_iterator_base> 
class _Checked_iterator_base_helper2 { 


public: typedef _Unchanged_checked_iterator_base_type_tag _Checked_iterator_base_type; 
}; 

template<class _Iter> 
class _Checked_iterator_base_helper2< _Iter, true>  { 


public: typedef typename _Iter::_Checked_iterator_base_type _Checked_iterator_base_type; 
}; 

template<class _Iter, class _Base_type> 
class _Checked_iterator_base_helper1 { 


public: typedef _Different_checked_iterator_base_type_tag _Base_type_tag; 
typedef _Base_type _Checked_iterator_base_type; 
}; 

template<class _Iter> 
class _Checked_iterator_base_helper1< _Iter, _Unchanged_checked_iterator_base_type_tag>  { 


public: typedef _Unchanged_checked_iterator_base_type_tag _Base_type_tag; 
typedef _Iter _Checked_iterator_base_type; 
}; 

template<class _Iter> 
class _Checked_iterator_base_helper { 


public: typedef _Checked_iterator_base_helper2< _Iter, __is_base_of(_Iterator_base_universal, _Iter)>  _Base_helper2; 
typedef _Checked_iterator_base_helper1< _Iter, typename _Checked_iterator_base_helper2< _Iter, __is_base_of(_Iterator_base_universal, _Iter)> ::_Checked_iterator_base_type>  _Base_helper1; 

typedef typename _Checked_iterator_base_helper1< _Iter, typename _Checked_iterator_base_helper2< _Iter, __is_base_of(_Iterator_base_universal, _Iter)> ::_Checked_iterator_base_type> ::_Base_type_tag _Checked_iterator_base_type_tag; 
typedef typename _Checked_iterator_base_helper1< _Iter, typename _Checked_iterator_base_helper2< _Iter, __is_base_of(_Iterator_base_universal, _Iter)> ::_Checked_iterator_base_type> ::_Checked_iterator_base_type _Checked_iterator_base_type; 
}; 

template < class _Iter, class _Base_tag >
 inline
 typename _Checked_iterator_base_helper < _Iter > :: _Checked_iterator_base_type
  __cdecl _Checked_base ( const _Iter & _It, _Base_tag )
 {
  return _It . _Checked_iterator_base ( );
 }

template < class _Iter >
 inline
 typename _Checked_iterator_base_helper < _Iter > :: _Checked_iterator_base_type
  __cdecl _Checked_base ( const _Iter & _It, _Unchanged_checked_iterator_base_type_tag )
 {
  return _It;
 }

template < class _Iter, class _Base_tag >
 inline
 typename _Checked_iterator_base_helper < _Iter > :: _Checked_iterator_base_type
  __cdecl _Checked_base ( _Iter & _It, _Base_tag )
 {
  return _It . _Checked_iterator_base ( );
 }

template < class _Iter >
 inline
 typename _Checked_iterator_base_helper < _Iter > :: _Checked_iterator_base_type
  __cdecl _Checked_base ( _Iter & _It, _Unchanged_checked_iterator_base_type_tag )
 {
  return _It;
 }

template < class _Iter >
 inline
 typename _Checked_iterator_base_helper < _Iter > :: _Checked_iterator_base_type
  __cdecl _Checked_base ( const _Iter & _It )
 {
  typename _Checked_iterator_base_helper < _Iter > :: _Checked_iterator_base_type_tag _Base_tag;
  return _Checked_base ( _It, _Base_tag );
 }

template < class _Iter >
 inline
 typename _Checked_iterator_base_helper < _Iter > :: _Checked_iterator_base_type
  __cdecl _Checked_base ( _Iter & _It )
 {
  typename _Checked_iterator_base_helper < _Iter > :: _Checked_iterator_base_type_tag _Base_tag;
  return _Checked_base ( _It, _Base_tag );
 }



template < class _DstIter, class _BaseIter >
 inline
 void __cdecl _Checked_assign_from_base ( _DstIter & _Dest, const _BaseIter & _Src )
 {
  _Dest . _Checked_iterator_assign_from_base ( _Src );
 }

template < class _Iter >
 inline
 void __cdecl _Checked_assign_from_base ( _Iter & _Dest, const _Iter & _Src )
 {
  _Dest = _Src;
 }
#line 1190 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template<class _Value> 
class _Move_operation_category { 


public: typedef _Undefined_move_tag _Move_cat; 
}; 

template < class _Iter >
 inline
  typename _Move_operation_category < typename iterator_traits < _Iter > :: value_type > :: _Move_cat _Move_cat ( const _Iter & )
 {
  typename _Move_operation_category < typename iterator_traits < _Iter > :: value_type > :: _Move_cat _Cat;
  return ( _Cat );
 }

template<class _Ty> 
struct _Is_swap_move { 

static const bool _Value = false; 
}; 


template<> struct _Is_swap_move< _Swap_move_tag>  { 

static const bool _Value = true; 
}; 

template<class _Ty1, class 
_Ty2> 
class _Move_operation_category< pair< _Ty1, _Ty2> >  { 
#line 1228 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
public: typedef typename _If< (_Is_swap_move< typename std::_Move_operation_category< _Ty1> ::_Move_cat> ::_Value && _Is_swap_move< typename std::_Move_operation_category< _Ty2> ::_Move_cat> ::_Value), _Swap_move_tag, _Undefined_move_tag> ::_Result _Move_cat; 
}; 


template<class _T1, class _T2, class _Checked_Cat1, class _Checked_Cat2> 
struct _Ptr_cat_with_checked_cat_helper { 

typedef _Nonscalar_ptr_iterator_tag _Ptr_cat; 
}; 

template<class _T1, class _T2> 
struct _Ptr_cat_helper { 



typedef typename _Ptr_cat_with_checked_cat_helper< _T1, _T2, typename _Checked_iterator_category< _T1> ::_Checked_cat, typename _Checked_iterator_category< _T2> ::_Checked_cat> ::_Ptr_cat _Ptr_cat; 
}; 

template<class _T1, class _T2, class _Checked_Cat1> 
struct _Ptr_cat_with_checked_cat_helper< _T1, _T2, _Checked_Cat1, _Range_checked_iterator_tag>  { 

typedef typename _Ptr_cat_helper< _T1, typename _T2::_Inner_type> ::_Ptr_cat _Ptr_cat; 
}; 

template<class _T1, class _T2, class _Checked_Cat2> 
struct _Ptr_cat_with_checked_cat_helper< _T1, _T2, _Range_checked_iterator_tag, _Checked_Cat2>  { 

typedef typename _Ptr_cat_helper< typename _T1::_Inner_type, _T2> ::_Ptr_cat _Ptr_cat; 
}; 

template<class _T1, class _T2> 
struct _Ptr_cat_with_checked_cat_helper< _T1, _T2, _Range_checked_iterator_tag, _Range_checked_iterator_tag>  { 

typedef typename _Ptr_cat_helper< typename _T1::_Inner_type, typename _T2::_Inner_type> ::_Ptr_cat _Ptr_cat; 
}; 

template<class _T1> 
struct _Ptr_cat_helper< _T1, _Undefined_inner_type_tag>  { 

typedef _Nonscalar_ptr_iterator_tag _Ptr_cat; 
}; 

template<class _T2> 
struct _Ptr_cat_helper< _Undefined_inner_type_tag, _T2>  { 

typedef _Nonscalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< _Undefined_inner_type_tag, _Undefined_inner_type_tag>  { 

typedef _Nonscalar_ptr_iterator_tag _Ptr_cat; 
}; 



template<> struct _Ptr_cat_helper< bool *, bool *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const bool *, bool *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< char *, char *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const char *, char *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< signed char *, signed char *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const signed char *, signed char *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< unsigned char *, unsigned char *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const unsigned char *, unsigned char *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 




template<> struct _Ptr_cat_helper< __wchar_t *, __wchar_t *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const __wchar_t *, __wchar_t *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 
#line 1347 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template<> struct _Ptr_cat_helper< short *, short *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const short *, short *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< unsigned short *, unsigned short *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const unsigned short *, unsigned short *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< int *, int *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const int *, int *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< unsigned *, unsigned *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const unsigned *, unsigned *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< long *, long *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const long *, long *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< unsigned long *, unsigned long *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const unsigned long *, unsigned long *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< float *, float *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const float *, float *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< double *, double *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const double *, double *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< long double *, long double *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const long double *, long double *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 




template<> struct _Ptr_cat_helper< __int64 *, __int64 *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const __int64 *, __int64 *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< unsigned __int64 *, unsigned __int64 *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template<> struct _Ptr_cat_helper< const unsigned __int64 *, unsigned __int64 *>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 
#line 1482 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template<class _Ty> 
struct _Ptr_cat_helper< _Ty **, _Ty **>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 

template<class _Ty> 
struct _Ptr_cat_helper< _Ty **, const _Ty **>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 

template<class _Ty> 
struct _Ptr_cat_helper< _Ty *const *, _Ty **>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 

template<class _Ty> 
struct _Ptr_cat_helper< _Ty *const *, const _Ty **>  { 

typedef _Scalar_ptr_iterator_tag _Ptr_cat; 
}; 


template < class _T1, class _T2 > inline
typename _Ptr_cat_helper < _T1, _T2 > :: _Ptr_cat __cdecl _Ptr_cat ( _T1 &, _T2 & )
 {
 typename _Ptr_cat_helper < _T1, _T2 > :: _Ptr_cat _Cat;
 return ( _Cat );
 }
#line 1763 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _Iter > inline
 typename iterator_traits < _Iter > :: value_type * __cdecl _Val_type ( _Iter )
 {
 return ( 0 );
 }


template < class _InIt,
 class _Diff > inline
 void __cdecl advance ( _InIt & _Where, _Diff _Off )
 {
 _Advance ( _Where, _Off, _Iter_cat ( _Where ) );
 }

template < class _InIt,
 class _Diff > inline
 void __cdecl _Advance ( _InIt & _Where, _Diff _Off, input_iterator_tag )
 {






 for (; 0 < _Off; -- _Off )
  ++ _Where;
 }
#line 1791 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _FI,
 class _Diff > inline
 void __cdecl _Advance ( _FI & _Where, _Diff _Off, forward_iterator_tag )
 {






 for (; 0 < _Off; -- _Off )
  ++ _Where;
 }
#line 1805 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
#pragma warning(push)
#pragma warning(disable: 6295)
template < class _BI,
 class _Diff > inline
 void __cdecl _Advance ( _BI & _Where, _Diff _Off, bidirectional_iterator_tag )
 {
 for (; 0 < _Off; -- _Off )
  ++ _Where;
 for (; _Off < 0; ++ _Off )
  -- _Where;
 }
#pragma warning(pop)

template < class _RI,
 class _Diff > inline
 void __cdecl _Advance ( _RI & _Where, _Diff _Off, random_access_iterator_tag )
 {
 _Where += _Off;
 }



template < class _Iter > inline
 typename iterator_traits < _Iter > :: difference_type
  * __cdecl _Dist_type ( _Iter )
 {
 return ( 0 );
 }


template < class _InIt,
 class _Diff > inline
  void __cdecl _Distance2 ( _InIt _First, _InIt _Last, _Diff & _Off,
   input_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  ++ _Off;
 }

template < class _FwdIt,
 class _Diff > inline
  void __cdecl _Distance2 ( _FwdIt _First, _FwdIt _Last, _Diff & _Off,
   forward_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  ++ _Off;
 }

template < class _BidIt,
 class _Diff > inline
  void __cdecl _Distance2 ( _BidIt _First, _BidIt _Last, _Diff & _Off,
   bidirectional_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  ++ _Off;
 }

template < class _RanIt,
 class _Diff > inline
  void __cdecl _Distance2 ( _RanIt _First, _RanIt _Last, _Diff & _Off,
   random_access_iterator_tag )
 {









 _Off += _Last - _First;
 }
#line 1879 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt > inline
 typename iterator_traits < _InIt > :: difference_type
  __cdecl distance ( _InIt _First, _InIt _Last )
 {
 typename iterator_traits < _InIt > :: difference_type _Off = 0;
 _Distance2 ( _First, _Last, _Off, _Iter_cat ( _First ) );
 return ( _Off );
 }


template < class _InIt,
 class _Diff > inline
  void __cdecl _Distance ( _InIt _First, _InIt _Last, _Diff & _Off )
 {
 _Distance2 ( _First, _Last, _Off, _Iter_cat ( _First ) );
 }


template < class _RanIt,
 class _Base >
 class _Revranit
  : public _Base
 {
public :
 typedef _Revranit < _RanIt, _Base > _Myt;
 typedef typename iterator_traits < _RanIt > :: iterator_category iterator_category;
 typedef typename iterator_traits < _RanIt > :: value_type value_type;
 typedef typename iterator_traits < _RanIt > :: difference_type difference_type;
 typedef typename iterator_traits < _RanIt > :: difference_type distance_type;
 typedef typename iterator_traits < _RanIt > :: pointer pointer;
 typedef typename iterator_traits < _RanIt > :: reference reference;
 typedef _RanIt iterator_type;

  _Revranit ( )
  {
  }

 explicit _Revranit ( _RanIt _Right )
  : current ( _Right )
  {
  }

 template < class _RanIt2,
  class _Base2 >
  _Revranit ( const _Revranit < _RanIt2, _Base2 > & _Right )
  : current ( _Right . base ( ) )
  {
  }

 _RanIt base ( ) const
  {
  return ( current );
  }

 reference operator * ( ) const
  {
  _RanIt _Tmp = current;
  return ( * -- _Tmp );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myt & operator ++ ( )
  {
  -- current;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  ++ current;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

 template < class _RanIt2,
  class _Base2 >
  bool _Equal ( const _Revranit < _RanIt2, _Base2 > & _Right ) const
  {
  return ( current == _Right . base ( ) );
  }



 _Myt & operator += ( difference_type _Off )
  {
  current -= _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  return ( _Myt ( current - _Off ) );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  current += _Off;
  return ( * this );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  return ( _Myt ( current + _Off ) );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 template < class _RanIt2,
  class _Base2 >
  bool _Less ( const _Revranit < _RanIt2, _Base2 > & _Right ) const
  {
  return ( _Right . base ( ) < current );
  }

 template < class _RanIt2,
  class _Base2 >
  difference_type _Minus ( const _Revranit < _RanIt2, _Base2 > & _Right ) const
  {
  return ( _Right . base ( ) - current );
  }

protected :
 _RanIt current;
 };


template < class _RanIt,
 class _Base,
 class _Diff > inline
 _Revranit < _RanIt, _Base >
  operator + ( _Diff _Off,
  const _Revranit < _RanIt, _Base > & _Right )
 {
 return ( _Right + _Off );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 typename _Base1 :: difference_type operator - (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Left . _Minus ( _Right ) );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator == (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator != (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator < (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Left . _Less ( _Right ) );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator > (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Right < _Left );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator <= (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }

template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator >= (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }


template < class _RanIt >
 class reverse_iterator
  : public _Revranit < _RanIt, iterator <
   typename iterator_traits < _RanIt > :: iterator_category,
   typename iterator_traits < _RanIt > :: value_type,
   typename iterator_traits < _RanIt > :: difference_type,
   typename iterator_traits < _RanIt > :: pointer,
   typename iterator_traits < _RanIt > :: reference > >
 {
 typedef reverse_iterator < _RanIt > _Myt;
 typedef _Revranit < _RanIt, iterator <
   typename iterator_traits < _RanIt > :: iterator_category,
   typename iterator_traits < _RanIt > :: value_type,
   typename iterator_traits < _RanIt > :: difference_type,
   typename iterator_traits < _RanIt > :: pointer,
   typename iterator_traits < _RanIt > :: reference > > _Mybase;

public :
 typedef typename iterator_traits < _RanIt > :: iterator_category iterator_category;
 typedef typename iterator_traits < _RanIt > :: value_type value_type;
 typedef typename iterator_traits < _RanIt > :: difference_type difference_type;
 typedef typename iterator_traits < _RanIt > :: difference_type distance_type;
 typedef typename iterator_traits < _RanIt > :: pointer pointer;
 typedef typename iterator_traits < _RanIt > :: reference reference;
 typedef _RanIt iterator_type;

  reverse_iterator ( )
  {
  }

 explicit reverse_iterator ( _RanIt _Right )
  : _Mybase ( _Right )
  {
  }

 template < class _Other >
   reverse_iterator ( const reverse_iterator < _Other > & _Right )
  : _Mybase ( _Right . base ( ) )
  {
  }

  reverse_iterator ( _Mybase _Right )
  : _Mybase ( _Right )
  {
  }


 typedef typename :: std :: _Checked_iterator_category < _RanIt > :: _Checked_cat _Checked_iterator_category;
 typedef reverse_iterator < typename _Checked_iterator_base_helper < _RanIt > :: _Checked_iterator_base_type > _Checked_iterator_base_type;

 _Checked_iterator_base_type _Checked_iterator_base ( ) const
 {
  typename _Checked_iterator_base_type _Base ( :: std :: _Checked_base ( this -> current ) );
  return _Base;
 }

 void _Checked_iterator_assign_from_base ( _Checked_iterator_base_type _Base )
 {
  :: std :: _Checked_assign_from_base ( this -> current, _Base . base ( ) );
 }


 _Myt & operator ++ ( )
  {
  ++ * ( ( _Mybase * ) this );
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  -- * ( ( _Mybase * ) this );
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myt & operator += ( difference_type _Off )
  {
  * ( ( _Mybase * ) this ) += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  * ( ( _Mybase * ) this ) -= _Off;
  return ( * this );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }
 };
#line 2227 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _RanIt,
 class _Diff > inline
 reverse_iterator < _RanIt > __cdecl operator + ( _Diff _Off,
  const reverse_iterator < _RanIt > & _Right )
 {
 return ( _Right + _Off );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 typename reverse_iterator < _RanIt1 > :: difference_type
  __cdecl operator - ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Minus ( _Right ) );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 bool __cdecl operator == ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 bool __cdecl operator != ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 bool __cdecl operator < ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Less ( _Right ) );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 bool __cdecl operator > ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Right < _Left );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 bool __cdecl operator <= ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }

template < class _RanIt1,
 class _RanIt2 > inline
 bool __cdecl operator >= ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }


template < class _BidIt,
 class _Ty,
 class _Reference = _Ty &,
 class _Pointer = _Ty *,
 class _Diff = ptrdiff_t >
 class reverse_bidirectional_iterator
  : public iterator < bidirectional_iterator_tag, _Ty, _Diff,
   _Pointer, _Reference >
 {
public :
 typedef reverse_bidirectional_iterator < _BidIt, _Ty, _Reference,
  _Pointer, _Diff > _Myt;
 typedef _BidIt iterator_type;

  reverse_bidirectional_iterator ( )
  {
  }

 explicit reverse_bidirectional_iterator ( _BidIt _Right )
  : current ( _Right )
  {
  }

 _BidIt base ( ) const
  {
  return ( current );
  }

 _Reference operator * ( ) const
  {
  _BidIt _Tmp = current;
  return ( * -- _Tmp );
  }

 _Pointer operator -> ( ) const
  {
  _Reference _Tmp = * * this;
  return ( & _Tmp );
  }

 _Myt & operator ++ ( )
  {
  -- current;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  ++ current;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

 bool operator == ( const _Myt & _Right ) const
  {
  return ( current == _Right . current );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

protected :
 _BidIt current;
 };


template < class _BidIt,
 class _BidIt2 = _BidIt >
 class _Revbidit
  : public iterator <
   typename iterator_traits < _BidIt > :: iterator_category,
   typename iterator_traits < _BidIt > :: value_type,
   typename iterator_traits < _BidIt > :: difference_type,
   typename iterator_traits < _BidIt > :: pointer,
   typename iterator_traits < _BidIt > :: reference >
 {
public :
 typedef _Revbidit < _BidIt, _BidIt2 > _Myt;
 typedef typename iterator_traits < _BidIt > :: difference_type _Diff;
 typedef typename iterator_traits < _BidIt > :: pointer _Pointer;
 typedef typename iterator_traits < _BidIt > :: reference _Reference;
 typedef _BidIt iterator_type;

  _Revbidit ( )
  {
  }

 explicit _Revbidit ( _BidIt _Right )
  : current ( _Right )
  {
  }

  _Revbidit ( const _Revbidit < _BidIt2 > & _Other )
  : current ( _Other . base ( ) )
  {
  }

 _BidIt base ( ) const
  {
  return ( current );
  }

 _Reference operator * ( ) const
  {
  _BidIt _Tmp = current;
  return ( * -- _Tmp );
  }

 _Pointer operator -> ( ) const
  {
  _Reference _Tmp = * * this;
  return ( & _Tmp );
  }

 _Myt & operator ++ ( )
  {
  -- current;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  ++ current;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

 bool operator == ( const _Myt & _Right ) const
  {
  return ( current == _Right . current );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

protected :
 _BidIt current;
 };




template < class _InIt, class _OutIt, class _InOutItCat >
inline
 _OutIt __cdecl _Copy_opt ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _InOutItCat, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {
 ;
 for (; _First != _Last; ++ _Dest, ++ _First )
  * _Dest = * _First;
 return ( _Dest );
 }


template < class _InIt, class _OutIt >
inline
 _OutIt __cdecl _Copy_opt ( _InIt _First, _InIt _Last, _OutIt _Dest,
  random_access_iterator_tag, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {

 _OutIt _Result = _Dest + ( _Last - _First );
 _Copy_opt ( _First, _Last, :: std :: _Checked_base ( _Dest ),
  forward_iterator_tag ( ), _Nonscalar_ptr_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 return _Result;
 }
#line 2490 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt, class _OutIt, class _InOutItCat >
inline
 _OutIt __cdecl _Copy_opt ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _InOutItCat, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {







 ptrdiff_t _Off = _Last - _First;

 _OutIt _Result = _Dest + _Off;
 if ( _Off > 0 )
  :: memmove_s ( ( & * _Dest ), ( _Off * sizeof ( * _First ) ), ( & * _First ), ( _Off * sizeof ( * _First ) ) );
 return _Result;
 }
#line 2510 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template<bool _Cond, class _Result_type> struct _Enable_if; 


template<class _Result_type> 
struct _Enable_if< true, _Result_type>  { 

typedef _Result_type _Result; 
}; 

template<class _Checked_iter_cat> 
struct _Is_checked_iterator_helper { 

enum __cuda__Result { _Result}; 
}; 


template<> struct _Is_checked_iterator_helper< _Range_checked_iterator_tag>  { 

enum __cuda__Result { _Result = 1}; 
}; 

template<class _Iter> 
struct _Is_checked_iterator { 

enum __cuda__Result { _Result = _Is_checked_iterator_helper< typename _Checked_iterator_category< _Iter> ::_Checked_cat> ::_Result
}; 
}; 
#line 2558 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt, class _OutIt >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result __cdecl copy ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return ( _Copy_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  _Iter_random ( _First, _Dest ), _Ptr_cat ( _First, _Dest ), _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _OutElem, size_t _Size >
inline
_OutElem * __cdecl copy ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ] )
 {
 return copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( );
 }

template < class _InIt, class _OutIt >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result __cdecl copy ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return ( _Copy_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  _Iter_random ( _First, _Dest ), _Ptr_cat ( _First, _Dest ), _Range_checked_iterator_tag ( ) ) );
 }
#line 2595 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt, class _OutIt, class _InOutItCat, class _MoveCatTy >
inline
 _OutIt __cdecl _Move_opt ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _InOutItCat _First_dest_cat, _MoveCatTy, _Range_checked_iterator_tag )
 {
 return _Copy_opt ( _First, _Last, _Dest,
  _First_dest_cat, _Ptr_cat ( _First, _Dest ), _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutIt, class _InOutItCat >
inline
 _OutIt __cdecl _Move_opt ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _InOutItCat, _Swap_move_tag, _Range_checked_iterator_tag )
 {
 ;
 for (; _First != _Last; ++ _Dest, ++ _First )
  :: std :: _Swap_adl ( * _Dest, * _First );
 return ( _Dest );
 }


template < class _InIt, class _OutIt, class _InOutItCat >
inline
 _OutIt __cdecl _Move_opt ( _InIt _First, _InIt _Last, _OutIt _Dest,
  random_access_iterator_tag, _Swap_move_tag _Move_cat, _Range_checked_iterator_tag )
 {

 _OutIt _Result = _Dest + ( _Last - _First );
 _Move_opt ( _First, _Last, :: std :: _Checked_base ( _Dest ),
  forward_iterator_tag ( ), _Move_cat, _Range_checked_iterator_tag ( ) );
 return _Result;
 }
#line 2631 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt, class _OutIt >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result __cdecl _Move ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return _Move_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  _Iter_random ( _First, _Dest ), _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutElem, size_t _Size >
inline
_OutElem * __cdecl _Move ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ] )
 {
 return _Move ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ),
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( );
 }

template < class _InIt, class _OutIt >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result __cdecl _Move ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return _Move_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  _Iter_random ( _First, _Dest ), _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 2669 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _BidIt1, class _BidIt2, class _InOutItCat >
inline
 _BidIt2 __cdecl _Copy_backward_opt ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
  _InOutItCat, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {
 ;
 while ( _First != _Last )
  * -- _Dest = * -- _Last;
 return ( _Dest );
 }


template < class _InIt, class _OutIt >
inline
 _OutIt __cdecl _Copy_backward_opt ( _InIt _First, _InIt _Last, _OutIt _Dest,
  random_access_iterator_tag, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {

 _OutIt _Result = _Dest - ( _Last - _First );
 _Copy_backward_opt ( _First, _Last, :: std :: _Checked_base ( _Dest ),
  forward_iterator_tag ( ), _Nonscalar_ptr_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 return _Result;
 }
#line 2694 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt, class _OutIt, class _InOutItCat >
inline
 _OutIt __cdecl _Copy_backward_opt ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _InOutItCat, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {







 ptrdiff_t _Off = _Last - _First;



 _OutIt _Result = _Dest - _Off;
 if ( _Off > 0 )
  :: memmove_s ( ( & * _Result ), ( _Off * sizeof ( * _First ) ), ( & * _First ), ( _Off * sizeof ( * _First ) ) );
 return _Result;
 }
#line 2718 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _BidIt1,
 class _BidIt2 > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _BidIt2 > :: _Result, _BidIt2 > :: _Result __cdecl copy_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
 return _Copy_backward_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  _Iter_random ( _First, _Dest ), _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1,
 class _BidIt2 > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _BidIt2 > :: _Result, _BidIt2 > :: _Result __cdecl copy_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
 return _Copy_backward_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  _Iter_random ( _First, _Dest ), _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 2748 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _BidIt1, class _BidIt2, class _InOutItCat, class _MoveCatTy >
inline
 _BidIt2 __cdecl _Move_backward_opt ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
  _InOutItCat _First_dest_cat, _MoveCatTy, _Range_checked_iterator_tag )
 {
 return _Copy_backward_opt ( _First, _Last, _Dest,
  _First_dest_cat, _Ptr_cat ( _First, _Dest ), _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1, class _BidIt2, class _InOutItCat >
inline
 _BidIt2 __cdecl _Move_backward_opt ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
  _InOutItCat, _Swap_move_tag, _Range_checked_iterator_tag )
 {
 ;
 while ( _First != _Last )
  :: std :: _Swap_adl ( * -- _Dest, * -- _Last );
 return ( _Dest );
 }


template < class _BidIt1, class _BidIt2 >
inline
 _BidIt2 __cdecl _Move_backward_opt ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
  random_access_iterator_tag, _Swap_move_tag _Move_cat, _Range_checked_iterator_tag )
 {

 _BidIt2 _Result = _Dest - ( _Last - _First );
 _Move_backward_opt ( _First, _Last, :: std :: _Checked_base ( _Dest ),
  forward_iterator_tag ( ), _Move_cat, _Range_checked_iterator_tag ( ) );
 return _Result;
 }
#line 2784 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _BidIt1, class _BidIt2 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _BidIt2 > :: _Result, _BidIt2 > :: _Result __cdecl _Move_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
 return _Move_backward_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  _Iter_random ( _First, _Dest ), _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1, class _BidIt2 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _BidIt2 > :: _Result, _BidIt2 > :: _Result __cdecl _Move_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
 return _Move_backward_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  _Iter_random ( _First, _Dest ), _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 2814 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2, class _InItCats >
inline
 pair < _InIt1, _InIt2 >
  __cdecl _Mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
   _InItCats, _Range_checked_iterator_tag )
 {







 for (; _First1 != _Last1 && * _First1 == * _First2; )
  ++ _First1, ++ _First2;
 return ( pair < _InIt1, _InIt2 > ( _First1, _First2 ) );
 }
#line 2833 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2 >
inline
 pair < _InIt1, _InIt2 >
  __cdecl _Mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
   random_access_iterator_tag, _Range_checked_iterator_tag )
 {

 _InIt2 _Last2 = _First2 + ( _Last1 - _First1 ); ( _Last2 );
 pair < _InIt1, typename :: std :: _Checked_iterator_base_helper < _InIt2 > :: _Checked_iterator_base_type > _Result =
  _Mismatch ( _First1, _Last1, :: std :: _Checked_base ( _First2 ),
   forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 :: std :: _Checked_assign_from_base ( _First2, _Result . second );
 return ( pair < _InIt1, _InIt2 > ( _Result . first, _First2 ) );
 }
#line 2851 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _InIt2 > :: _Result, :: std :: pair < _InIt1, _InIt2 > > :: _Result
  __cdecl mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {
 pair < typename :: std :: _Checked_iterator_base_helper < _InIt1 > :: _Checked_iterator_base_type, _InIt2 > _Result =
  _Mismatch ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
   _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 :: std :: _Checked_assign_from_base ( _First1, _Result . first );
 return ( pair < _InIt1, _InIt2 > ( _First1, _Result . second ) );
 }

template < class _InIt1, class _InElem2, size_t _Size >
inline
pair < _InIt1, _InElem2 * >
  __cdecl mismatch ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _Size ] )
 {
 pair < _InIt1, :: stdext :: checked_array_iterator < _InElem2 * > > _Result =
  mismatch ( _First1, _Last1, :: stdext :: make_checked_array_iterator ( _First2, _Size ) );
 return ( pair < _InIt1, _InElem2 * > ( _Result . first, _Result . second . base ( ) ) );
 }

template < class _InIt1, class _InIt2 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _InIt2 > :: _Result, :: std :: pair < _InIt1, _InIt2 > > :: _Result
  __cdecl mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {
 pair < typename :: std :: _Checked_iterator_base_helper < _InIt1 > :: _Checked_iterator_base_type, _InIt2 > _Result =
  _Mismatch ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
   _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 :: std :: _Checked_assign_from_base ( _First1, _Result . first );
 return ( pair < _InIt1, _InIt2 > ( _First1, _Result . second ) );
 }
#line 2900 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2, class _Pr, class _InItCats >
inline
 pair < _InIt1, _InIt2 >
  __cdecl _Mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
   _InItCats, _Range_checked_iterator_tag )
 {








 for (; _First1 != _Last1 && _Pred ( * _First1, * _First2 ); )
  ++ _First1, ++ _First2;
 return ( pair < _InIt1, _InIt2 > ( _First1, _First2 ) );
 }
#line 2920 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2, class _Pr >
inline
 pair < _InIt1, _InIt2 >
  __cdecl _Mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
   random_access_iterator_tag, _Range_checked_iterator_tag )
 {

 _InIt2 _Last2 = _First2 + ( _Last1 - _First1 ); ( _Last2 );
 pair < _InIt1, typename :: std :: _Checked_iterator_base_helper < _InIt2 > :: _Checked_iterator_base_type > _Result =
  _Mismatch ( _First1, _Last1, :: std :: _Checked_base ( _First2 ), _Pred,
   forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 :: std :: _Checked_assign_from_base ( _First2, _Result . second );
 return ( pair < _InIt1, _InIt2 > ( _Result . first, _First2 ) );
 }
#line 2938 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2, class _Pr >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _InIt2 > :: _Result, :: std :: pair < _InIt1, _InIt2 > > :: _Result
  __cdecl mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred )
 {
 pair < typename :: std :: _Checked_iterator_base_helper < _InIt1 > :: _Checked_iterator_base_type, _InIt2 > _Result =
  _Mismatch ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Pred,
   _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 :: std :: _Checked_assign_from_base ( _First1, _Result . first );
 return ( pair < _InIt1, _InIt2 > ( _First1, _Result . second ) );
 }

template < class _InIt1, class _InElem2, class _Pr, size_t _Size >
inline
pair < _InIt1, _InElem2 * >
  __cdecl mismatch ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _Size ], _Pr _Pred )
 {
 pair < _InIt1, :: stdext :: checked_array_iterator < _InElem2 * > > _Result =
  mismatch ( _First1, _Last1, :: stdext :: make_checked_array_iterator ( _First2, _Size ), _Pred );
 return ( pair < _InIt1, _InElem2 * > ( _Result . first, _Result . second . base ( ) ) );
 }

template < class _InIt1, class _InIt2, class _Pr >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _InIt2 > :: _Result, :: std :: pair < _InIt1, _InIt2 > > :: _Result
  __cdecl mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred )
 {
 pair < typename :: std :: _Checked_iterator_base_helper < _InIt1 > :: _Checked_iterator_base_type, _InIt2 > _Result =
  _Mismatch ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Pred,
   _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 :: std :: _Checked_assign_from_base ( _First1, _Result . first );
 return ( pair < _InIt1, _InIt2 > ( _First1, _Result . second ) );
 }
#line 2987 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2, class _InItCats >
inline
 bool __cdecl _Equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _InItCats, _Range_checked_iterator_tag )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _First2 )
  if ( ! ( * _First1 == * _First2 ) )
   return ( false );
 return ( true );
 }

inline bool __cdecl _Equal(const char *_First1, const char *
_Last1, const char *_First2, random_access_iterator_tag, _Range_checked_iterator_tag) 

{ 
#line 3008 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
return ::memcmp(_First1, _First2, _Last1 - _First1) == 0; 
} 

inline bool __cdecl _Equal(const signed char *_First1, const signed char *
_Last1, const signed char *_First2, random_access_iterator_tag, _Range_checked_iterator_tag) 

{ 
#line 3021 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
return ::memcmp(_First1, _First2, _Last1 - _First1) == 0; 
} 

inline bool __cdecl _Equal(const unsigned char *_First1, const unsigned char *
_Last1, const unsigned char *_First2, random_access_iterator_tag, _Range_checked_iterator_tag) 

{ 
#line 3034 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
return ::memcmp(_First1, _First2, _Last1 - _First1) == 0; 
} 


template < class _InIt1, class _InIt2 >
inline
 bool __cdecl _Equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {

 _InIt2 _Last2 = _First2 + ( _Last1 - _First1 ); ( _Last2 );
 return _Equal ( _First1, _Last1, :: std :: _Checked_base ( _First2 ),
  forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 }
#line 3052 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _InIt2 > :: _Result, bool > :: _Result __cdecl equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {
 return _Equal ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
  _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InElem2, size_t _Size >
inline
bool __cdecl equal ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _Size ] )
 {
 return equal ( _First1, _Last1,
  :: stdext :: make_checked_array_iterator ( _First2, _Size ) );
 }

template < class _InIt1, class _InIt2 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _InIt2 > :: _Result, bool > :: _Result __cdecl equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {
 return _Equal ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
  _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 3090 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2, class _Pr, class _InItCats >
inline
 bool __cdecl _Equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
  _InItCats, _Range_checked_iterator_tag )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _First2 )
  if ( ! _Pred ( * _First1, * _First2 ) )
   return ( false );
 return ( true );
 }


template < class _InIt1, class _InIt2, class _Pr >
inline
 bool __cdecl _Equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {

 _InIt2 _Last2 = _First2 + ( _Last1 - _First1 ); ( _Last2 );
 return _Equal ( _First1, _Last1, :: std :: _Checked_base ( _First2 ), _Pred,
  forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 }
#line 3116 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2, class _Pr >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _InIt2 > :: _Result, bool > :: _Result __cdecl equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred )
 {
 return _Equal ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Pred,
  _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InElem2, class _Pr, size_t _Size >
inline
bool __cdecl equal ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _Size ], _Pr _Pred )
 {
 return equal ( _First1, _Last1,
  :: stdext :: make_checked_array_iterator ( _First2, _Size ), _Pred );
 }

template < class _InIt1, class _InIt2, class _Pr >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _InIt2 > :: _Result, bool > :: _Result __cdecl equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred )
 {
 return _Equal ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Pred,
  _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 3154 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _FwdIt, class _Ty > inline
 void __cdecl _Fill ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 ;
 for (; _First != _Last; ++ _First )
  * _First = _Val;
 }

inline void __cdecl _Fill(char *_First, char *
_Last, int _Val) 
{ 
; 
::memset(_First, _Val, _Last - _First); 
} 

inline void __cdecl _Fill(signed char *_First, signed char *
_Last, int _Val) 
{ 
; 
::memset(_First, _Val, _Last - _First); 
} 

inline void __cdecl _Fill(unsigned char *
_First, unsigned char *
_Last, int _Val) 
{ 
; 
::memset(_First, _Val, _Last - _First); 
} 

template < class _FwdIt, class _Ty > inline
 void __cdecl fill ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _Fill ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Val );
 }


template < class _OutIt,
 class _Diff,
 class _Ty > inline
 void __cdecl _Fill_n ( _OutIt _First, _Diff _Count, const _Ty & _Val,
  _Range_checked_iterator_tag )
 {
 for (; 0 < _Count; -- _Count, ++ _First )
  * _First = _Val;
 }

inline void __cdecl _Fill_n(char *_First, size_t 
_Count, int _Val, _Range_checked_iterator_tag) 
{ 
#line 3210 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
::memset(_First, _Val, _Count); 
} 

inline void __cdecl _Fill_n(signed char *_First, size_t 
_Count, int _Val, _Range_checked_iterator_tag) 
{ 
#line 3222 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
::memset(_First, _Val, _Count); 
} 

inline void __cdecl _Fill_n(unsigned char *_First, size_t 
_Count, int _Val, _Range_checked_iterator_tag) 
{ 
#line 3234 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
::memset(_First, _Val, _Count); 
} 

template < class _OutIt, class _Diff, class _Ty, class _OutCat >
inline
 void __cdecl _Fill_n ( _OutIt _First, _Diff _Count, const _Ty & _Val,
  _OutCat, _Range_checked_iterator_tag )
 {
  _Fill_n ( _First, _Count, _Val, _Range_checked_iterator_tag ( ) );
 }


template < class _OutIt, class _Diff, class _Ty >
inline
 void __cdecl _Fill_n ( _OutIt _First, _Diff _Count, const _Ty & _Val,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {

  _OutIt _Last = _First + _Count; ( _Last );
  _Fill_n ( :: std :: _Checked_base ( _First ), _Count, _Val,
   _Range_checked_iterator_tag ( ) );
 }
#line 3260 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _OutIt,
 class _Diff,
 class _Ty >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result __cdecl fill_n ( _OutIt _First, _Diff _Count, const _Ty & _Val )
 {
  _Fill_n ( _First, _Count, _Val, _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _OutElem,
 class _Diff,
 class _Ty, size_t _Size >
inline
void __cdecl fill_n ( _OutElem ( & _First ) [ _Size ], _Diff _Count, const _Ty & _Val )
 {
  fill_n ( :: stdext :: make_checked_array_iterator ( _First, _Size ), _Count, _Val );
 }

template < class _OutIt,
 class _Diff,
 class _Ty >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result __cdecl fill_n ( _OutIt _First, _Diff _Count, const _Ty & _Val )
 {
  _Fill_n ( _First, _Count, _Val, _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 3301 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2 > inline
 bool __cdecl _Lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   return ( true );
  else if ( * _First2 < * _First1 )
   return ( false );
 return ( _First1 == _Last1 && _First2 != _Last2 );
 }

template < class _InIt1, class _InIt2 > inline
 bool __cdecl lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 return _Lexicographical_compare ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ) );
 }

inline bool __cdecl lexicographical_compare(const unsigned char *
_First1, const unsigned char *_Last1, const unsigned char *
_First2, const unsigned char *_Last2) 
{ 
; 
; 
auto ptrdiff_t _Num1 = (_Last1 - _First1); 
auto ptrdiff_t _Num2 = (_Last2 - _First2); 
auto int _Ans = ::memcmp(_First1, _First2, (_Num1 < _Num2) ? _Num1 : _Num2); 
return (_Ans < 0) || ((_Ans == 0) && (_Num1 < _Num2)); 
} 
#line 3350 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool __cdecl _Lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 ;
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( _Pred ( * _First1, * _First2 ) )
   return ( true );
  else if ( _Pred ( * _First2, * _First1 ) )
   return ( false );
 return ( _First1 == _Last1 && _First2 != _Last2 );
 }

template < class _InIt1, class _InIt2, class _Pr > inline
 bool __cdecl lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 return _Lexicographical_compare ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Pred );
 }
#line 3381 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _Ty > inline
 const _Ty & ( __cdecl max ) ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ( ( _Left ) < ( _Right ) ) ? _Right : _Left );
 }


template < class _Ty,
 class _Pr > inline
 const _Ty & ( __cdecl max ) ( const _Ty & _Left, const _Ty & _Right, _Pr _Pred )
 {
 return ( _Pred ( _Left, _Right ) ? _Right : _Left );
 }


template < class _Ty > inline
 const _Ty & ( __cdecl min ) ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ( ( _Right ) < ( _Left ) ) ? _Right : _Left );
 }


template < class _Ty,
 class _Pr > inline
 const _Ty & ( __cdecl min ) ( const _Ty & _Left, const _Ty & _Right, _Pr _Pred )
 {
 return ( _Pred ( _Right, _Left ) ? _Right : _Left );
 }

}

namespace stdext { 


template < class _Iterator >
 class checked_array_iterator
  : public :: std :: iterator <
   typename :: std :: iterator_traits < _Iterator > :: iterator_category,
   typename :: std :: iterator_traits < _Iterator > :: value_type,
   typename :: std :: iterator_traits < _Iterator > :: difference_type,
   typename :: std :: iterator_traits < _Iterator > :: pointer,
   typename :: std :: iterator_traits < _Iterator > :: reference >
 {
public :
 typedef checked_array_iterator < _Iterator > _Myt;
 typedef typename :: std :: iterator_traits < _Iterator > :: difference_type difference_type;
 typedef typename :: std :: iterator_traits < _Iterator > :: pointer pointer;
 typedef typename :: std :: iterator_traits < _Iterator > :: reference reference;

 typedef :: std :: _Range_checked_iterator_tag _Checked_iterator_category;
 typedef _Iterator _Inner_type;

 typedef _Iterator _Checked_iterator_base_type;

 _Checked_iterator_base_type _Checked_iterator_base ( ) const
 {
  return _Mycont + _Current;
 }

 void _Checked_iterator_assign_from_base ( _Checked_iterator_base_type _Base )
 {
  _Current = _Base - _Mycont;
 }



 checked_array_iterator ( ) :
  _Size ( 0 ), _Current ( 0 )
 {
 }

 checked_array_iterator ( _Iterator _Cont, size_t _S, size_t _Index = 0 )
 {
  { if ( ! ( _Index <= _S ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  _Mycont = _Cont;
  _Size = _S;
  _Current = _Index;
 }

 _Iterator base ( ) const
 {
  return _Mycont + _Current;
 }

 size_t __Size ( ) const
 {
  return _Size;
 }

 bool operator == ( const _Myt & _Right ) const
 {
  { if ( ! ( _Mycont == _Right . _Mycont ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  return _Current == _Right . _Current;
 }

 bool operator != ( const _Myt & _Right ) const
 {
  return ! ( * this == _Right );
 }

 bool operator < ( const _Myt & _Right ) const
 {
  { if ( ! ( _Mycont == _Right . _Mycont ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  return _Current < _Right . _Current;
 }

 bool operator > ( const _Myt & _Right ) const
 {
  return _Right < * this;
 }

 bool operator <= ( const _Myt & _Right ) const
 {
  return ! ( _Right < * this );
 }

 bool operator >= ( const _Myt & _Right ) const
 {
  return ! ( * this < _Right );
 }

 reference operator * ( ) const
 {
  { if ( ! ( _Current < _Size ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  return * ( _Mycont + _Current );
 }

 pointer operator -> ( ) const
 {
  return ( & * * this );
 }

 checked_array_iterator & operator ++ ( )
 {
  { if ( ! ( _Current < _Size ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  ++ _Current;
  return * this;
 }

 _Myt operator ++ ( int )
 {
  checked_array_iterator _Tmp = * this;
  ++ * this;
  return _Tmp;
 }

 _Myt & operator -- ( )
 {
  { if ( ! ( _Current > 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  -- _Current;
  return * this;
 }

 _Myt operator -- ( int )
 {
  checked_array_iterator _Tmp = * this;
  -- * this;
  return _Tmp;
 }



 _Myt & operator += ( difference_type _Off )
 {
  { if ( ! ( _Current + _Off <= _Size && _Current + _Off >= 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  _Current += _Off;
  return * this;
 }

 _Myt operator + ( difference_type _Off ) const
 {
  checked_array_iterator _Tmp = * this;
  return ( _Tmp += _Off );
 }

 _Myt & operator -= ( difference_type _Off )
 {
  return ( * this += - _Off );
 }

 _Myt operator - ( difference_type _Off ) const
 {
  checked_array_iterator _Tmp = * this;
  return ( _Tmp -= _Off );
 }

 difference_type operator - ( const checked_array_iterator & _Right ) const
 {
  { if ( ! ( _Mycont == _Right . _Mycont ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  return _Current - _Right . _Current;
 }

 reference operator [ ] ( difference_type _Off ) const
 {
  { if ( ! ( _Current + _Off < _Size && _Current + _Off >= 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  return * ( _Mycont + _Current + _Off );
 }

protected :
 void _Xran ( ) const
 {
  throw :: std :: out_of_range ( "invalid checked_array_iterator<T> subscript" );
 }

 void _Xinvarg ( ) const
 {
  throw :: std :: invalid_argument ( "invalid checked_array_iterator<T> argument" );
 }

 _Iterator _Mycont;
 size_t _Current;
 size_t _Size;
 };

template < class _Iter >
checked_array_iterator < _Iter > make_checked_array_iterator ( _Iter _Ptr, size_t _Size )
{
 return checked_array_iterator < _Iter > ( _Ptr, _Size );
}

template < class _InIt,
 class _OutIt > inline
 _OutIt __cdecl unchecked_copy ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
  return ( :: std :: _Copy_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
   :: std :: _Iter_random ( _First, _Dest ), :: std :: _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _OutIt >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result __cdecl checked_copy ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return ( :: std :: _Copy_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _OutElem, size_t _Size >
inline
_OutElem * __cdecl checked_copy ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ] )
 {
 return checked_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( );
 }

template < class _InIt, class _OutIt >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result __cdecl checked_copy ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return ( :: std :: _Copy_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 __cdecl unchecked_copy_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
  return ( :: std :: _Copy_backward_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
   :: std :: _Iter_random ( _First, _Dest ), :: std :: _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _BidIt1,
 class _BidIt2 > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _BidIt2 > :: _Result, _BidIt2 > :: _Result __cdecl checked_copy_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
 return :: std :: _Copy_backward_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1,
 class _BidIt2 > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _BidIt2 > :: _Result, _BidIt2 > :: _Result __cdecl checked_copy_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
 return :: std :: _Copy_backward_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt __cdecl _Unchecked_move ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
  return ( :: std :: _Move_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
   :: std :: _Iter_random ( _First, _Dest ), :: std :: _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _OutIt >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result __cdecl _Checked_move ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return :: std :: _Move_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutElem, size_t _Size >
inline
_OutElem * __cdecl _Checked_move ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ] )
 {
 return _Checked_move ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ),
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( );
 }

template < class _InIt, class _OutIt >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result __cdecl _Checked_move ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return :: std :: _Move_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 __cdecl _Unchecked_move_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
  return ( :: std :: _Move_backward_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
   :: std :: _Iter_random ( _First, _Dest ), :: std :: _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _BidIt1, class _BidIt2 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _BidIt2 > :: _Result, _BidIt2 > :: _Result __cdecl _Checked_move_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
 return :: std :: _Move_backward_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1, class _BidIt2 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _BidIt2 > :: _Result, _BidIt2 > :: _Result __cdecl _Checked_move_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
 return :: std :: _Move_backward_opt ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _OutIt,
 class _Diff,
 class _Ty > inline
 void __cdecl unchecked_fill_n ( _OutIt _First, _Diff _Count, const _Ty & _Val )
 {
  :: std :: _Fill_n ( _First, _Count, _Val, :: std :: _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _OutIt,
 class _Diff,
 class _Ty >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result __cdecl checked_fill_n ( _OutIt _First, _Diff _Count, const _Ty & _Val )
 {
  _Fill_n ( _First, _Count, _Val, :: std :: _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _OutElem,
 class _Diff,
 class _Ty, size_t _Size >
inline
void __cdecl checked_fill_n ( _OutElem ( & _First ) [ _Size ], _Diff _Count, const _Ty & _Val )
 {
  checked_fill_n ( :: stdext :: make_checked_array_iterator ( _First, _Size ), _Count, _Val );
 }

template < class _OutIt,
 class _Diff,
 class _Ty >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result __cdecl checked_fill_n ( _OutIt _First, _Diff _Count, const _Ty & _Val )
 {
  _Fill_n ( _First, _Count, _Val, :: std :: _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2 >
inline
 :: std :: pair < _InIt1, _InIt2 >
  __cdecl unchecked_mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {

 :: std :: pair < typename :: std :: _Checked_iterator_base_helper < _InIt1 > :: _Checked_iterator_base_type, _InIt2 > _Result =
  :: std :: _Mismatch ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
   :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 :: std :: _Checked_assign_from_base ( _First1, _Result . first );
 return ( :: std :: pair < _InIt1, _InIt2 > ( _First1, _Result . second ) );




 }
#line 3769 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _InIt2 > :: _Result, :: std :: pair < _InIt1, _InIt2 > > :: _Result
  __cdecl checked_mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {
 :: std :: pair < typename :: std :: _Checked_iterator_base_helper < _InIt1 > :: _Checked_iterator_base_type, _InIt2 > _Result =
  :: std :: _Mismatch ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
   :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 :: std :: _Checked_assign_from_base ( _First1, _Result . first );
 return ( :: std :: pair < _InIt1, _InIt2 > ( _First1, _Result . second ) );
 }

template < class _InIt1, class _InElem2, size_t _Size >
inline
:: std :: pair < _InIt1, _InElem2 * >
  __cdecl checked_mismatch ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _Size ] )
 {
 :: std :: pair < _InIt1, :: stdext :: checked_array_iterator < _InElem2 * > > _Result =
  checked_mismatch ( _First1, _Last1, :: stdext :: make_checked_array_iterator ( _First2, _Size ) );
 return ( :: std :: pair < _InIt1, _InElem2 * > ( _Result . first, _Result . second . base ( ) ) );
 }

template < class _InIt1, class _InIt2 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _InIt2 > :: _Result, :: std :: pair < _InIt1, _InIt2 > > :: _Result
  __cdecl checked_mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {
 :: std :: pair < typename :: std :: _Checked_iterator_base_helper < _InIt1 > :: _Checked_iterator_base_type, _InIt2 > _Result =
  :: std :: _Mismatch ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
   :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 :: std :: _Checked_assign_from_base ( _First1, _Result . first );
 return ( :: std :: pair < _InIt1, _InIt2 > ( _First1, _Result . second ) );
 }

template < class _InIt1, class _InIt2, class _Pr >
inline
 :: std :: pair < _InIt1, _InIt2 >
  __cdecl unchecked_mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred )
 {

 :: std :: pair < typename :: std :: _Checked_iterator_base_helper < _InIt1 > :: _Checked_iterator_base_type, _InIt2 > _Result =
  :: std :: _Mismatch ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Pred,
   :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 :: std :: _Checked_assign_from_base ( _First1, _Result . first );
 return ( :: std :: pair < _InIt1, _InIt2 > ( _First1, _Result . second ) );




 }
#line 3821 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
template < class _InIt1, class _InIt2, class _Pr >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _InIt2 > :: _Result, :: std :: pair < _InIt1, _InIt2 > > :: _Result
  __cdecl checked_mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred )
 {
 :: std :: pair < typename :: std :: _Checked_iterator_base_helper < _InIt1 > :: _Checked_iterator_base_type, _InIt2 > _Result =
  :: std :: _Mismatch ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Pred,
   :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 :: std :: _Checked_assign_from_base ( _First1, _Result . first );
 return ( :: std :: pair < _InIt1, _InIt2 > ( _First1, _Result . second ) );
 }

template < class _InIt1, class _InElem2, class _Pr, size_t _Size >
inline
:: std :: pair < _InIt1, _InElem2 * >
  __cdecl checked_mismatch ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _Size ], _Pr _Pred )
 {
 :: std :: pair < _InIt1, :: stdext :: checked_array_iterator < _InElem2 * > > _Result =
  checked_mismatch ( _First1, _Last1, :: stdext :: make_checked_array_iterator ( _First2, _Size ), _Pred );
 return ( :: std :: pair < _InIt1, _InElem2 * > ( _Result . first, _Result . second . base ( ) ) );
 }

template < class _InIt1, class _InIt2, class _Pr >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _InIt2 > :: _Result, :: std :: pair < _InIt1, _InIt2 > > :: _Result
  __cdecl checked_mismatch ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred )
 {
 :: std :: pair < typename :: std :: _Checked_iterator_base_helper < _InIt1 > :: _Checked_iterator_base_type, _InIt2 > _Result =
  :: std :: _Mismatch ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Pred,
   :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 :: std :: _Checked_assign_from_base ( _First1, _Result . first );
 return ( :: std :: pair < _InIt1, _InIt2 > ( _First1, _Result . second ) );
 }

template < class _InIt1, class _InIt2 >
inline
 bool __cdecl unchecked_equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {
 return :: std :: _Equal ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
  :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _InIt2 > :: _Result, bool > :: _Result __cdecl checked_equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {
 return :: std :: _Equal ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
  :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InElem2, size_t _Size >
inline
bool __cdecl checked_equal ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _Size ] )
 {
 return checked_equal ( _First1, _Last1,
  :: stdext :: make_checked_array_iterator ( _First2, _Size ) );
 }

template < class _InIt1, class _InIt2 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _InIt2 > :: _Result, bool > :: _Result __cdecl checked_equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {
 return :: std :: _Equal ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
  :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _Pr >
inline
 bool __cdecl unchecked_equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred )
 {
 return :: std :: _Equal ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Pred,
  :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _Pr >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _InIt2 > :: _Result, bool > :: _Result __cdecl checked_equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred )
 {
 return :: std :: _Equal ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Pred,
  :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InElem2, class _Pr, size_t _Size >
inline
bool __cdecl checked_equal ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _Size ], _Pr _Pred )
 {
 return checked_equal ( _First1, _Last1,
  :: stdext :: make_checked_array_iterator ( _First2, _Size ), _Pred );
 }

template < class _InIt1, class _InIt2, class _Pr >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _InIt2 > :: _Result, bool > :: _Result __cdecl checked_equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred )
 {
 return :: std :: _Equal ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Pred,
  :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }

}
#line 3977 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
extern "C" void __cdecl _invalid_parameter_noinfo(); 
#line 3983 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
#pragma warning(pop)
#line 13 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xmemory"
#pragma warning(push,3)
#pragma warning(disable: 4100)
#line 3984 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xutility"
#pragma pack ( pop )
#line 12 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xmemory"
#pragma pack ( push, 8 )
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xmemory"
namespace std { 

template < class _Ty > inline
 _Ty * _Allocate ( size_t _Count, _Ty * )
 {
 if ( _Count <= 0 )
  _Count = 0;
 else if ( ( ( size_t ) ( - 1 ) / _Count ) < sizeof ( _Ty ) )
  throw std :: bad_alloc ( 0 );


 return ( ( _Ty * ) :: operator new ( _Count * sizeof ( _Ty ) ) );
 }


template < class _T1,
 class _T2 > inline
 void _Construct ( _T1 * _Ptr, const _T2 & _Val )
 {
 void * _Vptr = _Ptr;
 :: new ( _Vptr ) _T1 ( _Val );
 }


template < class _Ty > inline
 void _Destroy ( _Ty * _Ptr )
 {
 ( _Ptr ) -> ~ _Ty ( );
 }


template<> inline void _Destroy(char *) 
{ 
} 


template<> inline void _Destroy(__wchar_t *) 
{ 
} 



template<class _Ty> 
struct _Allocator_base { 

typedef _Ty value_type; 
}; 


template<class _Ty> 
struct _Allocator_base< const _Ty>  { 

typedef _Ty value_type; 
}; 


template < class _Ty >
 class allocator
  : public _Allocator_base < _Ty >
 {
public :
 typedef _Allocator_base < _Ty > _Mybase;
 typedef typename _Mybase :: value_type value_type;
 typedef value_type * pointer;
 typedef value_type & reference;
 typedef const value_type * const_pointer;
 typedef const value_type & const_reference;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 template < class _Other >
  struct rebind
  {
  typedef allocator < _Other > other;
  };

 pointer address ( reference _Val ) const
  {
  return ( & _Val );
  }

 const_pointer address ( const_reference _Val ) const
  {
  return ( & _Val );
  }

 allocator ( ) throw ( )
  {
  }

 allocator ( const allocator < _Ty > & ) throw ( )
  {
  }

 template < class _Other >
  allocator ( const allocator < _Other > & ) throw ( )
  {
  }

 template < class _Other >
  allocator < _Ty > & operator = ( const allocator < _Other > & )
  {
  return ( * this );
  }

 void deallocate ( pointer _Ptr, size_type )
  {
  :: operator delete ( _Ptr );
  }

 pointer allocate ( size_type _Count )
  {
  return ( _Allocate ( _Count, ( pointer ) 0 ) );
  }

 pointer allocate ( size_type _Count, const void * )
  {
  return ( allocate ( _Count ) );
  }

 void construct ( pointer _Ptr, const _Ty & _Val )
  {
  _Construct ( _Ptr, _Val );
  }

 void destroy ( pointer _Ptr )
  {
  _Destroy ( _Ptr );
  }

 size_t max_size ( ) const throw ( )
  {
  size_t _Count = ( size_t ) ( - 1 ) / sizeof ( _Ty );
  return ( 0 < _Count ? _Count : 1 );
  }
 };


template < class _Ty,
 class _Other > inline
 bool operator == ( const allocator < _Ty > &, const allocator < _Other > & ) throw ( )
 {
 return ( true );
 }

template < class _Ty,
 class _Other > inline
 bool operator != ( const allocator < _Ty > &, const allocator < _Other > & ) throw ( )
 {
 return ( false );
 }


template<> class allocator< void>  { 


public: typedef void _Ty; 
typedef _Ty *pointer; 
typedef const _Ty *const_pointer; 
typedef _Ty value_type; 

template<class _Other> 
struct rebind { 

typedef std::allocator< _Other>  other; 
}; 

allocator() throw() 
{ 
} 

allocator(const std::allocator< void>  &) throw() 
{ 
} 

template < class _Other >
  allocator ( const allocator < _Other > & ) throw ( )
  {
  }

template < class _Other >
  allocator < _Ty > & operator = ( const allocator < _Other > & )
  {
  return ( * this );
  }
}; 


template < class _Alloc > inline
 void _Destroy_range ( typename _Alloc :: pointer _First,
  typename _Alloc :: pointer _Last, _Alloc & _Al )
 {
 _Destroy_range ( _First, _Last, _Al, _Ptr_cat ( _First, _Last ) );
 }

template < class _Alloc > inline
 void _Destroy_range ( typename _Alloc :: pointer _First,
  typename _Alloc :: pointer _Last, _Alloc & _Al,
  _Nonscalar_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  _Al . destroy ( _First );
 }

template < class _Alloc > inline
 void _Destroy_range ( typename _Alloc :: pointer _First,
  typename _Alloc :: pointer _Last, _Alloc & _Al,
  _Scalar_ptr_iterator_tag )
 {
 }
}


#pragma warning(default: 4100)
#pragma warning(pop)
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstring"
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 248 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xmemory"
#pragma pack ( pop )
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstring"
#pragma pack ( push, 8 )
#line 17 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstring"
namespace std { 

#pragma warning(disable:4251)

template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Ax = allocator < _Elem > >
 class basic_string;


template < class _Elem,
 class _Traits,
 class _Alloc >
 class _String_const_iterator
  : public _Ranit_base < _Elem, typename _Alloc :: difference_type,
   typename _Alloc :: const_pointer, typename _Alloc :: const_reference, _Iterator_base_secure >
 {
public :
 typedef _String_const_iterator < _Elem, _Traits, _Alloc > _Myt;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystring;

 typedef random_access_iterator_tag iterator_category;
 typedef _Elem value_type;
 typedef typename _Alloc :: difference_type difference_type;
 typedef typename _Alloc :: const_pointer pointer;
 typedef typename _Alloc :: const_reference reference;
 typedef _Elem * _Inner_type;


 typedef _Range_checked_iterator_tag _Checked_iterator_category;



 typedef pointer _Checked_iterator_base_type;

 _Checked_iterator_base_type _Checked_iterator_base ( ) const
 {
  return _Myptr;
 }

 void _Checked_iterator_assign_from_base ( _Checked_iterator_base_type _Base )
 {
  this -> _Myptr = _Base;
 }


  _String_const_iterator ( )
  {
  _Myptr = 0;
  }
















   _String_const_iterator ( pointer _Ptr, const _Container_base_secure * _Pstring )
   {
   { if ( ! ( _Pstring != 0 && _Ptr != 0 && ( ( _Mystring * ) _Pstring ) -> _Myptr ( ) <= _Ptr && _Ptr <= ( ( ( _Mystring * ) _Pstring ) -> _Myptr ( ) + ( ( _Mystring * ) _Pstring ) -> _Mysize ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };

   this -> _Mycont = _Pstring;
   _Myptr = _Ptr;
   }











 reference operator * ( ) const
  {












  if ( this -> _Mycont != ( ( const _Container_base_secure * ) - 4 ) )
  {
   { if ( ! ( this -> _Has_container ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
   { if ( ! ( _Myptr < ( ( ( _Mystring * ) this -> _Mycont ) -> _Myptr ( ) + ( ( _Mystring * ) ( this -> _Mycont ) ) -> _Mysize ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  }


  return ( * _Myptr );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myt & operator ++ ( )
  {
  if ( this -> _Mycont != ( ( const _Container_base_secure * ) - 4 ) )
  {
   { if ( ! ( this -> _Has_container ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
   { if ( ! ( _Myptr < ( ( ( _Mystring * ) this -> _Mycont ) -> _Myptr ( ) + ( ( _Mystring * ) this -> _Mycont ) -> _Mysize ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  }
  ++ _Myptr;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  if ( this -> _Mycont != ( ( const _Container_base_secure * ) - 4 ) )
  {
   { if ( ! ( this -> _Has_container ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
   { if ( ! ( _Myptr > ( ( _Mystring * ) this -> _Mycont ) -> _Myptr ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  }
  -- _Myptr;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myt & operator += ( difference_type _Off )
  {
  if ( this -> _Mycont != ( ( const _Container_base_secure * ) - 4 ) )
  {
   { if ( ! ( this -> _Has_container ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
   { if ( ! ( _Myptr + _Off <= ( ( ( _Mystring * ) this -> _Mycont ) -> _Myptr ( ) + ( ( _Mystring * ) this -> _Mycont ) -> _Mysize ) && _Myptr + _Off >= ( ( _Mystring * ) this -> _Mycont ) -> _Myptr ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };

  }
  _Myptr += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myt & _Right ) const
  {




  if ( this -> _Mycont != ( ( const _Container_base_secure * ) - 4 ) )
  {
   { if ( ! ( this -> _Has_container ( ) && this -> _Same_container ( _Right ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  }


  return ( _Myptr - _Right . _Myptr );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myt & _Right ) const
  {




  if ( this -> _Mycont != ( ( const _Container_base_secure * ) - 4 ) )
  {
   { if ( ! ( this -> _Has_container ( ) && this -> _Same_container ( _Right ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  }


  return ( _Myptr == _Right . _Myptr );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myt & _Right ) const
  {




  if ( this -> _Mycont != ( ( const _Container_base_secure * ) - 4 ) )
  {
   { if ( ! ( this -> _Has_container ( ) && this -> _Same_container ( _Right ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  }


  return ( _Myptr < _Right . _Myptr );
  }

 bool operator > ( const _Myt & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myt & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myt & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }












 static void __cdecl _Xlen ( )
  {
  _Mystring :: _Xlen ( );
  }

 static void __cdecl _Xran ( )
  {
  _Mystring :: _Xran ( );
  }

 static void __cdecl _Xinvarg ( )
  {
  _Mystring :: _Xinvarg ( );
  }

 pointer _Myptr;
 };
#line 297 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstring"
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 _String_const_iterator < _Elem, _Traits, _Alloc > __cdecl operator + (
  typename _String_const_iterator < _Elem, _Traits, _Alloc >
   :: difference_type _Off,
  _String_const_iterator < _Elem, _Traits, _Alloc > _Next )
 {
 return ( _Next += _Off );
 }


template < class _Elem,
 class _Traits,
 class _Alloc >
 class _String_iterator
  : public _String_const_iterator < _Elem, _Traits, _Alloc >
 {
public :
 typedef _String_iterator < _Elem, _Traits, _Alloc > _Myt;
 typedef _String_const_iterator < _Elem, _Traits, _Alloc > _Mybase;

 typedef random_access_iterator_tag iterator_category;
 typedef _Elem value_type;
 typedef typename _Alloc :: difference_type difference_type;
 typedef typename _Alloc :: pointer pointer;
 typedef typename _Alloc :: reference reference;

  _String_iterator ( )
  {
  }











   _String_iterator ( pointer _Ptr, const _Container_base_secure * _Pstring )
   : _Mybase ( _Ptr, _Pstring )
   {
   }











 typedef pointer _Checked_iterator_base_type;

 _Checked_iterator_base_type _Checked_iterator_base ( ) const
 {
  return const_cast < pointer > ( this -> _Myptr );
 }

 void _Checked_iterator_assign_from_base ( _Checked_iterator_base_type _Base )
 {
  this -> _Myptr = _Base;
 }


 reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myt & operator ++ ( )
  {
  ++ ( * ( _Mybase * ) this );
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  -- ( * ( _Mybase * ) this );
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myt & operator += ( difference_type _Off )
  {
  ( * ( _Mybase * ) this ) += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( ( _Mybase ) * this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 437 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstring"
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 _String_iterator < _Elem, _Traits, _Alloc > operator + (
  typename _String_iterator < _Elem, _Traits, _Alloc >
   :: difference_type _Off,
  _String_iterator < _Elem, _Traits, _Alloc > _Next )
 {
 return ( _Next += _Off );
 }


class _String_base : public _Container_base_secure { 



public: static void __cdecl _Xlen(); 

static void __cdecl _Xran(); 

static void __cdecl _Xinvarg(); 
}; 


template < class _Ty,
 class _Alloc >
 class _String_val
  : public _String_base
 {
protected :
 typedef typename _Alloc :: template
  rebind < _Ty > :: other _Alty;

  _String_val ( _Alty _Al = _Alty ( ) )
  : _Alval ( _Al )
  {
  }

public :
  _String_val ( const _String_val & _Right )
  : _Alval ( _Right . _Alval )
  {






  }

protected :
 _Alty _Alval;
 };
#line 492 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstring"
template < class _Elem,
 class _Traits,
 class _Ax >
 class basic_string
  : public _String_val < _Elem, _Ax >
 {
public :
 typedef basic_string < _Elem, _Traits, _Ax > _Myt;
 typedef _String_val < _Elem, _Ax > _Mybase;
 typedef typename _Mybase :: _Alty _Alloc;
 typedef typename _Alloc :: size_type size_type;
 typedef typename _Alloc :: difference_type _Dift;
 typedef _Dift difference_type;
 typedef typename _Alloc :: pointer _Tptr;
 typedef typename _Alloc :: const_pointer _Ctptr;
 typedef _Tptr pointer;
 typedef _Ctptr const_pointer;
 typedef typename _Alloc :: reference _Reft;
 typedef _Reft reference;
 typedef typename _Alloc :: const_reference const_reference;
 typedef typename _Alloc :: value_type value_type;



 typedef _String_iterator < _Elem, _Traits, _Alloc > iterator;
 typedef _String_const_iterator < _Elem, _Traits, _Alloc > const_iterator;


 friend class _String_const_iterator < _Elem, _Traits, _Alloc >;

 typedef std :: reverse_iterator < iterator > reverse_iterator;
 typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;







































  basic_string ( )
  : _Mybase ( )
  {
  _Tidy ( );
  }

































 explicit basic_string ( const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  }

  basic_string ( const _Myt & _Right, size_type _Roff,
  size_type _Count = npos )
  : _Mybase ( )
  {






  _Tidy ( );
  assign ( _Right, _Roff, _Count );
  }

  basic_string ( const _Myt & _Right, size_type _Roff, size_type _Count,
  const _Alloc & _Al )
  : _Mybase ( _Al )
  {






  _Tidy ( );
  assign ( _Right, _Roff, _Count );
  }

  basic_string ( const _Elem * _Ptr, size_type _Count )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Ptr, _Count );
  }

  basic_string ( const _Elem * _Ptr, size_type _Count, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Ptr, _Count );
  }

  basic_string ( const _Elem * _Ptr )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Ptr );
  }

  basic_string ( const _Elem * _Ptr, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Ptr );
  }

  basic_string ( size_type _Count, _Elem _Ch )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Count, _Ch );
  }

  basic_string ( size_type _Count, _Elem _Ch, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Count, _Ch );
  }

 template < class _It >
   basic_string ( _It _First, _It _Last )
  : _Mybase ( )
  {
  _Tidy ( );
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _It >
   basic_string ( _It _First, _It _Last, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

  basic_string ( const_pointer _First, const_pointer _Last )
  : _Mybase ( )
  {



  _Tidy ( );
  if ( _First != _Last )
   assign ( & * _First, _Last - _First );
  }

  basic_string ( const_iterator _First, const_iterator _Last )
  : _Mybase ( )
  {



  _Tidy ( );
  if ( _First != _Last )
   assign ( & * _First, _Last - _First );
  }





  basic_string ( const _Myt & _Right )
  : _Mybase ( _Right )
  {
  _Tidy ( );
  assign ( _Right, 0, npos );
  }







































































































































 template < class _It >
  void _Construct ( _It _Count,
   _It _Ch, _Int_iterator_tag )
  {
  assign ( ( size_type ) _Count, ( _Elem ) _Ch );
  }

 template < class _It >
  void _Construct ( _It _First,
   _It _Last, input_iterator_tag )
  {
  try {
  for (; _First != _Last; ++ _First )
   append ( ( size_type ) 1, ( _Elem ) * _First );
  } catch ( ... ) {
  _Tidy ( true );
  throw;
  }
  }

 template < class _It >
  void _Construct ( _It _First,
   _It _Last, forward_iterator_tag )
  {







  size_type _Count = 0;
  _Distance ( _First, _Last, _Count );
  reserve ( _Count );

  try {
  for (; _First != _Last; ++ _First )
   append ( ( size_type ) 1, ( _Elem ) * _First );
  } catch ( ... ) {
  _Tidy ( true );
  throw;
  }
  }

  ~ basic_string ( )
  {
  _Tidy ( true );
  }

 typedef _Traits traits_type;
 typedef _Alloc allocator_type;

  static const size_type npos;

 _Myt & operator = ( const _Myt & _Right )
  {
  return ( assign ( _Right ) );
  }

 _Myt & operator = ( const _Elem * _Ptr )
  {
  return ( assign ( _Ptr ) );
  }

 _Myt & operator = ( _Elem _Ch )
  {
  return ( assign ( 1, _Ch ) );
  }

 _Myt & operator += ( const _Myt & _Right )
  {
  return ( append ( _Right ) );
  }

 _Myt & operator += ( const _Elem * _Ptr )
  {
  return ( append ( _Ptr ) );
  }

 _Myt & operator += ( _Elem _Ch )
  {
  return ( append ( ( size_type ) 1, _Ch ) );
  }

 _Myt & append ( const _Myt & _Right )
  {
  return ( append ( _Right, 0, npos ) );
  }

 _Myt & append ( const _Myt & _Right,
  size_type _Roff, size_type _Count )
  {
  if ( _Right . size ( ) < _Roff )
   _String_base :: _Xran ( );
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Num < _Count )
   _Count = _Num;
  if ( npos - _Mysize <= _Count || _Mysize + _Count < _Mysize )
   _String_base :: _Xlen ( );

  if ( 0 < _Count && _Grow ( _Num = _Mysize + _Count ) )
   {
   _Traits_helper :: copy_s < _Traits > ( _Myptr ( ) + _Mysize, _Myres - _Mysize,
    _Right . _Myptr ( ) + _Roff, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & append ( const _Elem * _Ptr, size_type _Count )
  {






  if ( _Inside ( _Ptr ) )
   return ( append ( * this, _Ptr - _Myptr ( ), _Count ) );
  if ( npos - _Mysize <= _Count || _Mysize + _Count < _Mysize )
   _String_base :: _Xlen ( );

  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = _Mysize + _Count ) )
   {
   _Traits_helper :: copy_s < _Traits > ( _Myptr ( ) + _Mysize, _Myres - _Mysize, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & append ( const _Elem * _Ptr )
  {
  ;
  return ( append ( _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & append ( size_type _Count, _Elem _Ch )
  {
   if ( npos - _Mysize <= _Count )
   _String_base :: _Xlen ( );

  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = _Mysize + _Count ) )
   {
   _Chassign ( _Mysize, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

 template < class _It >
  _Myt & append ( _It _First, _It _Last )
  {
  return ( _Append ( _First, _Last, _Iter_cat ( _First ) ) );
  }

 template < class _It >
  _Myt & _Append ( _It _Count, _It _Ch, _Int_iterator_tag )
  {
  return ( append ( ( size_type ) _Count, ( _Elem ) _Ch ) );
  }

 template < class _It >
  _Myt & _Append ( _It _First, _It _Last, input_iterator_tag )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 _Myt & append ( const_pointer _First, const_pointer _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 _Myt & append ( const_iterator _First, const_iterator _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 _Myt & assign ( const _Myt & _Right )
  {
  return ( assign ( _Right, 0, npos ) );
  }

 _Myt & assign ( const _Myt & _Right,
  size_type _Roff, size_type _Count )
  {
  if ( _Right . size ( ) < _Roff )
   _String_base :: _Xran ( );
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Count < _Num )
   _Num = _Count;

  if ( this == & _Right )
   erase ( ( size_type ) ( _Roff + _Num ) ), erase ( 0, _Roff );
  else if ( _Grow ( _Num ) )
   {
   _Traits_helper :: copy_s < _Traits > ( _Myptr ( ), _Myres, _Right . _Myptr ( ) + _Roff, _Num );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & assign ( const _Elem * _Ptr, size_type _Count )
  {






  if ( _Inside ( _Ptr ) )
   return ( assign ( * this, _Ptr - _Myptr ( ), _Count ) );

  if ( _Grow ( _Count ) )
   {
   _Traits_helper :: copy_s < _Traits > ( _Myptr ( ), _Myres, _Ptr, _Count );
   _Eos ( _Count );
   }
  return ( * this );
  }

 _Myt & assign ( const _Elem * _Ptr )
  {
  ;
  return ( assign ( _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & assign ( size_type _Count, _Elem _Ch )
  {
  if ( _Count == npos )
   _String_base :: _Xlen ( );

  if ( _Grow ( _Count ) )
   {
   _Chassign ( 0, _Count, _Ch );
   _Eos ( _Count );
   }
  return ( * this );
  }

 template < class _It >
  _Myt & assign ( _It _First, _It _Last )
  {
  return ( _Assign ( _First, _Last, _Iter_cat ( _First ) ) );
  }

 template < class _It >
  _Myt & _Assign ( _It _Count, _It _Ch, _Int_iterator_tag )
  {
  return ( assign ( ( size_type ) _Count, ( _Elem ) _Ch ) );
  }

 template < class _It >
  _Myt & _Assign ( _It _First, _It _Last, input_iterator_tag )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 _Myt & assign ( const_pointer _First, const_pointer _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 _Myt & assign ( const_iterator _First, const_iterator _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 _Myt & insert ( size_type _Off, const _Myt & _Right )
  {
  return ( insert ( _Off, _Right, 0, npos ) );
  }

 _Myt & insert ( size_type _Off,
  const _Myt & _Right, size_type _Roff, size_type _Count )
  {
  if ( _Mysize < _Off || _Right . size ( ) < _Roff )
   _String_base :: _Xran ( );
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Num < _Count )
   _Count = _Num;
  if ( npos - _Mysize <= _Count )
   _String_base :: _Xlen ( );

  if ( 0 < _Count && _Grow ( _Num = _Mysize + _Count ) )
   {
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _Count, _Myres - _Off - _Count,
    _Myptr ( ) + _Off, _Mysize - _Off );
   if ( this == & _Right )
    _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off, _Myres - _Off,
     _Myptr ( ) + ( _Off < _Roff ? _Roff + _Count : _Roff ),
      _Count );
   else
    _Traits_helper :: copy_s < _Traits > ( _Myptr ( ) + _Off, _Myres - _Off,
     _Right . _Myptr ( ) + _Roff, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & insert ( size_type _Off,
  const _Elem * _Ptr, size_type _Count )
  {






  if ( _Inside ( _Ptr ) )
   return ( insert ( _Off, * this,
    _Ptr - _Myptr ( ), _Count ) );
  if ( _Mysize < _Off )
   _String_base :: _Xran ( );
  if ( npos - _Mysize <= _Count )
   _String_base :: _Xlen ( );
  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = _Mysize + _Count ) )
   {
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _Count, _Myres - _Off - _Count,
    _Myptr ( ) + _Off, _Mysize - _Off );
   _Traits_helper :: copy_s < _Traits > ( _Myptr ( ) + _Off, _Myres - _Off, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & insert ( size_type _Off, const _Elem * _Ptr )
  {
  ;
  return ( insert ( _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & insert ( size_type _Off,
  size_type _Count, _Elem _Ch )
  {
  if ( _Mysize < _Off )
   _String_base :: _Xran ( );
  if ( npos - _Mysize <= _Count )
   _String_base :: _Xlen ( );
  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = _Mysize + _Count ) )
   {
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _Count, _Myres - _Off - _Count,
    _Myptr ( ) + _Off, _Mysize - _Off );
   _Chassign ( _Off, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

 iterator insert ( const_iterator _Where )
  {
  return ( insert ( _Where, _Elem ( ) ) );
  }

 iterator insert ( const_iterator _Where, _Elem _Ch )
  {
  size_type _Off = _Pdif ( _Where, begin ( ) );
  insert ( _Off, 1, _Ch );
  return ( begin ( ) + _Off );
  }

 void insert ( const_iterator _Where, size_type _Count, _Elem _Ch )
  {
  size_type _Off = _Pdif ( _Where, begin ( ) );
  insert ( _Off, _Count, _Ch );
  }

 template < class _It >
  void insert ( const_iterator _Where, _It _First, _It _Last )
  {
  _Insert ( _Where, _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _It >
  void _Insert ( const_iterator _Where, _It _Count, _It _Ch,
   _Int_iterator_tag )
  {
  insert ( _Where, ( size_type ) _Count, ( _Elem ) _Ch );
  }

 template < class _It >
  void _Insert ( const_iterator _Where, _It _First, _It _Last,
   input_iterator_tag )
  {
  replace ( _Where, _Where, _First, _Last );
  }

 void insert ( const_iterator _Where, const_pointer _First, const_pointer _Last )
  {
  replace ( _Where, _Where, _First, _Last );
  }

 void insert ( const_iterator _Where, const_iterator _First, const_iterator _Last )
  {
  replace ( _Where, _Where, _First, _Last );
  }

 _Myt & erase ( size_type _Off = 0,
  size_type _Count = npos )
  {
  if ( _Mysize < _Off )
   _String_base :: _Xran ( );
  if ( _Mysize - _Off < _Count )
   _Count = _Mysize - _Off;
  if ( 0 < _Count )
   {
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off, _Myres - _Off, _Myptr ( ) + _Off + _Count,
    _Mysize - _Off - _Count );
   size_type _Newsize = _Mysize - _Count;
   _Eos ( _Newsize );
   }
  return ( * this );
  }

 iterator erase ( const_iterator _Where )
  {
  size_type _Count = _Pdif ( _Where, begin ( ) );
  erase ( _Count, 1 );
  return ( iterator ( _Myptr ( ) + _Count, this ) );
  }

 iterator erase ( const_iterator _First, const_iterator _Last )
  {
  size_type _Count = _Pdif ( _First, begin ( ) );
  erase ( _Count, _Pdif ( _Last, _First ) );
  return ( iterator ( _Myptr ( ) + _Count, this ) );
  }

 void clear ( )
  {
  erase ( begin ( ), end ( ) );
  }

 _Myt & replace ( size_type _Off, size_type _N0, const _Myt & _Right )
  {
  return ( replace ( _Off, _N0, _Right, 0, npos ) );
  }

 _Myt & replace ( size_type _Off,
  size_type _N0, const _Myt & _Right, size_type _Roff, size_type _Count )
  {
  if ( _Mysize < _Off || _Right . size ( ) < _Roff )
   _String_base :: _Xran ( );
  if ( _Mysize - _Off < _N0 )
   _N0 = _Mysize - _Off;
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Num < _Count )
   _Count = _Num;
  if ( npos - _Count <= _Mysize - _N0 )
   _String_base :: _Xlen ( );

  size_type _Nm = _Mysize - _N0 - _Off;
  size_type _Newsize = _Mysize + _Count - _N0;
  if ( _Mysize < _Newsize )
   _Grow ( _Newsize );

  if ( this != & _Right )
   {
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _Count, _Myres - _Off - _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   _Traits_helper :: copy_s < _Traits > ( _Myptr ( ) + _Off, _Myres - _Off,
    _Right . _Myptr ( ) + _Roff, _Count );
   }
  else if ( _Count <= _N0 )
   {
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off, _Myres - _Off,
    _Myptr ( ) + _Roff, _Count );
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _Count, _Myres - _Off - _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   }
  else if ( _Roff <= _Off )
   {
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _Count, _Myres - _Off - _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off, _Myres - _Off,
    _Myptr ( ) + _Roff, _Count );
   }
  else if ( _Off + _N0 <= _Roff )
   {
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _Count, _Myres - _Off - _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off, _Myres - _Off,
    _Myptr ( ) + ( _Roff + _Count - _N0 ), _Count );
   }
  else
   {
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off, _Myres - _Off,
    _Myptr ( ) + _Roff, _N0 );
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _Count, _Myres - _Off - _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _N0, _Myres - _Off - _N0, _Myptr ( ) + _Roff + _Count,
    _Count - _N0 );
   }

  _Eos ( _Newsize );
  return ( * this );
  }

 _Myt & replace ( size_type _Off,
  size_type _N0, const _Elem * _Ptr, size_type _Count )
  {






  if ( _Inside ( _Ptr ) )
   return ( replace ( _Off, _N0, * this,
    _Ptr - _Myptr ( ), _Count ) );
  if ( _Mysize < _Off )
   _String_base :: _Xran ( );
  if ( _Mysize - _Off < _N0 )
   _N0 = _Mysize - _Off;
  if ( npos - _Count <= _Mysize - _N0 )
   _String_base :: _Xlen ( );
  size_type _Nm = _Mysize - _N0 - _Off;

  if ( _Count < _N0 )
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _Count, _Myres - _Off - _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
  size_type _Num;
  if ( ( 0 < _Count || 0 < _N0 ) && _Grow ( _Num = _Mysize + _Count - _N0 ) )
   {
   if ( _N0 < _Count )
    _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _Count, _Myres - _Off - _Count,
     _Myptr ( ) + _Off + _N0, _Nm );
   _Traits_helper :: copy_s < _Traits > ( _Myptr ( ) + _Off, _Myres - _Off, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & replace ( size_type _Off, size_type _N0, const _Elem * _Ptr )
  {
  ;
  return ( replace ( _Off, _N0, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & replace ( size_type _Off,
  size_type _N0, size_type _Count, _Elem _Ch )
  {
  if ( _Mysize < _Off )
   _String_base :: _Xran ( );
  if ( _Mysize - _Off < _N0 )
   _N0 = _Mysize - _Off;
  if ( npos - _Count <= _Mysize - _N0 )
   _String_base :: _Xlen ( );
  size_type _Nm = _Mysize - _N0 - _Off;

  if ( _Count < _N0 )
   _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _Count, _Myres - _Off - _Count,
    _Myptr ( ) + _Off + _N0, _Nm );
  size_type _Num;
  if ( ( 0 < _Count || 0 < _N0 ) && _Grow ( _Num = _Mysize + _Count - _N0 ) )
   {
   if ( _N0 < _Count )
    _Traits_helper :: move_s < _Traits > ( _Myptr ( ) + _Off + _Count, _Myres - _Off - _Count,
     _Myptr ( ) + _Off + _N0, _Nm );
   _Chassign ( _Off, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last, const _Myt & _Right )
  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Right ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last, const _Elem * _Ptr,
  size_type _Count )
  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Ptr, _Count ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last, const _Elem * _Ptr )
  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Ptr ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  size_type _Count, _Elem _Ch )
  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Count, _Ch ) );
  }

 template < class _It >
  _Myt & replace ( const_iterator _First, const_iterator _Last,
   _It _First2, _It _Last2 )
  {
  return ( _Replace ( _First, _Last,
   _First2, _Last2, _Iter_cat ( _First2 ) ) );
  }

 template < class _It >
  _Myt & _Replace ( const_iterator _First, const_iterator _Last,
   _It _Count, _It _Ch, _Int_iterator_tag )
  {
  return ( replace ( _First, _Last, ( size_type ) _Count, ( _Elem ) _Ch ) );
  }

 template < class _It >
  _Myt & _Replace ( const_iterator _First, const_iterator _Last,
   _It _First2, _It _Last2, input_iterator_tag )
  {
  _Myt _Right ( _First2, _Last2 );
  replace ( _First, _Last, _Right );
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const_pointer _First2, const_pointer _Last2 )
  {
  if ( _First2 == _Last2 )
   erase ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ) );
  else
   replace ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ),
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const_iterator _First2, const_iterator _Last2 )
  {
  if ( _First2 == _Last2 )
   erase ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ) );
  else
   replace ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ),
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

 iterator begin ( )
  {
  return ( iterator ( _Myptr ( ), this ) );
  }

 const_iterator begin ( ) const
  {
  return ( const_iterator ( _Myptr ( ), this ) );
  }

 iterator end ( )
  {
  return ( iterator ( _Myptr ( ) + _Mysize, this ) );
  }

 const_iterator end ( ) const
  {
  return ( const_iterator ( _Myptr ( ) + _Mysize, this ) );
  }

 reverse_iterator rbegin ( )
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( )
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }

 reference at ( size_type _Off )
  {
  if ( _Mysize <= _Off )
   _String_base :: _Xran ( );
  return ( _Myptr ( ) [ _Off ] );
  }

 const_reference at ( size_type _Off ) const
  {
  if ( _Mysize <= _Off )
   _String_base :: _Xran ( );
  return ( _Myptr ( ) [ _Off ] );
  }



 reference operator [ ] ( size_type _Off )
  {












  { if ( ! ( _Off <= _Mysize ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };


  return ( _Myptr ( ) [ _Off ] );
  }

 const_reference operator [ ] ( size_type _Off ) const
  {












  { if ( ! ( _Off <= _Mysize ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };


  return ( _Myptr ( ) [ _Off ] );
  }

















































 void push_back ( _Elem _Ch )
  {
  insert ( end ( ), _Ch );
  }

 const _Elem * c_str ( ) const
  {
  return ( _Myptr ( ) );
  }

 const _Elem * data ( ) const
  {
  return ( c_str ( ) );
  }

 size_type length ( ) const
  {
  return ( _Mysize );
  }

 size_type size ( ) const
  {
  return ( _Mysize );
  }

 size_type max_size ( ) const
  {
  size_type _Num = _Mybase :: _Alval . max_size ( );
  return ( _Num <= 1 ? 1 : _Num - 1 );
  }

 void resize ( size_type _Newsize )
  {
  resize ( _Newsize, _Elem ( ) );
  }

 void resize ( size_type _Newsize, _Elem _Ch )
  {
  if ( _Newsize <= _Mysize )
   erase ( _Newsize );
  else
   append ( _Newsize - _Mysize, _Ch );
  }

 size_type capacity ( ) const
  {
  return ( _Myres );
  }

 void reserve ( size_type _Newcap = 0 )
  {
  if ( _Mysize <= _Newcap && _Myres != _Newcap )
   {
   size_type _Size = _Mysize;
   if ( _Grow ( _Newcap, true ) )
    _Eos ( _Size );
   }
  }

 bool empty ( ) const
  {
  return ( _Mysize == 0 );
  }

 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 size_type copy ( _Elem * _Dest,
  size_type _Count, size_type _Off = 0 ) const
  {







  return _Copy_s ( _Dest, _Count, _Count, _Off );
  }

 size_type _Copy_s ( _Elem * _Dest, size_type _Dest_size,
  size_type _Count, size_type _Off = 0 ) const
  {
  ;
  if ( _Mysize < _Off )
   _String_base :: _Xran ( );
  if ( _Mysize - _Off < _Count )
   _Count = _Mysize - _Off;
  _Traits_helper :: copy_s < _Traits > ( _Dest, _Dest_size, _Myptr ( ) + _Off, _Count );
  return ( _Count );
  }

 void swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( _Mybase :: _Alval == _Right . _Alval )
   {





   _Bxty _Tbx = _Bx;
   _Bx = _Right . _Bx, _Right . _Bx = _Tbx;

   size_type _Tlen = _Mysize;
   _Mysize = _Right . _Mysize, _Right . _Mysize = _Tlen;

   size_type _Tres = _Myres;
   _Myres = _Right . _Myres, _Right . _Myres = _Tres;
   }
  else
   {
   _Myt _Tmp = * this;

   * this = _Right;
   _Right = _Tmp;
   }
  }

 size_type find ( const _Myt & _Right, size_type _Off = 0 ) const
  {
  return ( find ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {






  if ( _Count == 0 && _Off <= _Mysize )
   return ( _Off );

  size_type _Nm;
  if ( _Off < _Mysize && _Count <= ( _Nm = _Mysize - _Off ) )
   {
   const _Elem * _Uptr, * _Vptr;
   for ( _Nm -= _Count - 1, _Vptr = _Myptr ( ) + _Off;
    ( _Uptr = _Traits :: find ( _Vptr, _Nm, * _Ptr ) ) != 0;
    _Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1 )
    if ( _Traits :: compare ( _Uptr, _Ptr, _Count ) == 0 )
     return ( _Uptr - _Myptr ( ) );
   }

  return ( npos );
  }

 size_type find ( const _Elem * _Ptr, size_type _Off = 0 ) const
  {
  ;
  return ( find ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find ( _Elem _Ch, size_type _Off = 0 ) const
  {
  return ( find ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type rfind ( const _Myt & _Right, size_type _Off = npos ) const
  {
  return ( rfind ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type rfind ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {






  if ( _Count == 0 )
   return ( _Off < _Mysize ? _Off : _Mysize );
  if ( _Count <= _Mysize )
   {
   const _Elem * _Uptr = _Myptr ( ) +
    ( _Off < _Mysize - _Count ? _Off : _Mysize - _Count );
   for (;; -- _Uptr )
    if ( _Traits :: eq ( * _Uptr, * _Ptr )
     && _Traits :: compare ( _Uptr, _Ptr, _Count ) == 0 )
     return ( _Uptr - _Myptr ( ) );
    else if ( _Uptr == _Myptr ( ) )
     break;
   }

  return ( npos );
  }

 size_type rfind ( const _Elem * _Ptr, size_type _Off = npos ) const
  {
  ;
  return ( rfind ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type rfind ( _Elem _Ch, size_type _Off = npos ) const
  {
  return ( rfind ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_first_of ( const _Myt & _Right,
  size_type _Off = 0 ) const
  {
  return ( find_first_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find_first_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {






  if ( 0 < _Count && _Off < _Mysize )
   {
   const _Elem * const _Vptr = _Myptr ( ) + _Mysize;
   for ( const _Elem * _Uptr = _Myptr ( ) + _Off; _Uptr < _Vptr; ++ _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) != 0 )
     return ( _Uptr - _Myptr ( ) );
   }

  return ( npos );
  }

 size_type find_first_of ( const _Elem * _Ptr, size_type _Off = 0 ) const
  {
  ;
  return ( find_first_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_first_of ( _Elem _Ch, size_type _Off = 0 ) const
  {
  return ( find ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_last_of ( const _Myt & _Right,
  size_type _Off = npos ) const
  {
  return ( find_last_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find_last_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {






  if ( 0 < _Count && 0 < _Mysize )
   for ( const _Elem * _Uptr = _Myptr ( )
    + ( _Off < _Mysize ? _Off : _Mysize - 1 );; -- _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) != 0 )
     return ( _Uptr - _Myptr ( ) );
    else if ( _Uptr == _Myptr ( ) )
     break;

  return ( npos );
  }

 size_type find_last_of ( const _Elem * _Ptr,
  size_type _Off = npos ) const
  {
  ;
  return ( find_last_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_last_of ( _Elem _Ch, size_type _Off = npos ) const
  {
  return ( rfind ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_first_not_of ( const _Myt & _Right,
  size_type _Off = 0 ) const
  {
  return ( find_first_not_of ( _Right . _Myptr ( ), _Off,
   _Right . size ( ) ) );
  }

 size_type find_first_not_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {






  if ( _Off < _Mysize )
   {
   const _Elem * const _Vptr = _Myptr ( ) + _Mysize;
   for ( const _Elem * _Uptr = _Myptr ( ) + _Off; _Uptr < _Vptr; ++ _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) == 0 )
     return ( _Uptr - _Myptr ( ) );
   }
  return ( npos );
  }

 size_type find_first_not_of ( const _Elem * _Ptr,
  size_type _Off = 0 ) const
  {
  ;
  return ( find_first_not_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_first_not_of ( _Elem _Ch, size_type _Off = 0 ) const
  {
  return ( find_first_not_of ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_last_not_of ( const _Myt & _Right,
  size_type _Off = npos ) const
  {
  return ( find_last_not_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find_last_not_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {






  if ( 0 < _Mysize )
   for ( const _Elem * _Uptr = _Myptr ( )
    + ( _Off < _Mysize ? _Off : _Mysize - 1 );; -- _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) == 0 )
     return ( _Uptr - _Myptr ( ) );
    else if ( _Uptr == _Myptr ( ) )
     break;
  return ( npos );
  }

 size_type find_last_not_of ( const _Elem * _Ptr,
  size_type _Off = npos ) const
  {
  ;
  return ( find_last_not_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_last_not_of ( _Elem _Ch, size_type _Off = npos ) const
  {
  return ( find_last_not_of ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 _Myt substr ( size_type _Off = 0, size_type _Count = npos ) const
  {
  return ( _Myt ( * this, _Off, _Count, get_allocator ( ) ) );
  }

 int compare ( const _Myt & _Right ) const
  {
  return ( compare ( 0, _Mysize, _Right . _Myptr ( ), _Right . size ( ) ) );
  }

 int compare ( size_type _Off, size_type _N0,
  const _Myt & _Right ) const
  {
  return ( compare ( _Off, _N0, _Right, 0, npos ) );
  }

 int compare ( size_type _Off,
  size_type _N0, const _Myt & _Right,
  size_type _Roff, size_type _Count ) const
  {
  if ( _Right . size ( ) < _Roff )
   _String_base :: _Xran ( );
  if ( _Right . _Mysize - _Roff < _Count )
   _Count = _Right . _Mysize - _Roff;
  return ( compare ( _Off, _N0, _Right . _Myptr ( ) + _Roff, _Count ) );
  }

 int compare ( const _Elem * _Ptr ) const
  {
  ;
  return ( compare ( 0, _Mysize, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 int compare ( size_type _Off, size_type _N0, const _Elem * _Ptr ) const
  {
  ;
  return ( compare ( _Off, _N0, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 int compare ( size_type _Off,
  size_type _N0, const _Elem * _Ptr, size_type _Count ) const
  {






  if ( _Mysize < _Off )
   _String_base :: _Xran ( );
  if ( _Mysize - _Off < _N0 )
   _N0 = _Mysize - _Off;

  size_type _Ans = _Traits :: compare ( _Myptr ( ) + _Off, _Ptr,
   _N0 < _Count ? _N0 : _Count );
  return ( _Ans != 0 ? ( int ) _Ans : _N0 < _Count ? - 1
   : _N0 == _Count ? 0 : + 1 );
  }

 allocator_type get_allocator ( ) const
  {
  return ( _Mybase :: _Alval );
  }

 enum
  {
  _BUF_SIZE = 16 / sizeof ( _Elem ) < 1 ? 1
   : 16 / sizeof ( _Elem ) };

protected :
 enum
  {
  _ALLOC_MASK = sizeof ( _Elem ) <= 1 ? 15
   : sizeof ( _Elem ) <= 2 ? 7
   : sizeof ( _Elem ) <= 4 ? 3
   : sizeof ( _Elem ) <= 8 ? 1 : 0 };

 void _Chassign ( size_type _Off, size_type _Count, _Elem _Ch )
  {
  if ( _Count == 1 )
   _Traits :: assign ( * ( _Myptr ( ) + _Off ), _Ch );
  else
   _Traits :: assign ( _Myptr ( ) + _Off, _Count, _Ch );
  }

 void _Copy ( size_type _Newsize, size_type _Oldlen )
  {
  size_type _Newres = _Newsize | _ALLOC_MASK;
  if ( max_size ( ) < _Newres )
   _Newres = _Newsize;
  else if ( _Newres / 3 < _Myres / 2
   && _Myres <= max_size ( ) - _Myres / 2 )
   _Newres = _Myres + _Myres / 2;
  _Elem * _Ptr = 0;

  try {
   _Ptr = _Mybase :: _Alval . allocate ( _Newres + 1 );
  } catch ( ... ) {
   _Newres = _Newsize;
   try {
    _Ptr = _Mybase :: _Alval . allocate ( _Newres + 1 );
   } catch ( ... ) {
   _Tidy ( true );
   throw;
   }
  }

  if ( 0 < _Oldlen )
   _Traits_helper :: copy_s < _Traits > ( _Ptr, _Newres + 1, _Myptr ( ), _Oldlen );
  _Tidy ( true );
  _Bx . _Ptr = _Ptr;
  _Myres = _Newres;
  _Eos ( _Oldlen );
  }

 void _Eos ( size_type _Newsize )
  {
  _Traits :: assign ( _Myptr ( ) [ _Mysize = _Newsize ], _Elem ( ) );
  }

 bool _Grow ( size_type _Newsize,
  bool _Trim = false )
  {
   if ( max_size ( ) < _Newsize )
   _String_base :: _Xlen ( );
  if ( _Myres < _Newsize )
   _Copy ( _Newsize, _Mysize );
  else if ( _Trim && _Newsize < _BUF_SIZE )
   _Tidy ( true,
    _Newsize < _Mysize ? _Newsize : _Mysize );
  else if ( _Newsize == 0 )
   _Eos ( 0 );
  return ( 0 < _Newsize );
  }

 bool _Inside ( const _Elem * _Ptr )
  {
  if ( _Ptr == 0 || _Ptr < _Myptr ( ) || _Myptr ( ) + _Mysize <= _Ptr )
   return ( false );
  else
   return ( true );
  }

 static size_type __cdecl _Pdif ( const_iterator _P2,
  const_iterator _P1 )
  {
  return ( ( _P2 ) . _Myptr == 0 ? 0 : _P2 - _P1 );
  }

 void _Tidy ( bool _Built = false,
  size_type _Newsize = 0 )
  {
  if ( ! _Built )
   ;
  else if ( _BUF_SIZE <= _Myres )
   {
   _Elem * _Ptr = _Bx . _Ptr;
   if ( 0 < _Newsize )
    _Traits_helper :: copy_s < _Traits > ( _Bx . _Buf, _BUF_SIZE, _Ptr, _Newsize );
   _Mybase :: _Alval . deallocate ( _Ptr, _Myres + 1 );
   }
  _Myres = _BUF_SIZE - 1;
  _Eos ( _Newsize );
  }

 union _Bxty
  {
  _Elem _Buf [ _BUF_SIZE ];
  _Elem * _Ptr;
  } _Bx;

 _Elem * _Myptr ( )
  {
  return ( _BUF_SIZE <= _Myres ? _Bx . _Ptr : _Bx . _Buf );
  }

 const _Elem * _Myptr ( ) const
  {
  return ( _BUF_SIZE <= _Myres ? _Bx . _Ptr : _Bx . _Buf );
  }

 size_type _Mysize;
 size_type _Myres;
 };
#line 2183 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstring"
template<class _Elem, class _Traits, class _Ax> 
#pragma pack(8)
#line 2184 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstring"
class _Move_operation_category< basic_string< _Elem, _Traits, _Ax> >  { 


public: typedef _Swap_move_tag _Move_cat; 
}; 
#pragma pack()

template<class _Elem, class 
_Traits, class 
_Alloc> const typename basic_string< _Elem, _Traits, _Alloc> ::size_type 

basic_string< _Elem, _Traits, _Alloc> ::npos = (typename std::basic_string< _Elem, _Traits, typename _String_val< _Elem, _Alloc> ::_Alty> ::size_type)(-1); 




template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void __cdecl swap ( basic_string < _Elem, _Traits, _Alloc > & _Left,
  basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }


typedef basic_string< char, char_traits< char> , allocator< char> >  string; 

typedef basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstring; 
#line 2229 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstring"
}

#pragma warning(default: 4251)
#pragma warning(pop)
#line 11 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
#pragma warning(push,3)
#line 2233 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xstring"
#pragma pack ( pop )
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
#pragma pack ( push, 8 )
#line 13 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
namespace std { 
#line 20 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
class logic_error : public exception { 



public: explicit logic_error(const string &_Message) : _Str(_Message) 

{ 
} 

virtual ~logic_error() throw() 
{ 
} 

virtual const char *what() const throw() 
{ 
return (this->_Str).c_str(); 
} 
#line 47 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
private: string _Str; 
}; 


class domain_error : public logic_error { 



public: explicit domain_error(const string &_Message) : logic_error(_Message) 

{ 
} 

virtual ~domain_error() throw() 
{ 
} 
#line 72 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
}; 


class invalid_argument : public logic_error { 



public: explicit invalid_argument(const string &_Message) : logic_error(_Message) 

{ 
} 

virtual ~invalid_argument() throw() 
{ 
} 
#line 96 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
}; 


class length_error : public logic_error { 



public: explicit length_error(const string &_Message) : logic_error(_Message) 

{ 
} 

virtual ~length_error() throw() 
{ 
} 
#line 120 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
}; 


class out_of_range : public logic_error { 



public: explicit out_of_range(const string &_Message) : logic_error(_Message) 

{ 
} 

virtual ~out_of_range() throw() 
{ 
} 
#line 144 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
}; 


class runtime_error : public exception { 



public: explicit runtime_error(const string &_Message) : _Str(_Message) 

{ 
} 

virtual ~runtime_error() throw() 
{ 
} 

virtual const char *what() const throw() 
{ 
return (this->_Str).c_str(); 
} 
#line 174 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
private: string _Str; 
}; 


class overflow_error : public runtime_error { 



public: explicit overflow_error(const string &_Message) : runtime_error(_Message) 

{ 
} 

virtual ~overflow_error() throw() 
{ 
} 
#line 199 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
}; 


class underflow_error : public runtime_error { 



public: explicit underflow_error(const string &_Message) : runtime_error(_Message) 

{ 
} 

virtual ~underflow_error() throw() 
{ 
} 
#line 223 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
}; 


class range_error : public runtime_error { 



public: explicit range_error(const string &_Message) : runtime_error(_Message) 

{ 
} 

virtual ~range_error() throw() 
{ 
} 
#line 247 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
}; 
#line 271 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\stdexcept"
}

#pragma warning(pop)
#pragma pack ( pop )
#line 25 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\typeinfo"
#pragma pack ( push, 8 )
#line 36 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\typeinfo"
struct __type_info_node { 
void *memPtr; 
__type_info_node *next; 
}; 

extern __type_info_node __type_info_root_node; 

class type_info { 

public: virtual ~type_info(); 
bool operator==(const type_info &) const; 
bool operator!=(const type_info &) const; 
int before(const type_info &) const; 
const char *name(__type_info_node * = (&__type_info_root_node)) const; 
const char *raw_name() const; 

private: void *_m_data; 
char _m_d_name[1]; 
type_info(const type_info &); 
type_info &operator=(const type_info &); 
static const char *__cdecl _Name_base(const type_info *, __type_info_node *); 
static void __cdecl _Type_info_dtor(type_info *); 
}; 



namespace std { 

using ::type_info;

}
#line 72 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\typeinfo"
namespace std { 

class bad_cast : public exception { 
#line 86 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\typeinfo"
public: bad_cast(const char * = ("bad cast")); 
bad_cast(const bad_cast &); 
virtual ~bad_cast(); 
#line 90 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\typeinfo"
}; 

class bad_typeid : public exception { 
#line 104 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\typeinfo"
public: bad_typeid(const char * = ("bad typeid")); 
bad_typeid(const bad_typeid &); 
virtual ~bad_typeid(); 
#line 109 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\typeinfo"
}; 

class __non_rtti_object : public bad_typeid { 
#line 123 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\typeinfo"
public: __non_rtti_object(const char *); 
__non_rtti_object(const __non_rtti_object &); 
virtual ~__non_rtti_object(); 
#line 127 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\typeinfo"
}; 

}
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xdebug"
#pragma warning(push,3)
#line 194 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\typeinfo"
#pragma pack ( pop )
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xdebug"
#pragma pack ( push, 8 )
#line 13 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xdebug"
namespace std { 
struct _DebugHeapTag_t { 

int _Type; 
}; 
}
#line 154 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xdebug"
#pragma warning(pop)
#pragma pack ( pop )
#line 94 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ctype.h"
extern "C" { extern int __cdecl _isctype(int, int); } 
extern "C" { extern int __cdecl _isctype_l(int, int, _locale_t); } 
extern "C" { extern int __cdecl isalpha(int); } 
extern "C" { extern int __cdecl _isalpha_l(int, _locale_t); } 
extern "C" { extern int __cdecl isupper(int); } 
extern "C" { extern int __cdecl _isupper_l(int, _locale_t); } 
extern "C" { extern int __cdecl islower(int); } 
extern "C" { extern int __cdecl _islower_l(int, _locale_t); } 
extern "C" { extern int __cdecl isdigit(int); } 
extern "C" { extern int __cdecl _isdigit_l(int, _locale_t); } 
extern "C" { extern int __cdecl isxdigit(int); } 
extern "C" { extern int __cdecl _isxdigit_l(int, _locale_t); } 
extern "C" { extern int __cdecl isspace(int); } 
extern "C" { extern int __cdecl _isspace_l(int, _locale_t); } 
extern "C" { extern int __cdecl ispunct(int); } 
extern "C" { extern int __cdecl _ispunct_l(int, _locale_t); } 
extern "C" { extern int __cdecl isalnum(int); } 
extern "C" { extern int __cdecl _isalnum_l(int, _locale_t); } 
extern "C" { extern int __cdecl isprint(int); } 
extern "C" { extern int __cdecl _isprint_l(int, _locale_t); } 
extern "C" { extern int __cdecl isgraph(int); } 
extern "C" { extern int __cdecl _isgraph_l(int, _locale_t); } 
extern "C" { extern int __cdecl iscntrl(int); } 
extern "C" { extern int __cdecl _iscntrl_l(int, _locale_t); } 
extern "C" { extern int __cdecl toupper(int); } 
extern "C" { extern int __cdecl tolower(int); } 
extern "C" { extern int __cdecl _tolower(int); } 
extern "C" { extern int __cdecl _tolower_l(int, _locale_t); } 
extern "C" { extern int __cdecl _toupper(int); } 
extern "C" { extern int __cdecl _toupper_l(int, _locale_t); } 
extern "C" { extern int __cdecl __isascii(int); } 
extern "C" { extern int __cdecl __toascii(int); } 
extern "C" { extern int __cdecl __iscsymf(int); } 
extern "C" { extern int __cdecl __iscsym(int); } 
#line 28 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\locale.h"
#pragma pack ( push, 8 )
#line 59 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\locale.h"
extern "C" { struct lconv { 
char *decimal_point; 
char *thousands_sep; 
char *grouping; 
char *int_curr_symbol; 
char *currency_symbol; 
char *mon_decimal_point; 
char *mon_thousands_sep; 
char *mon_grouping; 
char *positive_sign; 
char *negative_sign; 
char int_frac_digits; 
char frac_digits; 
char p_cs_precedes; 
char p_sep_by_space; 
char n_cs_precedes; 
char n_sep_by_space; 
char p_sign_posn; 
char n_sign_posn; 
}; }
#line 103 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\locale.h"
extern "C" { extern int __cdecl _configthreadlocale(int); } 
extern "C" { extern char *__cdecl setlocale(int, const char *); } 
extern "C" { extern lconv *__cdecl localeconv(); } 
extern "C" { extern _locale_t __cdecl _get_current_locale(); } 
extern "C" { extern _locale_t __cdecl _create_locale(int, const char *); } 
extern "C" { extern void __cdecl _free_locale(_locale_t); } 


extern "C" { extern __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _get_current_locale instead. See online help for details.")) _locale_t __cdecl __get_current_locale(); } 
extern "C" { extern __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _create_locale instead. See online help for details.")) _locale_t __cdecl __create_locale(int, const char *); } 
extern "C" { extern __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _free_locale instead. See online help for details.")) void __cdecl __free_locale(_locale_t); } 
#line 129 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\locale.h"
#pragma pack ( pop )
#line 13 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo.h"
#pragma pack ( push, 8 )
#line 57 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo.h"
extern "C" { typedef 
#line 53 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo.h"
struct _Collvec { 

unsigned long _Hand; 
unsigned _Page; 
} _Collvec; }
#line 65 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo.h"
extern "C" { typedef 
#line 59 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo.h"
struct _Ctypevec { 

unsigned long _Hand; 
unsigned _Page; 
const short *_Table; 
int _Delfl; 
} _Ctypevec; }
#line 71 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo.h"
extern "C" { typedef 
#line 67 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo.h"
struct _Cvtvec { 

unsigned long _Hand; 
unsigned _Page; 
} _Cvtvec; }


extern "C" { extern _Collvec __cdecl _Getcoll(); } 
extern "C" { extern _Ctypevec __cdecl _Getctype(); } 
extern "C" { extern _Cvtvec __cdecl _Getcvt(); } 

extern "C" { extern int __cdecl _Getdateorder(); } 

extern "C" { extern int __cdecl _Mbrtowc(__wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *); } 

extern "C" { extern float __cdecl _Stof(const char *, char **, long); } 
extern "C" { extern double __cdecl _Stod(const char *, char **, long); } 
extern "C" { extern long double __cdecl _Stold(const char *, char **, long); } 

extern "C" { extern int __cdecl _Strcoll(const char *, const char *, const char *, const char *, const _Collvec *); } 

extern "C" { extern size_t __cdecl _Strxfrm(char *, char *, const char *, const char *, const _Collvec *); } 


extern "C" { extern int __cdecl _Tolower(int, const _Ctypevec *); } 
extern "C" { extern int __cdecl _Toupper(int, const _Ctypevec *); } 
extern "C" { extern int __cdecl _Wcrtomb(char *, __wchar_t, mbstate_t *, const _Cvtvec *); } 

extern "C" { extern int __cdecl _Wcscoll(const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *, const _Collvec *); } 

extern "C" { extern size_t __cdecl _Wcsxfrm(__wchar_t *, __wchar_t *, const __wchar_t *, const __wchar_t *, const _Collvec *); } 



extern "C" { extern short __cdecl _Getwctype(__wchar_t, const _Ctypevec *); } 
extern "C" { extern const __wchar_t *__cdecl _Getwctypes(const __wchar_t *, const __wchar_t *, short *, const _Ctypevec *); } 

extern "C" { extern __wchar_t __cdecl _Towlower(__wchar_t, const _Ctypevec *); } 
extern "C" { extern __wchar_t __cdecl _Towupper(__wchar_t, const _Ctypevec *); } 
#line 112 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo.h"
extern "C" { extern void *__cdecl _Gettnames(); } 
extern "C" { extern char *__cdecl _Getdays(); } 
extern "C" { extern char *__cdecl _Getmonths(); } 
extern "C" { extern size_t __cdecl _Strftime(char *, size_t, const char *, const tm *, void *); } 
#line 121 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo.h"
extern "C" { extern _locale_t __cdecl _GetLocaleForCP(unsigned); } 
#line 12 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo"
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 125 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo.h"
#pragma pack ( pop )
#line 11 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo"
#pragma pack ( push, 8 )
#line 16 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo"
namespace std { 


class _Timevec { 


public: _Timevec(void *_Ptr = 0) : _Timeptr(_Ptr) 

{ 
} 

_Timevec(const _Timevec &_Right) 
{ 
((*this) = _Right); 
} 

~_Timevec() 
{ 
free(this->_Timeptr); 
} 

_Timevec &operator=(const _Timevec &_Right) 
{ 
(this->_Timeptr) = _Right._Timeptr; 
(((_Timevec &)_Right)._Timeptr) = (0); 
return *this; 
} 

void *_Getptr() const 
{ 
return this->_Timeptr; 
} 


private: void *_Timeptr; 
}; 




#pragma warning(push)
#pragma warning(disable:4412)
class _Locinfo { 


public: typedef ::_Collvec _Collvec; 
typedef ::_Ctypevec _Ctypevec; 
typedef ::_Cvtvec _Cvtvec; 
typedef std::_Timevec _Timevec; 

static void __cdecl _Locinfo_ctor(_Locinfo *, const char *); 
static void __cdecl _Locinfo_ctor(_Locinfo *, const string &); 
static void __cdecl _Locinfo_ctor(_Locinfo *, int, const char *); 
static void __cdecl _Locinfo_dtor(_Locinfo *); 
static _Locinfo &__cdecl _Locinfo_Addcats(_Locinfo *, int, const char *); 

_Locinfo(const char *_Pch = ("C")) : _Lock(0) 
#line 76 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo"
{ 
if (_Pch == (0)) { 
throw ((runtime_error)("bad locale name")); }  
_Locinfo_ctor(this, _Pch); 
} 

_Locinfo(int _I, const char *_Pch) : _Lock(0) 
#line 86 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo"
{ 
if (_Pch == (0)) { 
throw ((runtime_error)("bad locale name")); }  
_Locinfo_ctor(this, _I, _Pch); 
} 

_Locinfo(const string &locstr) : _Lock(0) 
#line 96 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo"
{ 
_Locinfo_ctor(this, locstr); 
} 

~_Locinfo() 
{ 
_Locinfo_dtor(this); 
} 

_Locinfo &_Addcats(int _I, const char *_Pch) 
{ 
if (_Pch == (0)) { 
throw ((runtime_error)("bad locale name")); }  
return _Locinfo_Addcats(this, _I, _Pch); 
} 

string _Getname() const 
{ 
return this->_Newlocname; 
} 

_Collvec _Getcoll() const 
{ 
return ::_Getcoll(); 
} 

_Ctypevec _Getctype() const 
{ 
return ::_Getctype(); 
} 

_Cvtvec _Getcvt() const 
{ 
return ::_Getcvt(); 
} 

const lconv *_Getlconv() const 
{ 
return localeconv(); 
} 

_Timevec _Gettnames() const 
{ 
return ((_Timevec)(::_Gettnames())); 
} 

const char *_Getdays() const 
{ 
auto const char *_Ptr = (::_Getdays()); 
if (_Ptr != (0)) 
{ 
((((_Locinfo &)(*this))._Days) = _Ptr); 
free((void *)_Ptr); 
}  
return ((this->_Days).size() != (0)) ? (this->_Days).c_str() : (":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday"); 


} 

const char *_Getmonths() const 
{ 
auto const char *_Ptr = (::_Getmonths()); 
if (_Ptr != (0)) 
{ 
((((_Locinfo &)(*this))._Months) = _Ptr); 
free((void *)_Ptr); 
}  
return ((this->_Months).size() != (0)) ? (this->_Months).c_str() : (":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:De" "cember"); 




} 

const char *_Getfalse() const 
{ 
return "false"; 
} 

const char *_Gettrue() const 
{ 
return "true"; 
} 

int _Getdateorder() const 
{ 
return ::_Getdateorder(); 
} 
#line 191 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo"
private: _Lockit _Lock; 
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo"
string _Days; 
string _Months; 
string _Oldlocname; 
string _Newlocname; 
}; 
#pragma warning(pop)


template < class _Elem > inline
 int __cdecl _LStrcoll ( const _Elem * _First1, const _Elem * _Last1,
  const _Elem * _First2, const _Elem * _Last2,
   const _Locinfo :: _Collvec * )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( * _First1 < * _First2 )
   return ( - 1 );
  else if ( * _First2 < * _First1 )
   return ( + 1 );
 return ( _First2 != _Last2 ? - 1 : _First1 != _Last1 ? + 1 : 0 );
 }


template<> inline int __cdecl _LStrcoll(const char *_First1, const char *_Last1, const char *
_First2, const char *_Last2, const _Locinfo::_Collvec *
_Vector) 
{ 
return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector); 
} 


template<> inline int __cdecl _LStrcoll(const __wchar_t *_First1, const __wchar_t *_Last1, const __wchar_t *
_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
_Vector) 
{ 
return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector); 
} 


template < class _Elem > inline
 size_t __cdecl _LStrxfrm ( _Elem * _First1, _Elem * _Last1,
  const _Elem * _First2, const _Elem * _Last2,
   const _Locinfo :: _Collvec * )
 {
 size_t _Count = _Last2 - _First2;
 if ( _Count <= ( size_t ) ( _Last1 - _First1 ) )
  :: memcpy_s ( ( _First1 ), ( ( _Last1 - _First1 ) * sizeof ( _Elem ) ), ( _First2 ), ( _Count * sizeof ( _Elem ) ) );
 return ( _Count );
 }


template<> inline size_t __cdecl _LStrxfrm(char *
_First1, char *
_Last1, const char *
_First2, const char *_Last2, const _Locinfo::_Collvec *
_Vector) 
{ 
return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
} 


template<> inline size_t __cdecl _LStrxfrm(__wchar_t *
_First1, __wchar_t *
_Last1, const __wchar_t *
_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
_Vector) 
{ 
return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
} 
}

#pragma warning(pop)
#line 15 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 264 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocinfo"
#pragma pack ( pop )
#line 14 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
#pragma pack ( push, 8 )
#line 19 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
namespace std { 


template<class _Dummy> 
class _Locbase { 


public: static const int collate = ((1 << 1) >> 1); 
static const int ctype = ((1 << 2) >> 1); 
static const int monetary = ((1 << 3) >> 1); 
static const int numeric = ((1 << 4) >> 1); 
static const int time = ((1 << 5) >> 1); 
static const int messages = ((1 << 6) >> 1); 
static const int all = (((1 << 7) >> 1) - 1); 
static const int none = 0; 
}; 

template<class _Dummy> const int 
_Locbase< _Dummy> ::collate; 
template<class _Dummy> const int 
_Locbase< _Dummy> ::ctype; 
template<class _Dummy> const int 
_Locbase< _Dummy> ::monetary; 
template<class _Dummy> const int 
_Locbase< _Dummy> ::numeric; 
template<class _Dummy> const int 
_Locbase< _Dummy> ::time; 
template<class _Dummy> const int 
_Locbase< _Dummy> ::messages; 
template<class _Dummy> const int 
_Locbase< _Dummy> ::all; 
template<class _Dummy> const int 
_Locbase< _Dummy> ::none; 


class locale; 
template < class _Facet >
 const _Facet & __cdecl use_facet ( const locale & );


#pragma warning(push)
#pragma warning(disable:4412)
class locale : public _Locbase< int>  { 



public: typedef int category; 


class id { 


public: id(size_t _Val = (0)) : _Id(_Val) 

{ 
} 

operator size_t() 
{ 
if ((this->_Id) == (0)) 
{ 
{ auto _Lockit _Lock(0); 
if ((this->_Id) == (0)) { 
(this->_Id) = ++_Id_cnt; }  
} 
}  
return this->_Id; 
} 


private: id(const id &); 
id &operator=(const id &); 

size_t _Id; 
static int &__cdecl _Id_cnt_func(); 



static int _Id_cnt; 
#line 99 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
}; 

class _Locimp; 


class facet { 

friend class locale; 
friend class _Locimp; 


public: static size_t __cdecl _Getcat(const facet ** = 0, const locale * = 0) 

{ 
return (size_t)(-1); 
} 

void _Incref() 
{ 
{ auto _Lockit _Lock(0); 
if ((this->_Refs) < ((size_t)(-1))) { 
++(this->_Refs); }  
} 
} 

facet *_Decref() 
{ 
{ auto _Lockit _Lock(0); 
if (((0) < (this->_Refs)) && ((this->_Refs) < ((size_t)(-1)))) { 
--(this->_Refs); }  
return ((this->_Refs) == (0)) ? this : (0); 
} 
} 

void _Register() 
{ 
#line 138 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
facet_Register(this); 
#line 140 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
} 
#line 169 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
virtual ~facet() 
{ 
} 


protected: explicit facet(size_t _Initrefs = (0)) : _Refs(_Initrefs) 

{ 
} 
#line 183 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
private: static void __cdecl facet_Register(facet *); 
#line 186 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
facet(const facet &); 
facet &operator=(const facet &); 

size_t _Refs; 
}; 

#pragma warning(push)
#pragma warning(disable:4275)

class _Locimp : public facet { 



protected: virtual ~_Locimp() 
{ 
_Locimp_dtor(this); 
} 


private: static void __cdecl _Locimp_dtor(_Locimp *); 
static void _Locimp_ctor(_Locimp *, const _Locimp &); 
static void __cdecl _Locimp_Addfac(_Locimp *, facet *, size_t); 
friend class locale; 

_Locimp(bool _Transparent = false) : facet(1), _Facetvec((0)), _Facetcount((0)), _Catmask((none)), _Xparent(_Transparent), _Name("*") 


{ } 

_Locimp(const _Locimp &_Right) : facet(1), _Facetvec((0)), _Facetcount((_Right._Facetcount)), _Catmask((_Right._Catmask)), _Xparent((_Right._Xparent)), _Name(_Right._Name) 


{ 
_Locimp_ctor(this, _Right); 
} 

void _Addfac(facet *_Pfacet, size_t _Id) 
{ 
_Locimp_Addfac(this, _Pfacet, _Id); 
} 

static _Locimp *_Makeloc(const _Locinfo &, category, _Locimp *, const locale *); 


static void _Makewloc(const _Locinfo &, category, _Locimp *, const locale *); 



static void _Makeushloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 238 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
static void _Makexloc(const _Locinfo &, category, _Locimp *, const locale *); 


facet **_Facetvec; 
size_t _Facetcount; 
category _Catmask; 
bool _Xparent; 
string _Name; 

static _Locimp *&__cdecl _Clocptr_func(); 



static _Locimp *_Clocptr; 
#line 254 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
_Locimp &operator=(const _Locimp &); 

}; 
#pragma warning(pop)

__declspec(deprecated("This is an obsolete part of the Standard C++ Library Implementation. Do not use it.")) locale &_Addfac(facet *_Fac, size_t _Id, size_t 
_Catmask) 
{ 
if ((1) < ((*(this->_Ptr))._Refs)) 
{ 
(*(this->_Ptr))._Decref(); 
(this->_Ptr) = (new _Locimp(*(this->_Ptr))); 
}  
(*(this->_Ptr))._Addfac(_Fac, _Id); 

if (_Catmask != (0)) { 
(((*(this->_Ptr))._Name) = ("*")); }  
return *this; 
} 


template < class _Elem,
  class _Traits,
  class _Alloc >
  bool operator ( ) ( const basic_string < _Elem, _Traits, _Alloc > & _Left,
   const basic_string < _Elem, _Traits, _Alloc > & _Right ) const
  {
  const std :: collate < _Elem > & _Coll_fac =
   std :: use_facet < std :: collate < _Elem > > ( * this );

  return ( _Coll_fac . compare ( _Left . c_str ( ), _Left . c_str ( ) + _Left . size ( ),
   _Right . c_str ( ), _Right . c_str ( ) + _Right . size ( ) ) < 0 );
  }

template < class _Facet >
  locale combine ( const locale & _Loc ) const
  {
  _Facet * _Facptr;

  try {
   _Facptr = ( _Facet * ) & std :: use_facet < _Facet > ( _Loc );
  } catch ( ... ) {
   throw runtime_error ( "locale::combine facet missing" );
  }

  _Locimp * _Newimp = new _Locimp ( * _Ptr );
  _Newimp -> _Addfac ( _Facptr, _Facet :: id );
  _Newimp -> _Catmask = 0;
  _Newimp -> _Name = "*";
  return ( locale ( _Newimp ) );
  }

template < class _Facet >
   locale ( const locale & _Loc, const _Facet * _Facptr )
   : _Ptr ( new _Locimp ( * _Loc . _Ptr ) )
  {
  if ( _Facptr != 0 )
   {
   _Ptr -> _Addfac ( ( _Facet * ) _Facptr, _Facet :: id );
   if ( _Facet :: _Getcat ( ) != ( size_t ) ( - 1 ) )
    {
    _Ptr -> _Catmask = 0;
    _Ptr -> _Name = "*";
    }
   }
  }


locale() throw() : _Ptr(_Init()) 

{ 
(*_Getgloballocale())._Incref(); 
} 

locale(_Uninitialized) 
{ 
} 

locale(const locale &_Right) throw() : _Ptr((_Right._Ptr)) 

{ 
(*(this->_Ptr))._Incref(); 
} 

locale(const locale &_Loc, const locale &_Other, category 
_Cat) : _Ptr((new _Locimp(*(_Loc._Ptr)))) 

{ 
try { 
{ auto _Locinfo _Lobj((*(_Loc._Ptr))._Catmask, ((*(_Loc._Ptr))._Name).c_str()); 
_Locimp::_Makeloc(_Lobj._Addcats(_Cat & ((*(_Other._Ptr))._Catmask), ((*(_Other._Ptr))._Name).c_str()), _Cat, this->_Ptr, (&_Other)); 

} 
} catch (...) { 
delete (*(this->_Ptr))._Decref(); 
throw; 
}  
} 

explicit locale(const char *_Locname, category 
_Cat = (all)) : _Ptr((new _Locimp)) 

{ 
try { 
_Init(); 
{ auto _Locinfo _Lobj(_Cat, _Locname); 
if (_Lobj._Getname().compare("*") == 0) { 
throw ((runtime_error)("bad locale name")); }  
_Locimp::_Makeloc(_Lobj, _Cat, this->_Ptr, 0); 
} 
} catch (...) { 
delete (*(this->_Ptr))._Decref(); 
throw; 
}  
} 

locale(const locale &_Loc, const char *_Locname, category 
_Cat) : _Ptr((new _Locimp(*(_Loc._Ptr)))) 

{ 
try { 
{ auto _Locinfo _Lobj((*(_Loc._Ptr))._Catmask, ((*(_Loc._Ptr))._Name).c_str()); 
auto bool _Hadname = (_Lobj._Getname().compare("*") != 0); 
_Lobj._Addcats(_Cat, _Locname); 

if (_Hadname && (_Lobj._Getname().compare("*") == 0)) { 
throw ((runtime_error)("bad locale name")); }  
_Locimp::_Makeloc(_Lobj, _Cat, this->_Ptr, 0); 
} 
} catch (...) { 
delete (*(this->_Ptr))._Decref(); 
throw; 
}  
} 

~locale() throw() 
{ 
if ((this->_Ptr) != (0)) { 
delete (*(this->_Ptr))._Decref(); }  
} 

locale &operator=(const locale &_Right) throw() 
{ 
if ((this->_Ptr) != (_Right._Ptr)) 
{ 
delete (*(this->_Ptr))._Decref(); 
(this->_Ptr) = _Right._Ptr; 
(*(this->_Ptr))._Incref(); 
}  
return *this; 
} 

string name() const 
{ 
return (*(this->_Ptr))._Name; 
} 

const facet *_Getfacet(size_t _Id) const 
{ 
auto const facet *_Facptr = ((_Id < ((*(this->_Ptr))._Facetcount)) ? (((*(this->_Ptr))._Facetvec)[_Id]) : (0)); 

if ((_Facptr != (0)) || (!((*(this->_Ptr))._Xparent))) { 
return _Facptr; } else 

{ 
auto _Locimp *_Ptr = _Getgloballocale(); 
return (_Id < (_Ptr->_Facetcount)) ? ((_Ptr->_Facetvec)[_Id]) : (0); 


}  
} 


bool operator==(const locale &_Loc) const 
{ 
return ((this->_Ptr) == (_Loc._Ptr)) || ((this->name().compare("*") != 0) && (this->name().compare(_Loc.name()) == 0)); 

} 

bool operator!=(const locale &_Right) const 
{ 
return !((*this) == _Right); 
} 

static const locale &__cdecl classic(); 

static locale __cdecl global(const locale &); 

static locale __cdecl empty(); 


private: locale(_Locimp *_Ptrimp) : _Ptr(_Ptrimp) 

{ 
} 

static _Locimp *__cdecl _Getgloballocale(); 
static _Locimp *__cdecl _Init(); 
static void __cdecl _Setgloballocale(void *); 

_Locimp *_Ptr; 
}; 
#pragma warning(pop)


template<class _Facet> 
struct _Facetptr { 

static const locale::facet *_Psave; 
}; 

template<class _Facet> const locale::facet *
_Facetptr< _Facet> ::_Psave = (0); 

template < class _Facet > inline __declspec ( deprecated ( "This is an obsolete part of the Standard C++ Library Implementation. Do not use it." ) )
 locale _Addfac ( locale _Loc, const _Facet * _Facptr )
  {
  size_t _Cat = _Facet :: _Getcat ( 0, 0 );
  locale _Newloc = _Loc . _Addfac ( ( _Facet * ) _Facptr, _Facet :: id, _Cat );

  return ( _Newloc );
  }
#line 482 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
template < class _Facet > inline
 const _Facet & __cdecl use_facet ( const locale & _Loc )


{
 { :: std :: _Lockit _Lock ( 0 );
  const locale :: facet * _Psave =
   _Facetptr < _Facet > :: _Psave;

  size_t _Id = _Facet :: id;
  const locale :: facet * _Pf = _Loc . _Getfacet ( _Id );

  if ( _Pf != 0 )
   ;
  else if ( _Psave != 0 )
   _Pf = _Psave;
  else if ( _Facet :: _Getcat ( & _Psave, & _Loc ) == ( size_t ) ( - 1 ) )


  throw bad_cast ( );





  else
   {
   _Pf = _Psave;
   _Facetptr < _Facet > :: _Psave = _Psave;

   locale :: facet * _Pfmod = ( _Facet * ) _Psave;
   _Pfmod -> _Incref ( );
   _Pfmod -> _Register ( );
   }

  return ( ( const _Facet & ) ( * _Pf ) );
 }
 }
#line 521 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
template < class _Facet > inline __declspec ( deprecated ( "This is an obsolete part of the Standard C++ Library Implementation. Do not use it." ) )
 const _Facet & __cdecl use_facet ( const locale & _Loc, const _Facet *,
  bool = false )
 {
 return use_facet < _Facet > ( _Loc );
 }


template < class _Elem,
 class _InIt > inline
 int __cdecl _Getloctxt ( _InIt & _First, _InIt & _Last, size_t _Numfields,
  const _Elem * _Ptr )
 {
 for ( size_t _Off = 0; _Ptr [ _Off ] != ( _Elem ) 0; ++ _Off )
  if ( _Ptr [ _Off ] == _Ptr [ 0 ] )
   ++ _Numfields;
 string _Str ( _Numfields, '\000' );

 int _Ans = - 2;
 for ( size_t _Column = 1;; ++ _Column, ++ _First, _Ans = - 1 )
  {
  bool _Prefix = false;
  size_t _Off = 0;
  size_t _Field = 0;

  for (; _Field < _Numfields; ++ _Field )
   {
   for (; _Ptr [ _Off ] != ( _Elem ) 0 && _Ptr [ _Off ] != _Ptr [ 0 ]; ++ _Off )
    ;

   if ( _Str [ _Field ] != '\000' )
    _Off += _Str [ _Field ];
   else if ( _Ptr [ _Off += _Column ] == _Ptr [ 0 ]
    || _Ptr [ _Off ] == ( _Elem ) 0 )
    {
    _Str [ _Field ] = ( char ) ( _Column < 127
     ? _Column : 127 );
    _Ans = ( int ) _Field;
    }
   else if ( _First == _Last || _Ptr [ _Off ] != * _First )
    _Str [ _Field ] = ( char ) ( _Column < 127
     ? _Column : 127 );
   else
    _Prefix = true;
   }

  if ( ! _Prefix || _First == _Last )
   break;
  }
 return ( _Ans );
 }
#line 577 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
template < class _Elem > inline
 char __cdecl _Maklocbyte ( _Elem _Char,
  const _Locinfo :: _Cvtvec & )
 {
 return ( ( char ) ( unsigned char ) _Char );
 }


template<> inline char __cdecl _Maklocbyte(__wchar_t _Char, const _Locinfo::_Cvtvec &
_Cvt) 
{ 
auto char _Byte = '\000'; 
auto mbstate_t _Mbst1 = (0); 
_Wcrtomb(&_Byte, _Char, &_Mbst1, (&_Cvt)); 
return _Byte; 
} 
#line 599 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
template < class _Elem > inline
 _Elem __cdecl _Maklocchr ( char _Byte, _Elem *,
  const _Locinfo :: _Cvtvec & )
 {
 return ( ( _Elem ) ( unsigned char ) _Byte );
 }


template<> inline __wchar_t __cdecl _Maklocchr(char _Byte, __wchar_t *, const _Locinfo::_Cvtvec &
_Cvt) 
{ 
auto __wchar_t _Wc = L'\x0'; 
auto mbstate_t _Mbst1 = (0); 
_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, (&_Cvt)); 
return _Wc; 
} 
#line 621 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
template < class _Elem > inline
 _Elem * __cdecl _Maklocstr ( const char * _Ptr, _Elem *,
  const _Locinfo :: _Cvtvec & )
 {
 size_t _Count = :: strlen ( _Ptr ) + 1;
 _Elem * _Ptrdest = new _Elem [ _Count ];

#pragma warning(push)
#pragma warning(disable: 6011)

 for ( _Elem * _Ptrnext = _Ptrdest; 0 < _Count; -- _Count, ++ _Ptrnext, ++ _Ptr )
  * _Ptrnext = ( _Elem ) ( unsigned char ) * _Ptr;
 return ( _Ptrdest );
#pragma warning(pop)
 }


template<> inline __wchar_t *__cdecl _Maklocstr(const char *_Ptr, __wchar_t *, const _Locinfo::_Cvtvec &
_Cvt) 
{ 
auto size_t _Count; auto size_t _Count1; 
auto size_t _Wchars; 
auto const char *_Ptr1; 
auto int _Bytes; 
auto __wchar_t _Wc; 
auto mbstate_t _Mbst1 = (0); 

_Count1 = ::strlen(_Ptr) + (1); 
for (((_Count = _Count1), (_Wchars = (0))), (_Ptr1 = _Ptr); (0) < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) { 

if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, (&_Cvt))) <= 0) { 
break; }  }  
++_Wchars; 

auto __wchar_t *_Ptrdest = (new __wchar_t [_Wchars]); 
auto __wchar_t *_Ptrnext = _Ptrdest; 
auto mbstate_t _Mbst2 = (0); 
#pragma warning(push)
#pragma warning(disable: 6011)

for (; (0) < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) { 

if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, (&_Cvt))) <= 0) { 
break; }  }  
(*_Ptrnext) = L'\x0'; 
#pragma warning(pop)
return _Ptrdest; 
} 


#pragma warning(push)
#pragma warning(disable:4275)

class codecvt_base : public locale::facet { 




public: enum __cuda_ok { 
ok, partial, error, noconv}; 
typedef int result; 

codecvt_base(size_t _Refs = (0)) : locale::facet(_Refs) 

{ 
} 

bool always_noconv() const throw() 
{ 
return this->do_always_noconv(); 
} 

int max_length() const throw() 
{ 
return this->do_max_length(); 
} 

int encoding() const throw() 
{ 
return this->do_encoding(); 
} 

virtual ~codecvt_base() 
{ 
} 


protected: virtual bool do_always_noconv() const throw() 
{ 
return true; 
} 

virtual int do_max_length() const throw() 
{ 
return 1; 
} 

virtual int do_encoding() const throw() 
{ 
return 1; 
} 
}; 
#pragma warning(pop)


template < class _Elem,
 class _Byte,
 class _Statype >
 class codecvt
  : public codecvt_base
 {
public :
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in ( _Statype & _State,
  const _Byte * _First1, const _Byte * _Last1, const _Byte * & _Mid1,
  _Elem * _First2, _Elem * _Last2, _Elem * & _Mid2 ) const
  {
  return ( do_in ( _State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 ) );
  }

 result out ( _Statype & _State,
  const _Elem * _First1, const _Elem * _Last1, const _Elem * & _Mid1,
  _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const
  {
  return ( do_out ( _State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 ) );
  }

 result unshift ( _Statype & _State,
  _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const
  {
  return ( do_unshift ( _State, _First2, _Last2, _Mid2 ) );
  }

 int length ( const _Statype & _State, const _Byte * _First1,
  const _Byte * _Last1, size_t _Count ) const
  {
  return ( do_length ( _State, _First1, _Last1, _Count ) );
  }

  static locale :: id id;

 explicit codecvt ( size_t _Refs = 0 )
  : codecvt_base ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  codecvt ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : codecvt_base ( _Refs )
  {
  _Init ( _Lobj );
  }

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new codecvt < _Elem, _Byte, _Statype > (
    _Locinfo ( _Ploc -> name ( ) ) );
  return ( 2 );
  }

protected :
 virtual ~ codecvt ( )
  {
  }

protected :
 void _Init ( const _Locinfo & )
  {
  }

 virtual result do_in ( _Statype &,
  const _Byte * _First1, const _Byte *, const _Byte * & _Mid1,
  _Elem * _First2, _Elem *, _Elem * & _Mid2 ) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  return ( noconv );
  }

 virtual result do_out ( _Statype &,
  const _Elem * _First1, const _Elem *, const _Elem * & _Mid1,
  _Byte * _First2, _Byte *, _Byte * & _Mid2 ) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  return ( noconv );
  }

 virtual result do_unshift ( _Statype &,
  _Byte * _First2, _Byte *, _Byte * & _Mid2 ) const
  {
  _Mid2 = _First2;
  return ( noconv );
  }

 virtual int do_length ( const _Statype &, const _Byte * _First1,
  const _Byte * _Last1, size_t _Count ) const
  {
  return ( ( int ) ( _Count < ( size_t ) ( _Last1 - _First1 )
   ? _Count : _Last1 - _First1 ) );
  }
 };


template<class _Elem, class 
_Byte, class 
_Statype> locale::id 
codecvt< _Elem, _Byte, _Statype> ::id; 


template<> class codecvt< __wchar_t, char, int>  : public codecvt_base { 



public: typedef __wchar_t _Elem; 
typedef char _Byte; 
typedef _Mbstatet _Statype; 
typedef _Elem intern_type; 
typedef _Byte extern_type; 
typedef _Statype state_type; 

result in(_Statype &_State, const _Byte *
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
{ 
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 

} 

result out(_Statype &_State, const _Elem *
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 

} 

result unshift(_Statype &_State, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
return this->do_unshift(_State, _First2, _Last2, _Mid2); 

} 

int length(const _Statype &_State, const _Byte *_First1, const _Byte *
_Last1, size_t _Count) const 
{ 
return this->do_length(_State, _First1, _Last1, _Count); 
} 

static locale::id &__cdecl _Id_func(); 



static locale::id id; 
#line 885 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
explicit codecvt(size_t _Refs = (0)) : codecvt_base(_Refs) 

{ 
{ auto _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
} 

codecvt(const _Locinfo &_Lobj, size_t _Refs = (0)) : codecvt_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
_Ploc = 0) 
{ 
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
(*_Ppf) = new std::codecvt< __wchar_t, char, int> (((_Locinfo)(_Ploc->name()))); }  

return 2; 
} 


protected: virtual ~codecvt() 
{ 
} 


void _Init(const _Locinfo &_Lobj) 
{ 
(this->_Cvt) = _Lobj._Getcvt(); 
} 

virtual result do_in(_Statype &_State, const _Byte *
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
{ 
; 
; 
(_Mid1 = _First1), (_Mid2 = _First2); 
auto result _Ans = (((_Mid1) == _Last1) ? ok : partial); 
auto int _Bytes; 

while (((_Mid1) != _Last1) && ((_Mid2) != _Last2)) { 
switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1, (&_State), &(this->_Cvt))) 

{ 
case (-2): 
_Mid1 = _Last1; 
return _Ans; 

case (-1): 
return error; 

case 0: 
if ((*(_Mid2)) == ((_Elem)0)) { 
_Bytes = (int)::strlen(_Mid1) + 1; }  


default: 
if (_Bytes == (-3)) { 
_Bytes = 0; }  
_Mid1 += _Bytes; 
++_Mid2; 
_Ans = (ok); break;
}  }  
return _Ans; 
} 

virtual result do_out(_Statype &_State, const _Elem *
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
; 
; 
(_Mid1 = _First1), (_Mid2 = _First2); 
auto result _Ans = (((_Mid1) == _Last1) ? ok : partial); 
auto int _Bytes; 

while (((_Mid1) != _Last1) && ((_Mid2) != _Last2)) { 
if (((int)___mb_cur_max_func()) <= (_Last2 - _Mid2)) { 
if ((_Bytes = _Wcrtomb(_Mid2, *(_Mid1), (&_State), &(this->_Cvt))) < 0) { 

return error; } else { 

((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); }  } else 

{ 
auto _Byte _Buf[5]; 
auto _Statype _Stsave = (_State); 

if ((_Bytes = _Wcrtomb(_Buf, *(_Mid1), (&_State), &(this->_Cvt))) < 0) { 

return error; } else { 
if ((_Last2 - _Mid2) < _Bytes) 
{ 
_State = _Stsave; 
return _Ans; 
} else 

{ 
::memcpy_s(_Mid2, _Last2 - _Mid2, _Buf, _Bytes); 
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); 
}  }  
}  }  
return _Ans; 
} 

virtual result do_unshift(_Statype &_State, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
; 
_Mid2 = _First2; 
auto result _Ans = (ok); 
auto int _Bytes; 
auto _Byte _Buf[5]; 
auto _Statype _Stsave = (_State); 

if ((_Bytes = _Wcrtomb(_Buf, L'\x0', (&_State), &(this->_Cvt))) <= 0) { 
_Ans = (error); } else { 
if ((_Last2 - _Mid2) < (--_Bytes)) 
{ 
_State = _Stsave; 
_Ans = (partial); 
} else { 
if (0 < _Bytes) 
{ 
::memcpy_s(_Mid2, _Last2 - _Mid2, _Buf, _Bytes); 
_Mid2 += _Bytes; 
}  }  }  
return _Ans; 
} 

virtual int do_length(const _Statype &_State, const _Byte *_First1, const _Byte *
_Last1, size_t _Count) const 
{ 
#line 1028 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
; 
auto int _Wchars; 
auto const _Byte *_Mid1; 
auto _Statype _Mystate = (_State); 

for ((_Wchars = 0), (_Mid1 = _First1); (((unsigned)_Wchars) < _Count) && (_Mid1 != _Last1);) 

{ 
auto int _Bytes; 
auto _Elem _Ch; 

switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1, &_Mystate, &(this->_Cvt))) 

{ 
case (-2): 
return _Wchars; 

case (-1): 
return _Wchars; 

case 0: 
if (_Ch == ((_Elem)0)) { 
_Bytes = (int)::strlen(_Mid1) + 1; }  


default: 
if (_Bytes == (-3)) { 
_Bytes = 0; }  
_Mid1 += _Bytes; 
++_Wchars; break;
}  
}  
return _Wchars; 
#line 1062 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
} 

virtual bool do_always_noconv() const throw() 
{ 
return false; 
} 

virtual int do_max_length() const throw() 
{ 
return 5; 
} 


private: _Locinfo::_Cvtvec _Cvt; 
}; 



template<> class codecvt< unsigned short, char, int>  : public codecvt_base { 



public: typedef unsigned short _Elem; 
typedef char _Byte; 
typedef _Mbstatet _Statype; 
typedef _Elem intern_type; 
typedef _Byte extern_type; 
typedef _Statype state_type; 

result in(_Statype &_State, const _Byte *
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
{ 
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 

} 

result out(_Statype &_State, const _Elem *
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 

} 

result unshift(_Statype &_State, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
return this->do_unshift(_State, _First2, _Last2, _Mid2); 

} 

int length(const _Statype &_State, const _Byte *_First1, const _Byte *
_Last1, size_t _Count) const 
{ 
return this->do_length(_State, _First1, _Last1, _Count); 
} 

static locale::id &__cdecl _Id_func(); 



static locale::id id; 
#line 1127 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
explicit codecvt(size_t _Refs = (0)) : codecvt_base(_Refs) 

{ 
{ auto _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
} 

codecvt(const _Locinfo &_Lobj, size_t _Refs = (0)) : codecvt_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
_Ploc = 0) 
{ 
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
(*_Ppf) = new std::codecvt< unsigned short, char, int> (((_Locinfo)(_Ploc->name()))); }  

return 2; 
} 


protected: virtual ~codecvt() 
{ 
} 


codecvt(const char *_Locname, size_t _Refs = (0)) : codecvt_base(_Refs) 

{ 
{ auto _Locinfo _Lobj(_Locname); 
this->_Init(_Lobj); 
} 
} 

void _Init(const _Locinfo &_Lobj) 
{ 
(this->_Cvt) = _Lobj._Getcvt(); 
} 

virtual result do_in(_Statype &_State, const _Byte *
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
{ 
; 
; 
(_Mid1 = _First1), (_Mid2 = _First2); 
auto result _Ans = (((_Mid1) == _Last1) ? ok : partial); 
auto int _Bytes; 

while (((_Mid1) != _Last1) && ((_Mid2) != _Last2)) { 
switch (_Bytes = _Mbrtowc((__wchar_t *)(_Mid2), _Mid1, _Last1 - _Mid1, (&_State), &(this->_Cvt))) 

{ 
case (-2): 
_Mid1 = _Last1; 
return _Ans; 

case (-1): 
return error; 

case 0: 
if ((*(_Mid2)) == ((_Elem)0)) { 
_Bytes = (int)::strlen(_Mid1) + 1; }  


default: 
if (_Bytes == (-3)) { 
_Bytes = 0; }  
_Mid1 += _Bytes; 
++_Mid2; 
_Ans = (ok); break;
}  }  
return _Ans; 
} 

virtual result do_out(_Statype &_State, const _Elem *
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
; 
; 
(_Mid1 = _First1), (_Mid2 = _First2); 
auto result _Ans = (((_Mid1) == _Last1) ? ok : partial); 
auto int _Bytes; 

while (((_Mid1) != _Last1) && ((_Mid2) != _Last2)) { 
if (5 <= (_Last2 - _Mid2)) { 
if ((_Bytes = _Wcrtomb(_Mid2, *(_Mid1), (&_State), &(this->_Cvt))) < 0) { 

return error; } else { 

((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); }  } else 

{ 
auto _Byte _Buf[5]; 
auto _Statype _Stsave = (_State); 

if ((_Bytes = _Wcrtomb(_Buf, *(_Mid1), (&_State), &(this->_Cvt))) < 0) { 

return error; } else { 
if ((_Last2 - _Mid2) < _Bytes) 
{ 
_State = _Stsave; 
return _Ans; 
} else 

{ 
::memcpy_s(_Mid2, _Last2 - _Mid2, _Buf, _Bytes); 
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); 
}  }  
}  }  
return _Ans; 
} 

virtual result do_unshift(_Statype &_State, _Byte *
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
{ 
; 
_Mid2 = _First2; 
auto result _Ans = (ok); 
auto int _Bytes; 
auto _Byte _Buf[5]; 
auto _Statype _Stsave = (_State); 

if ((_Bytes = _Wcrtomb(_Buf, L'\x0', (&_State), &(this->_Cvt))) <= 0) { 
_Ans = (error); } else { 
if ((_Last2 - _Mid2) < (--_Bytes)) 
{ 
_State = _Stsave; 
_Ans = (partial); 
} else { 
if (0 < _Bytes) 
{ 
::memcpy_s(_Mid2, _Last2 - _Mid2, _Buf, _Bytes); 
_Mid2 += _Bytes; 
}  }  }  
return _Ans; 
} 

virtual int do_length(const _Statype &_State, const _Byte *_First1, const _Byte *
_Last1, size_t _Count) const 
{ 
; 
auto int _Wchars; 
auto const _Byte *_Mid1; 
auto _Statype _Mystate = (_State); 

for ((_Wchars = 0), (_Mid1 = _First1); (((unsigned)_Wchars) < _Count) && (_Mid1 != _Last1);) 

{ 
auto int _Bytes; 
auto _Elem _Ch; 

switch (_Bytes = _Mbrtowc((__wchar_t *)(&_Ch), _Mid1, _Last1 - _Mid1, &_Mystate, &(this->_Cvt))) 

{ 
case (-2): 
return _Wchars; 

case (-1): 
return _Wchars; 

case 0: 
if (_Ch == ((_Elem)0)) { 
_Bytes = (int)::strlen(_Mid1) + 1; }  


default: 
if (_Bytes == (-3)) { 
_Bytes = 0; }  
_Mid1 += _Bytes; 
++_Wchars; break;
}  
}  
return _Wchars; 
} 

virtual bool do_always_noconv() const throw() 
{ 
return false; 
} 

virtual int do_max_length() const throw() 
{ 
return 5; 
} 


private: _Locinfo::_Cvtvec _Cvt; 
}; 
#line 1323 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
template < class _Elem,
 class _Byte,
 class _Statype >
 class codecvt_byname
  : public codecvt < _Elem, _Byte, _Statype >
 {
public :
 explicit codecvt_byname ( const char * _Locname, size_t _Refs = 0 )
  : codecvt < _Elem, _Byte, _Statype > ( _Locname, _Refs )
  {
  }

protected :
 virtual ~ codecvt_byname ( )
  {
  }
 };

#pragma warning(push)
#pragma warning(disable:4275)

struct ctype_base : public locale::facet { 



enum __cuda_alnum { 
alnum = 263, alpha = 259, 
cntrl = 32, digit = 4, graph = 279, 
lower = 2, print = 471, 
punct = 16, space = 72, upper = 1, 
xdigit = 128}; 
typedef short mask; 

ctype_base(size_t _Refs = (0)) : locale::facet(_Refs) 

{ 
} 

virtual ~ctype_base() 
{ 
} 


protected: static void __cdecl _Xran() 
{ 
throw ((out_of_range)("out_of_range in ctype<T>")); 
} 
}; 
#pragma warning(pop)


template < class _Elem >
 class ctype
  : public ctype_base
 {
public :
 typedef _Elem char_type;

 bool is ( mask _Maskval, _Elem _Ch ) const
  {
  return ( do_is ( _Maskval, _Ch ) );
  }

 const _Elem * is ( const _Elem * _First, const _Elem * _Last,
  mask * _Dest ) const
  {
  return ( do_is ( _First, _Last, _Dest ) );
  }

 const _Elem * scan_is ( mask _Maskval, const _Elem * _First,
  const _Elem * _Last ) const
  {
  return ( do_scan_is ( _Maskval, _First, _Last ) );
  }

 const _Elem * scan_not ( mask _Maskval, const _Elem * _First,
  const _Elem * _Last ) const
  {
  return ( do_scan_not ( _Maskval, _First, _Last ) );
  }

 _Elem tolower ( _Elem _Ch ) const
  {
  return ( do_tolower ( _Ch ) );
  }

 const _Elem * tolower ( _Elem * _First, const _Elem * _Last ) const
  {
  return ( do_tolower ( _First, _Last ) );
  }

 _Elem toupper ( _Elem _Ch ) const
  {
  return ( do_toupper ( _Ch ) );
  }

 const _Elem * toupper ( _Elem * _First, const _Elem * _Last ) const
  {
  return ( do_toupper ( _First, _Last ) );
  }

 _Elem widen ( char _Byte ) const
  {
  return ( do_widen ( _Byte ) );
  }

 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 const char * widen ( const char * _First, const char * _Last,
  _Elem * _Dest ) const
  {
#pragma warning(push)
#pragma warning(disable:4996)
  return ( do_widen ( _First, _Last, _Dest ) );
#pragma warning(pop)
  }

 const char * _Widen_s ( const char * _First, const char * _Last,
  _Elem * _Dest, size_t _Dest_size ) const
  {
  return ( _Do_widen_s ( _First, _Last, _Dest, _Dest_size ) );
  }

 char narrow ( _Elem _Ch, char _Dflt = '\000' ) const
  {
  return ( do_narrow ( _Ch, _Dflt ) );
  }

 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 const _Elem * narrow ( const _Elem * _First, const _Elem * _Last,
  char _Dflt, char * _Dest ) const
  {

#pragma warning(push)
#pragma warning(disable:4996)
  return ( do_narrow ( _First, _Last, _Dflt, _Dest ) );
#pragma warning(pop)
  }

 const _Elem * _Narrow_s ( const _Elem * _First, const _Elem * _Last,
  char _Dflt, char * _Dest, size_t _Dest_size ) const
  {
  return ( _Do_narrow_s ( _First, _Last, _Dflt, _Dest, _Dest_size ) );
  }

  static locale :: id id;

 explicit ctype ( size_t _Refs = 0 )
  : ctype_base ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  ctype ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : ctype_base ( _Refs )
  {
  _Init ( _Lobj );
  }

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new ctype < _Elem > (
    _Locinfo ( _Ploc -> name ( ) ) );
  return ( 2 );
  }

protected :
 virtual ~ ctype ( )
  {
  if ( _Ctype . _Delfl )
   free ( ( void * ) _Ctype . _Table );
  }

protected :
 void _Init ( const _Locinfo & _Lobj )
  {
  _Ctype = _Lobj . _Getctype ( );
  }

 virtual bool do_is ( mask _Maskval, _Elem _Ch ) const
  {
  return ( ( _Ctype . _Table [ ( unsigned char ) narrow ( _Ch ) ]
   & _Maskval ) != 0 );
  }

 virtual const _Elem * do_is ( const _Elem * _First, const _Elem * _Last,
  mask * _Dest ) const
  {
  ;
  ;
  for (; _First != _Last; ++ _First, ++ _Dest )
   * _Dest = _Ctype . _Table [ ( unsigned char ) narrow ( * _First ) ];
  return ( _First );
  }

 virtual const _Elem * do_scan_is ( mask _Maskval,
  const _Elem * _First, const _Elem * _Last ) const
  {
  ;
  for (; _First != _Last && ! is ( _Maskval, * _First ); ++ _First )
   ;
  return ( _First );
  }

 virtual const _Elem * do_scan_not ( mask _Maskval,
  const _Elem * _First, const _Elem * _Last ) const
  {
  ;
  for (; _First != _Last && is ( _Maskval, * _First ); ++ _First )
   ;
  return ( _First );
  }

 virtual _Elem do_tolower ( _Elem _Ch ) const
  {
  unsigned char _Byte = ( unsigned char ) narrow ( _Ch, '\000' );
  if ( _Byte == '\000' )
   return ( _Ch );
  else
   return ( widen ( ( char ) _Tolower ( _Byte, & _Ctype ) ) );
  }

 virtual const _Elem * do_tolower ( _Elem * _First, const _Elem * _Last ) const
  {
  ;
  for (; _First != _Last; ++ _First )
   {
   unsigned char _Byte = ( unsigned char ) narrow ( * _First, '\000' );
   if ( _Byte != '\000' )
    * _First = ( widen ( ( char ) _Tolower ( _Byte, & _Ctype ) ) );
   }
  return ( ( const _Elem * ) _First );
  }

 virtual _Elem do_toupper ( _Elem _Ch ) const
  {
  unsigned char _Byte = ( unsigned char ) narrow ( _Ch, '\000' );
  if ( _Byte == '\000' )
   return ( _Ch );
  else
   return ( widen ( ( char ) _Toupper ( _Byte, & _Ctype ) ) );
  }

 virtual const _Elem * do_toupper ( _Elem * _First, const _Elem * _Last ) const
  {
  ;
  for (; _First != _Last; ++ _First )
   {
   unsigned char _Byte = ( unsigned char ) narrow ( * _First, '\000' );
   if ( _Byte != '\000' )
    * _First = ( widen ( ( char ) _Toupper ( _Byte, & _Ctype ) ) );
   }
  return ( ( const _Elem * ) _First );
  }

 virtual _Elem do_widen ( char _Byte ) const
  {
  return ( _Maklocchr ( _Byte, ( _Elem * ) 0, _Cvt ) );
  }

 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 virtual const char * do_widen ( const char * _First,
  const char * _Last, _Elem * _Dest ) const
  {

  return _Do_widen_s ( _First, _Last, _Dest, _Last - _First );
  }

 virtual const char * _Do_widen_s ( const char * _First,
  const char * _Last, _Elem * _Dest, size_t _Dest_size ) const
  {
  ;
  ;
  { if ( ! ( _Dest_size >= ( size_t ) ( _Last - _First ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  for (; _First != _Last; ++ _First, ++ _Dest )
   * _Dest = _Maklocchr ( * _First, ( _Elem * ) 0, _Cvt );
  return ( _First );
  }

 char _Donarrow ( _Elem _Ch, char _Dflt ) const
  {
  char _Byte;
  if ( _Ch == ( _Elem ) 0 )
   return ( '\000' );
  else if ( ( _Byte = _Maklocbyte ( ( _Elem ) _Ch, _Cvt ) ) == '\000' )
   return ( _Dflt );
  else
   return ( _Byte );
  }

 virtual char do_narrow ( _Elem _Ch, char _Dflt ) const
  {
  return ( _Donarrow ( _Ch, _Dflt ) );
  }

 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 virtual const _Elem * do_narrow ( const _Elem * _First,
  const _Elem * _Last, char _Dflt, char * _Dest ) const
  {

  return _Do_narrow_s ( _First, _Last, _Dflt, _Dest, _Last - _First );
  }

 virtual const _Elem * _Do_narrow_s ( const _Elem * _First,
  const _Elem * _Last, char _Dflt,
      char * _Dest,
  size_t _Dest_size ) const
  {
  ;
  ;
  { if ( ! ( _Dest_size >= ( size_t ) ( _Last - _First ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  for (; _First != _Last; ++ _First, ++ _Dest )
   * _Dest = _Donarrow ( * _First, _Dflt );
  return ( _First );
  }

private :
 _Locinfo :: _Ctypevec _Ctype;
 _Locinfo :: _Cvtvec _Cvt;
 };


template<class _Elem> locale::id 
ctype< _Elem> ::id; 


template<> class ctype< char>  : public ctype_base { 


typedef std::ctype< char>  _Myt; 


public: typedef char _Elem; 
typedef _Elem char_type; 

bool is(mask _Maskval, _Elem _Ch) const 
{ 
return ((((this->_Ctype)._Table)[(unsigned char)_Ch]) & _Maskval) != 0; 
} 

const _Elem *is(const _Elem *_First, const _Elem *
_Last, mask *_Dest) const 
{ 
; 
; 
for (; _First != _Last; (++_First), (++_Dest)) { 
(*_Dest) = ((this->_Ctype)._Table)[(unsigned char)(*_First)]; }  
return _First; 
} 

const _Elem *scan_is(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
; 
for (; (_First != _Last) && (!this->is(_Maskval, *_First)); ++_First) { 
; }  
return _First; 
} 

const _Elem *scan_not(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
; 
for (; (_First != _Last) && this->is(_Maskval, *_First); ++_First) { 
; }  
return _First; 
} 

_Elem tolower(_Elem _Ch) const 
{ 
return this->do_tolower(_Ch); 
} 

const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
{ 
return this->do_tolower(_First, _Last); 
} 

_Elem toupper(_Elem _Ch) const 
{ 
return this->do_toupper(_Ch); 
} 

const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
{ 
return this->do_toupper(_First, _Last); 
} 

_Elem widen(char _Byte) const 
{ 
return this->do_widen(_Byte); 
} 


__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *widen(const char *_First, const char *_Last, _Elem *
_Dest) const 
{ 

#pragma warning(push)
#pragma warning(disable:4996)
return this->do_widen(_First, _Last, _Dest); 
#pragma warning(pop)
} 

const _Elem *_Widen_s(const char *_First, const char *_Last, _Elem *
_Dest, size_t _Dest_size) const 
{ 
return this->_Do_widen_s(_First, _Last, _Dest, _Dest_size); 
} 

_Elem narrow(_Elem _Ch, char _Dflt = '\000') const 
{ 
return this->do_narrow(_Ch, _Dflt); 
} 


__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest) const 
{ 

#pragma warning(push)
#pragma warning(disable:4996)
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#pragma warning(pop)
} 

const _Elem *_Narrow_s(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest, size_t 
_Dest_size) const 
{ 
return this->_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size); 
} 

static locale::id &__cdecl _Id_func(); 



static locale::id id; 
#line 1766 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
explicit ctype(const mask *_Table = 0, bool 
_Deletetable = false, size_t 
_Refs = (0)) : ctype_base(_Refs) 

{ 
{ auto _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
if (_Table != (0)) 
{ 
this->_Tidy(); 
((this->_Ctype)._Table) = _Table; 
((this->_Ctype)._Delfl) = _Deletetable ? (-1) : 0; 
}  
} 

ctype(const _Locinfo &_Lobj, size_t _Refs = (0)) : ctype_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
_Ploc = 0) 
{ 
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
(*_Ppf) = new std::ctype< char> (((_Locinfo)(_Ploc->name()))); }  

return 2; 
} 

static const size_t table_size = (1 << 8); 


protected: virtual ~ctype() 
{ 
this->_Tidy(); 
} 


void _Init(const _Locinfo &_Lobj) 
{ 
(this->_Ctype) = _Lobj._Getctype(); 
} 

void _Tidy() 
{ 
if (0 < ((this->_Ctype)._Delfl)) { 
free((void *)((this->_Ctype)._Table)); } else { 
if (((this->_Ctype)._Delfl) < 0) { 
delete [] ((void *)((this->_Ctype)._Table)); }  }  
} 

virtual _Elem do_tolower(_Elem _Ch) const 
{ 
return (_Elem)_Tolower((unsigned char)_Ch, &(this->_Ctype)); 
} 

virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
_Last) const 
{ 
; 
for (; _First != _Last; ++_First) { 
(*_First) = (_Elem)_Tolower((unsigned char)(*_First), &(this->_Ctype)); }  
return (const _Elem *)_First; 
} 

virtual _Elem do_toupper(_Elem _Ch) const 
{ 
return (_Elem)_Toupper((unsigned char)_Ch, &(this->_Ctype)); 
} 

virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
_Last) const 
{ 
; 
for (; _First != _Last; ++_First) { 
(*_First) = (_Elem)_Toupper((unsigned char)(*_First), &(this->_Ctype)); }  
return (const _Elem *)_First; 
} 

virtual _Elem do_widen(char _Byte) const 
{ 
return _Byte; 
} 


virtual __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *do_widen(const char *_First, const char *
_Last, _Elem *_Dest) const 
{ 

return this->_Do_widen_s(_First, _Last, _Dest, _Last - _First); 
} 

virtual const _Elem *_Do_widen_s(const char *_First, const char *
_Last, _Elem *_Dest, size_t _Dest_size) const 
{ 
; 
; 
{ if (!(_Dest_size >= ((unsigned)(_Last - _First)))) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 
::memcpy_s(_Dest, _Dest_size, _First, _Last - _First); 
return _Last; 
} 

virtual _Elem do_narrow(_Elem _Ch, char) const 
{ 
return _Ch; 
} 


virtual __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *do_narrow(const _Elem *_First, const _Elem *
_Last, char _Dflt, char *
_Dest) const 
{ 

return this->_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First); 
} 

virtual const _Elem *_Do_narrow_s(const _Elem *_First, const _Elem *
_Last, char, char *_Dest, size_t 
_Dest_size) const 
{ 
; 
; 
{ if (!(_Dest_size >= ((unsigned)(_Last - _First)))) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 
::memcpy_s(_Dest, _Dest_size, _First, _Last - _First); 
return _Last; 
} 

const mask *table() const throw() 
{ 
return (this->_Ctype)._Table; 
} 

static const mask *__cdecl classic_table() throw() 
{ 
auto const _Myt &_Ctype_fac = use_facet< std::ctype< char> > (locale::classic()); 
return _Ctype_fac.table(); 
} 


private: _Locinfo::_Ctypevec _Ctype; 
}; 


template<> class ctype< __wchar_t>  : public ctype_base { 


typedef std::ctype< __wchar_t>  _Myt; 


public: typedef __wchar_t _Elem; 
typedef _Elem char_type; 

bool is(mask _Maskval, _Elem _Ch) const 
{ 
return this->do_is(_Maskval, _Ch); 
} 

const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
_Dest) const 
{ 
return this->do_is(_First, _Last, _Dest); 
} 

const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
_Last) const 
{ 
return this->do_scan_is(_Maskval, _First, _Last); 
} 

const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
_Last) const 
{ 
return this->do_scan_not(_Maskval, _First, _Last); 
} 

_Elem tolower(_Elem _Ch) const 
{ 
return this->do_tolower(_Ch); 
} 

const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
{ 
return this->do_tolower(_First, _Last); 
} 

_Elem toupper(_Elem _Ch) const 
{ 
return this->do_toupper(_Ch); 
} 

const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
{ 
return this->do_toupper(_First, _Last); 
} 

_Elem widen(char _Byte) const 
{ 
return this->do_widen(_Byte); 
} 


__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *widen(const char *_First, const char *_Last, _Elem *
_Dest) const 
{ 

#pragma warning(push)
#pragma warning(disable:4996)
return this->do_widen(_First, _Last, _Dest); 
#pragma warning(pop)
} 

const char *_Widen_s(const char *_First, const char *_Last, _Elem *
_Dest, size_t _Dest_size) const 
{ 
return this->_Do_widen_s(_First, _Last, _Dest, _Dest_size); 
} 

char narrow(_Elem _Ch, char _Dflt = '\000') const 
{ 
return this->do_narrow(_Ch, _Dflt); 
} 


__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest) const 
{ 

#pragma warning(push)
#pragma warning(disable:4996)
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#pragma warning(pop)
} 

const _Elem *_Narrow_s(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest, size_t 
_Dest_size) const 
{ 
return this->_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size); 
} 

static locale::id &__cdecl _Id_func(); 



static locale::id id; 
#line 2015 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
explicit ctype(size_t _Refs = (0)) : ctype_base(_Refs) 

{ 
{ auto _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
} 

ctype(const _Locinfo &_Lobj, size_t _Refs = (0)) : ctype_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
_Ploc = 0) 
{ 
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
(*_Ppf) = new std::ctype< __wchar_t> (((_Locinfo)(_Ploc->name()))); }  

return 2; 
} 


protected: virtual ~ctype() 
{ 
if ((this->_Ctype)._Delfl) { 
free((void *)((this->_Ctype)._Table)); }  
} 


void _Init(const _Locinfo &_Lobj) 
{ 
(this->_Ctype) = _Lobj._Getctype(); 
(this->_Cvt) = _Lobj._Getcvt(); 
} 

virtual bool do_is(mask _Maskval, _Elem _Ch) const 
{ 
return ((::_Getwctype(_Ch, &(this->_Ctype))) & _Maskval) != 0; 
} 

virtual const __wchar_t *do_is(const _Elem *_First, const _Elem *
_Last, mask *_Dest) const 
{ 
; 
; 
return ::_Getwctypes(_First, _Last, _Dest, &(this->_Ctype)); 
} 

virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
; 
for (; (_First != _Last) && (!this->is(_Maskval, *_First)); ++_First) { 
; }  
return _First; 
} 

virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
; 
for (; (_First != _Last) && this->is(_Maskval, *_First); ++_First) { 
; }  
return _First; 
} 

virtual _Elem do_tolower(_Elem _Ch) const 
{ 
return _Towlower(_Ch, &(this->_Ctype)); 
} 

virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
_Last) const 
{ 
; 
for (; _First != _Last; ++_First) { 
(*_First) = _Towlower(*_First, &(this->_Ctype)); }  
return (const _Elem *)_First; 
} 

virtual _Elem do_toupper(_Elem _Ch) const 
{ 
return _Towupper(_Ch, &(this->_Ctype)); 
} 

virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
_Last) const 
{ 
; 
for (; _First != _Last; ++_First) { 
(*_First) = _Towupper(*_First, &(this->_Ctype)); }  
return (const _Elem *)_First; 
} 

_Elem _Dowiden(char _Byte) const 
{ 
auto mbstate_t _Mbst = (0); 
auto __wchar_t _Wc; 
return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &(this->_Cvt)) < 0) ? ((__wchar_t)((wint_t)65535)) : _Wc; 

} 

virtual _Elem do_widen(char _Byte) const 
{ 
return this->_Dowiden(_Byte); 
} 


virtual __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *do_widen(const char *_First, const char *
_Last, _Elem *_Dest) const 
{ 

return this->_Do_widen_s(_First, _Last, _Dest, _Last - _First); 
} 

virtual const char *_Do_widen_s(const char *_First, const char *
_Last, _Elem *_Dest, size_t _Dest_size) const 
{ 
; 
; 
{ if (!(_Dest_size >= ((unsigned)(_Last - _First)))) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 
for (; _First != _Last; (++_First), (++_Dest)) { 
(*_Dest) = this->_Dowiden(*_First); }  
return _First; 
} 

char _Donarrow(_Elem _Ch, char _Dflt) const 
{ 
auto char _Buf[5]; 
auto mbstate_t _Mbst = (0); 
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(this->_Cvt)) != 1) ? _Dflt : ((_Buf)[0]); 

} 

virtual char do_narrow(_Elem _Ch, char _Dflt) const 
{ 
return this->_Donarrow(_Ch, _Dflt); 
} 


virtual __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *do_narrow(const _Elem *_First, const _Elem *
_Last, char _Dflt, char *
_Dest) const 
{ 

return this->_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First); 
} 

virtual const _Elem *_Do_narrow_s(const _Elem *_First, const _Elem *
_Last, char _Dflt, char *
_Dest, size_t 
_Dest_size) const 
{ 
; 
; 
{ if (!(_Dest_size >= ((unsigned)(_Last - _First)))) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 
for (; _First != _Last; (++_First), (++_Dest)) { 
(*_Dest) = this->_Donarrow(*_First, _Dflt); }  
return _First; 
} 


private: _Locinfo::_Ctypevec _Ctype; 
_Locinfo::_Cvtvec _Cvt; 
}; 



template<> class ctype< unsigned short>  : public ctype_base { 


typedef std::ctype< unsigned short>  _Myt; 


public: typedef unsigned short _Elem; 
typedef _Elem char_type; 

bool is(mask _Maskval, _Elem _Ch) const 
{ 
return this->do_is(_Maskval, _Ch); 
} 

const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
_Dest) const 
{ 
return this->do_is(_First, _Last, _Dest); 
} 

const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
_Last) const 
{ 
return this->do_scan_is(_Maskval, _First, _Last); 
} 

const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
_Last) const 
{ 
return this->do_scan_not(_Maskval, _First, _Last); 
} 

_Elem tolower(_Elem _Ch) const 
{ 
return this->do_tolower(_Ch); 
} 

const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
{ 
return this->do_tolower(_First, _Last); 
} 

_Elem toupper(_Elem _Ch) const 
{ 
return this->do_toupper(_Ch); 
} 

const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
{ 
return this->do_toupper(_First, _Last); 
} 

_Elem widen(char _Byte) const 
{ 
return this->do_widen(_Byte); 
} 


__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *widen(const char *_First, const char *_Last, _Elem *
_Dest) const 
{ 

#pragma warning(push)
#pragma warning(disable:4996)
return this->do_widen(_First, _Last, _Dest); 
#pragma warning(pop)
} 

const char *_Widen_s(const char *_First, const char *_Last, _Elem *
_Dest, size_t _Dest_size) const 
{ 
return this->_Do_widen_s(_First, _Last, _Dest, _Dest_size); 
} 

char narrow(_Elem _Ch, char _Dflt = '\000') const 
{ 
return this->do_narrow(_Ch, _Dflt); 
} 


__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest) const 
{ 

#pragma warning(push)
#pragma warning(disable:4996)
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#pragma warning(pop)
} 

const _Elem *_Narrow_s(const _Elem *_First, const _Elem *_Last, char 
_Dflt, char *_Dest, size_t 
_Dest_size) const 
{ 
return this->_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size); 
} 

static locale::id &__cdecl _Id_func(); 



static locale::id id; 
#line 2289 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
explicit ctype(size_t _Refs = (0)) : ctype_base(_Refs) 

{ 
{ auto _Locinfo _Lobj; 
this->_Init(_Lobj); 
} 
} 

ctype(const _Locinfo &_Lobj, size_t _Refs = (0)) : ctype_base(_Refs) 

{ 
this->_Init(_Lobj); 
} 

static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
_Ploc = 0) 
{ 
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
(*_Ppf) = new std::ctype< unsigned short> (((_Locinfo)(_Ploc->name()))); }  

return 2; 
} 


protected: virtual ~ctype() 
{ 
if ((this->_Ctype)._Delfl) { 
free((void *)((this->_Ctype)._Table)); }  
} 


ctype(const char *_Locname, size_t _Refs = (0)) : ctype_base(_Refs) 

{ 
{ auto _Locinfo _Lobj(_Locname); 
this->_Init(_Lobj); 
} 
} 

void _Init(const _Locinfo &_Lobj) 
{ 
(this->_Ctype) = _Lobj._Getctype(); 
(this->_Cvt) = _Lobj._Getcvt(); 
} 

virtual bool do_is(mask _Maskval, _Elem _Ch) const 
{ 
return ((::_Getwctype(_Ch, &(this->_Ctype))) & _Maskval) != 0; 
} 

virtual const _Elem *do_is(const _Elem *_First, const _Elem *
_Last, mask *_Dest) const 
{ 
; 
; 
return (const _Elem *)::_Getwctypes((const __wchar_t *)_First, (const __wchar_t *)_Last, _Dest, &(this->_Ctype)); 

} 

virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
; 
for (; (_First != _Last) && (!this->is(_Maskval, *_First)); ++_First) { 
; }  
return _First; 
} 

virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *
_First, const _Elem *_Last) const 
{ 
; 
for (; (_First != _Last) && this->is(_Maskval, *_First); ++_First) { 
; }  
return _First; 
} 

virtual _Elem do_tolower(_Elem _Ch) const 
{ 
return _Towlower(_Ch, &(this->_Ctype)); 
} 

virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
_Last) const 
{ 
; 
for (; _First != _Last; ++_First) { 
(*_First) = _Towlower(*_First, &(this->_Ctype)); }  
return (const _Elem *)_First; 
} 

virtual _Elem do_toupper(_Elem _Ch) const 
{ 
return _Towupper(_Ch, &(this->_Ctype)); 
} 

virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
_Last) const 
{ 
; 
for (; _First != _Last; ++_First) { 
(*_First) = _Towupper(*_First, &(this->_Ctype)); }  
return (const _Elem *)_First; 
} 

_Elem _Dowiden(char _Byte) const 
{ 
auto mbstate_t _Mbst = (0); 
auto unsigned short _Wc; 
return (_Mbrtowc((__wchar_t *)(&_Wc), &_Byte, 1, &_Mbst, &(this->_Cvt)) < 0) ? ((unsigned short)((wint_t)65535)) : _Wc; 

} 

virtual _Elem do_widen(char _Byte) const 
{ 
return this->_Dowiden(_Byte); 
} 


virtual __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const char *do_widen(const char *_First, const char *
_Last, _Elem *_Dest) const 
{ 

return this->_Do_widen_s(_First, _Last, _Dest, _Last - _First); 
} 

virtual const char *_Do_widen_s(const char *_First, const char *
_Last, _Elem *_Dest, size_t _Dest_size) const 
{ 
; 
; 
{ if (!(_Dest_size >= ((unsigned)(_Last - _First)))) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 
for (; _First != _Last; (++_First), (++_Dest)) { 
(*_Dest) = this->_Dowiden(*_First); }  
return _First; 
} 

char _Donarrow(_Elem _Ch, char _Dflt) const 
{ 
auto char _Buf[5]; 
auto mbstate_t _Mbst = (0); 
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(this->_Cvt)) != 1) ? _Dflt : ((_Buf)[0]); 

} 

virtual char do_narrow(_Elem _Ch, char _Dflt) const 
{ 
return this->_Donarrow(_Ch, _Dflt); 
} 


virtual __declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")) const _Elem *do_narrow(const _Elem *_First, const _Elem *
_Last, char _Dflt, char *_Dest) const 
{ 

return this->_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First); 
} 

virtual const _Elem *_Do_narrow_s(const _Elem *_First, const _Elem *
_Last, char _Dflt, char *
_Dest, size_t 
_Dest_size) const 
{ 
; 
; 
{ if (!(_Dest_size >= ((unsigned)(_Last - _First)))) { (void)0; ::_invalid_parameter_noinfo(); }  ; } ; 
for (; _First != _Last; (++_First), (++_Dest)) { 
(*_Dest) = this->_Donarrow(*_First, _Dflt); }  
return _First; 
} 


private: _Locinfo::_Ctypevec _Ctype; 
_Locinfo::_Cvtvec _Cvt; 
}; 
#line 2467 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
template < class _Elem >
 class ctype_byname
 : public ctype < _Elem >
 {
public :
 explicit ctype_byname ( const char * _Locname, size_t _Refs = 0 )
  : ctype < _Elem > ( _Locname, _Refs )
  {
  }

protected :
 virtual ~ ctype_byname ( )
  {
  }
 };


template<> class ctype_byname< char>  : public ctype< char>  { 



public: explicit ctype_byname(const char *_Locname, size_t _Refs = (0)) : std::ctype< char> (_Locname, _Refs) 

{ 
} 


protected: virtual ~ctype_byname() 
{ 
} 
}; 
#line 2504 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
}


#pragma warning(pop)
#line 11 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xiosbase"
#pragma warning(push,3)
#pragma warning(disable:4412)
#line 2508 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocale"
#pragma pack ( pop )
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xiosbase"
#pragma pack ( push, 8 )
#line 15 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xiosbase"
namespace std { 
#line 42 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xiosbase"
template<class _Dummy> 
class _Iosb { 


public: enum _Dummy_enum { _Dummy_enum_val = 1}; 

enum _Fmtflags { 

_Fmtmask = 65535, _Fmtzero = 0}; 

static const _Fmtflags skipws = ((_Fmtflags)1); 
static const _Fmtflags unitbuf = ((_Fmtflags)2); 
static const _Fmtflags uppercase = ((_Fmtflags)4); 
static const _Fmtflags showbase = ((_Fmtflags)8); 
static const _Fmtflags showpoint = ((_Fmtflags)16); 
static const _Fmtflags showpos = ((_Fmtflags)32); 
static const _Fmtflags left = ((_Fmtflags)64); 
static const _Fmtflags right = ((_Fmtflags)128); 
static const _Fmtflags internal = ((_Fmtflags)256); 
static const _Fmtflags dec = ((_Fmtflags)512); 
static const _Fmtflags oct = ((_Fmtflags)1024); 
static const _Fmtflags hex = ((_Fmtflags)2048); 
static const _Fmtflags scientific = ((_Fmtflags)4096); 
static const _Fmtflags fixed = ((_Fmtflags)8192); 

static const _Fmtflags hexfloat = ((_Fmtflags)12288); 


static const _Fmtflags boolalpha = ((_Fmtflags)16384); 
static const _Fmtflags _Stdio = ((_Fmtflags)32768); 
static const _Fmtflags adjustfield = ((_Fmtflags)((64 | 128) | 256)); 

static const _Fmtflags basefield = ((_Fmtflags)((512 | 1024) | 2048)); 

static const _Fmtflags floatfield = ((_Fmtflags)(4096 | 8192)); 


enum _Iostate { 

_Statmask = 23}; 

static const _Iostate goodbit = ((_Iostate)0); 
static const _Iostate eofbit = ((_Iostate)1); 
static const _Iostate failbit = ((_Iostate)2); 
static const _Iostate badbit = ((_Iostate)4); 
static const _Iostate _Hardfail = ((_Iostate)16); 

enum _Openmode { 

_Openmask = 255}; 

static const _Openmode in = ((_Openmode)1); 
static const _Openmode out = ((_Openmode)2); 
static const _Openmode ate = ((_Openmode)4); 
static const _Openmode app = ((_Openmode)8); 
static const _Openmode trunc = ((_Openmode)16); 
static const _Openmode _Nocreate = ((_Openmode)64); 
static const _Openmode _Noreplace = ((_Openmode)128); 
static const _Openmode binary = ((_Openmode)32); 

enum _Seekdir { 

_Seekmask = 3}; 
static const _Seekdir beg = ((_Seekdir)0); 
static const _Seekdir cur = ((_Seekdir)1); 
static const _Seekdir end = ((_Seekdir)2); 


enum __cuda__Openprot { 
_Openprot = 64}; 
}; 

template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::skipws; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::unitbuf; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::uppercase; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::showbase; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::showpoint; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::showpos; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::left; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::right; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::internal; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::dec; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::oct; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::hex; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::scientific; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::fixed; 

template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 

_Iosb< _Dummy> ::hexfloat; 

template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::boolalpha; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::_Stdio; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::adjustfield; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::basefield; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
_Iosb< _Dummy> ::floatfield; 

template<class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
_Iosb< _Dummy> ::goodbit; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
_Iosb< _Dummy> ::eofbit; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
_Iosb< _Dummy> ::failbit; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
_Iosb< _Dummy> ::badbit; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
_Iosb< _Dummy> ::_Hardfail; 

template<class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
_Iosb< _Dummy> ::in; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
_Iosb< _Dummy> ::out; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
_Iosb< _Dummy> ::ate; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
_Iosb< _Dummy> ::app; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
_Iosb< _Dummy> ::trunc; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
_Iosb< _Dummy> ::_Nocreate; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
_Iosb< _Dummy> ::_Noreplace; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
_Iosb< _Dummy> ::binary; 

template<class _Dummy> const typename _Iosb< _Dummy> ::_Seekdir 
_Iosb< _Dummy> ::beg; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Seekdir 
_Iosb< _Dummy> ::cur; 
template<class _Dummy> const typename _Iosb< _Dummy> ::_Seekdir 
_Iosb< _Dummy> ::end; 


class ios_base : public _Iosb< int>  { 



public: typedef int fmtflags; 
typedef int iostate; 
typedef int openmode; 
typedef int seekdir; 

typedef std::streamoff streamoff; 
typedef std::streampos streampos; 

enum event { 

erase_event, imbue_event, copyfmt_event}; 

typedef void (__cdecl *event_callback)(event, ios_base &, int); 
typedef unsigned io_state; typedef unsigned open_mode; typedef unsigned seek_dir; 


class failure : public runtime_error { 



public: explicit failure(const string &_Message) : runtime_error(_Message) 

{ 
} 

virtual ~failure() throw() 
{ 
} 
#line 236 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xiosbase"
}; 


class Init { 


public: Init() 
{ 
_Init_ctor(this); 
} 

~Init() 
{ 
_Init_dtor(this); 
} 


private: static void __cdecl _Init_ctor(Init *); 
static void __cdecl _Init_dtor(Init *); 

static int &__cdecl _Init_cnt_func(); 



static int _Init_cnt; 
#line 262 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xiosbase"
}; 

ios_base &operator=(const ios_base &_Right) 
{ 
if (this != (&_Right)) 
{ 
(this->_Mystate) = _Right._Mystate; 
this->copyfmt(_Right); 
}  
return *this; 
} 

operator void *() const 
{ 
return this->fail() ? (0) : ((void *)this); 
} 

bool operator!() const 
{ 
return this->fail(); 
} 

void clear(iostate _State, bool _Reraise) 
{ 
(this->_Mystate) = (iostate)(_State & (_Statmask)); 
if (((this->_Mystate) & (this->_Except)) == 0) { 
; } else { 
if (_Reraise) { 
throw; } else { 
if (((this->_Mystate) & (this->_Except)) & ((_Iostate)4)) { 
throw ((failure)("ios_base::badbit set")); } else { 
if (((this->_Mystate) & (this->_Except)) & ((_Iostate)2)) { 
throw ((failure)("ios_base::failbit set")); } else { 

throw ((failure)("ios_base::eofbit set")); }  }  }  }  
} 

void clear(iostate _State = ((_Iostate)0)) 
{ 
this->clear(_State, false); 
} 

void clear(io_state _State) 
{ 
this->clear((iostate)_State); 
} 

iostate rdstate() const 
{ 
return this->_Mystate; 
} 


void setstate(iostate _State, bool _Exreraise) 
{ 
if (_State != ((_Iostate)0)) { 
this->clear((iostate)(((int)this->rdstate()) | _State), _Exreraise); }  
} 

void setstate(iostate _State) 
{ 
if (_State != ((_Iostate)0)) { 
this->clear((iostate)(((int)this->rdstate()) | _State), false); }  
} 

void setstate(io_state _State) 
{ 
this->setstate((iostate)_State); 
} 

bool good() const 
{ 
return this->rdstate() == ((_Iostate)0); 
} 

bool eof() const 
{ 
return ((int)this->rdstate()) & ((int)((_Iostate)1)); 
} 

bool fail() const 
{ 
return (((int)this->rdstate()) & (((int)((_Iostate)4)) | ((int)((_Iostate)2)))) != 0; 

} 

bool bad() const 
{ 
return (((int)this->rdstate()) & ((int)((_Iostate)4))) != 0; 
} 




iostate exceptions() const 
{ 
return this->_Except; 
} 

void exceptions(iostate _Newexcept) 
{ 
(this->_Except) = (iostate)(_Newexcept & ((int)_Statmask)); 
this->clear(this->_Mystate); 
} 

void exceptions(io_state _State) 
{ 
this->exceptions((iostate)_State); 
} 

fmtflags flags() const 
{ 
return this->_Fmtfl; 
} 

fmtflags flags(fmtflags _Newfmtflags) 
{ 
auto fmtflags _Oldfmtflags = (this->_Fmtfl); 
(this->_Fmtfl) = (fmtflags)(_Newfmtflags & ((int)_Fmtmask)); 
return _Oldfmtflags; 
} 

fmtflags setf(fmtflags _Newfmtflags) 
{ 
auto fmtflags _Oldfmtflags = (this->_Fmtfl); 
(this->_Fmtfl) = (fmtflags)((this->_Fmtfl) | (_Newfmtflags & ((int)_Fmtmask))); 

return _Oldfmtflags; 
} 

fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask) 
{ 
auto fmtflags _Oldfmtflags = (this->_Fmtfl); 
(this->_Fmtfl) = (fmtflags)(((this->_Fmtfl) & ((int)(~_Mask))) | ((_Newfmtflags & _Mask) & ((int)_Fmtmask))); 

return _Oldfmtflags; 
} 

void unsetf(fmtflags _Mask) 
{ 
(this->_Fmtfl) = (fmtflags)((this->_Fmtfl) & ((int)(~_Mask))); 
} 

streamsize precision() const 
{ 
return this->_Prec; 
} 

streamsize precision(streamsize _Newprecision) 
{ 
auto streamsize _Oldprecision = (this->_Prec); 
(this->_Prec) = _Newprecision; 
return _Oldprecision; 
} 

streamsize width() const 
{ 
return this->_Wide; 
} 

streamsize width(streamsize _Newwidth) 
{ 
auto streamsize _Oldwidth = (this->_Wide); 
(this->_Wide) = _Newwidth; 
return _Oldwidth; 
} 

locale getloc() const 
{ 
return *(this->_Ploc); 
} 

locale imbue(const locale &_Loc) 
{ 
auto locale _Oldlocale = *(this->_Ploc); 
((*(this->_Ploc)) = _Loc); 
this->_Callfns(imbue_event); 
return _Oldlocale; 
} 

static int __cdecl xalloc() 
{ 
{ auto _Lockit _Lock(2); 
return _Index++; 
} 
} 

long &iword(int _Idx) 
{ 
return this->_Findarr(_Idx)._Lo; 
} 

void *&pword(int _Idx) 
{ 
return this->_Findarr(_Idx)._Vp; 
} 

void register_callback(event_callback _Pfn, int _Idx) 
{ 
(this->_Calls) = (new _Fnarray(_Idx, _Pfn, this->_Calls)); 
} 

ios_base &copyfmt(const ios_base &_Other) 
{ 
if (this != (&_Other)) 
{ 
this->_Tidy(); 
((*(this->_Ploc)) = (*(_Other._Ploc))); 
(this->_Fmtfl) = _Other._Fmtfl; 
(this->_Prec) = _Other._Prec; 
(this->_Wide) = _Other._Wide; 
auto _Iosarray *_Ptr = (_Other._Arr); 

for ((this->_Arr) = (0); _Ptr != (0); _Ptr = _Ptr->_Next) { 
if (((_Ptr->_Lo) != (0)) || ((_Ptr->_Vp) != (0))) 
{ 
this->iword(_Ptr->_Index) = _Ptr->_Lo; 
this->pword(_Ptr->_Index) = _Ptr->_Vp; 
}  }  

for (_Fnarray *_Q = (_Other._Calls); _Q != (0); _Q = _Q->_Next) { 
this->register_callback(_Q->_Pfn, _Q->_Index); }  

this->_Callfns(copyfmt_event); 
this->exceptions(_Other._Except); 
}  
return *this; 
} 


virtual ~ios_base() 
{ 
_Ios_base_dtor(this); 
} 

static bool __cdecl sync_with_stdio(bool _Newsync = true) 
{ 
{ auto _Lockit _Lock(2); 
auto const bool _Oldsync = _Sync; 
_Sync = _Newsync; 
return _Oldsync; 
} 
} 

static void __cdecl _Addstd(ios_base *); 
size_t _Stdstr; 


protected: ios_base() 
{ 
} 

void _Init() 
{ 
(this->_Ploc) = (0); 
(this->_Stdstr) = (0); 
(this->_Except) = ((_Iostate)0); 
(this->_Fmtfl) = (((_Fmtflags)1) | ((_Fmtflags)512)); 
(this->_Prec) = (6); 
(this->_Wide) = (0); 
(this->_Arr) = (0); 
(this->_Calls) = (0); 
this->clear((_Iostate)0); 
(this->_Ploc) = (new locale); 
} 



private: struct _Iosarray { 


_Iosarray(int _Idx, _Iosarray *_Link) : _Next(_Link), _Index(_Idx), _Lo((0)), _Vp((0)) 

{ 
} 

_Iosarray *_Next; 
int _Index; 
long _Lo; 
void *_Vp; 
}; 


struct _Fnarray { 

_Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link) : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) 

{ 
} 

_Fnarray *_Next; 
int _Index; 
event_callback _Pfn; 
}; 

void _Callfns(event _Ev) 
{ 
for (_Fnarray *_Ptr = (this->_Calls); _Ptr != (0); _Ptr = _Ptr->_Next) { 
(_Ptr->_Pfn)(_Ev, *this, _Ptr->_Index); }  
} 

_Iosarray &_Findarr(int _Idx) 
{ 
auto _Iosarray *_Ptr; auto _Iosarray *_Q; 

for ((_Ptr = this->_Arr), (_Q = (0)); _Ptr != (0); _Ptr = _Ptr->_Next) { 
if ((_Ptr->_Index) == _Idx) { 
return *_Ptr; } else { 
if (((_Q == (0)) && ((_Ptr->_Lo) == (0))) && ((_Ptr->_Vp) == (0))) { 
_Q = _Ptr; }  }  }  

if (_Q != (0)) 
{ 
(_Q->_Index) = _Idx; 
return *_Q; 
}  

(this->_Arr) = (new _Iosarray(_Idx, this->_Arr)); 
return *(this->_Arr); 
} 

void __cdecl _Tidy() 
{ 
this->_Callfns(erase_event); 
auto _Iosarray *_Q1; auto _Iosarray *_Q2; 

for (_Q1 = this->_Arr; _Q1 != (0); _Q1 = _Q2) { 
(_Q2 = _Q1->_Next), (delete _Q1); }  
(this->_Arr) = (0); 

auto _Fnarray *_Q3; auto _Fnarray *_Q4; 
for (_Q3 = this->_Calls; _Q3 != (0); _Q3 = _Q4) { 
(_Q4 = _Q3->_Next), (delete _Q3); }  
(this->_Calls) = (0); 
} 

static void __cdecl _Ios_base_dtor(ios_base *); 

iostate _Mystate; 
iostate _Except; 
fmtflags _Fmtfl; 
streamsize _Prec; 
streamsize _Wide; 
_Iosarray *_Arr; 
_Fnarray *_Calls; 
locale *_Ploc; 
#line 613 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xiosbase"
static int _Index; 
static bool _Sync; 
#line 616 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xiosbase"
static int &__cdecl _Index_func(); 
static bool &__cdecl _Sync_func(); 
}; 
#line 624 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xiosbase"
}

#pragma warning(pop)
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\streambuf"
#pragma warning(push,3)
#line 627 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xiosbase"
#pragma pack ( pop )
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\streambuf"
#pragma pack ( push, 8 )
#line 12 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\streambuf"
namespace std { 


template < class _Elem,
 class _Traits >
 class basic_streambuf
 {

 basic_streambuf ( const basic_streambuf < _Elem, _Traits > & );
 basic_streambuf < _Elem, _Traits > &
  operator = ( const basic_streambuf < _Elem, _Traits > & );


protected :
 basic_streambuf ( )
  : _Plocale ( new ( locale ) )
  {
  _Init ( );
  }

 basic_streambuf ( _Uninitialized )
  {
  }

public :
 typedef basic_streambuf < _Elem, _Traits > _Myt;
 typedef _Elem char_type;
 typedef _Traits traits_type;

 virtual ~ basic_streambuf ( )
  {
  delete ( _Plocale );
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 pos_type pubseekoff ( off_type _Off, ios_base :: seekdir _Way,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  {
  return ( seekoff ( _Off, _Way, _Mode ) );
  }

 pos_type pubseekoff ( off_type _Off, ios_base :: seek_dir _Way,
  ios_base :: open_mode _Mode )
  {
  return ( pubseekoff ( _Off, ( ios_base :: seekdir ) _Way,
   ( ios_base :: openmode ) _Mode ) );
  }

 pos_type pubseekpos ( pos_type _Pos,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  {
  return ( seekpos ( _Pos, _Mode ) );
  }

 pos_type pubseekpos ( pos_type _Pos, ios_base :: open_mode _Mode )
  {
  return ( seekpos ( _Pos, ( ios_base :: openmode ) _Mode ) );
  }

 _Myt * pubsetbuf ( _Elem * _Buffer, streamsize _Count )
  {
  return ( setbuf ( _Buffer, _Count ) );
  }

 locale pubimbue ( const locale & _Newlocale )
  {
  locale _Oldlocale = * _Plocale;
  imbue ( _Newlocale );
  * _Plocale = _Newlocale;
  return ( _Oldlocale );
  }

 locale getloc ( ) const
  {
  return ( * _Plocale );
  }

 streamsize in_avail ( )
  {
  streamsize _Res = _Gnavail ( );
  return ( 0 < _Res ? _Res : showmanyc ( ) );
  }

 int pubsync ( )
  {
  return ( sync ( ) );
  }

 int_type sbumpc ( )
  {
  return ( 0 < _Gnavail ( )
   ? _Traits :: to_int_type ( * _Gninc ( ) ) : uflow ( ) );
  }

 int_type sgetc ( )
  {
  return ( 0 < _Gnavail ( )
   ? _Traits :: to_int_type ( * gptr ( ) ) : underflow ( ) );
  }

 streamsize _Sgetn_s ( _Elem * _Ptr, size_t _Ptr_size, streamsize _Count )
  {
  return _Xsgetn_s ( _Ptr, _Ptr_size, _Count );
  }

 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 streamsize sgetn ( _Elem * _Ptr, streamsize _Count )
  {
#pragma warning(push)
#pragma warning(disable:4996)
  return xsgetn ( _Ptr, _Count );
#pragma warning(pop)
  }

 int_type snextc ( )
  {
  return ( 1 < _Gnavail ( )
   ? _Traits :: to_int_type ( * _Gnpreinc ( ) )
   : _Traits :: eq_int_type ( _Traits :: eof ( ), sbumpc ( ) )
    ? _Traits :: eof ( ) : sgetc ( ) );
  }

 int_type sputbackc ( _Elem _Ch )
  {
  return ( gptr ( ) != 0 && eback ( ) < gptr ( )
   && _Traits :: eq ( _Ch, gptr ( ) [ - 1 ] )
   ? _Traits :: to_int_type ( * _Gndec ( ) )
   : pbackfail ( _Traits :: to_int_type ( _Ch ) ) );
  }

 void stossc ( )
  {
  if ( 0 < _Gnavail ( ) )
   _Gninc ( );
  else
   uflow ( );
  }

 int_type sungetc ( )
  {
  return ( gptr ( ) != 0 && eback ( ) < gptr ( )
   ? _Traits :: to_int_type ( * _Gndec ( ) ) : pbackfail ( ) );
  }

 int_type sputc ( _Elem _Ch )
  {
  return ( 0 < _Pnavail ( )
   ? _Traits :: to_int_type ( * _Pninc ( ) = _Ch )
   : overflow ( _Traits :: to_int_type ( _Ch ) ) );
  }

 streamsize sputn ( const _Elem * _Ptr, streamsize _Count )
  {
  return ( xsputn ( _Ptr, _Count ) );
  }

 void _Lock ( )
  {
  _Mylock . _Lock ( );
  }

 void _Unlock ( )
  {
  _Mylock . _Unlock ( );
  }


protected :
 _Elem * eback ( ) const
  {
  return ( * _IGfirst );
  }

 _Elem * gptr ( ) const
  {
  return ( * _IGnext );
  }

 _Elem * pbase ( ) const
  {
  return ( * _IPfirst );
  }

 _Elem * pptr ( ) const
  {
  return ( * _IPnext );
  }

 _Elem * egptr ( ) const
  {
  return ( * _IGnext + * _IGcount );
  }

 void gbump ( int _Off )
  {
  * _IGcount -= _Off;
  * _IGnext += _Off;
  }

 void setg ( _Elem * _First, _Elem * _Next, _Elem * _Last )
  {
  * _IGfirst = _First;
  * _IGnext = _Next;
  * _IGcount = ( int ) ( _Last - _Next );
  }

 _Elem * epptr ( ) const
  {
  return ( * _IPnext + * _IPcount );
  }

 _Elem * _Gndec ( )
  {
  ++ * _IGcount;
  return ( -- * _IGnext );
  }

 _Elem * _Gninc ( )
  {
  -- * _IGcount;
  return ( ( * _IGnext ) ++ );
  }

 _Elem * _Gnpreinc ( )
  {
  -- * _IGcount;
  return ( ++ ( * _IGnext ) );
  }

 streamsize _Gnavail ( ) const
  {
  return ( * _IGnext != 0 ? * _IGcount : 0 );
  }

 void pbump ( int _Off )
  {
  * _IPcount -= _Off;
  * _IPnext += _Off;
  }

 void setp ( _Elem * _First, _Elem * _Last )
  {
  * _IPfirst = _First;
  * _IPnext = _First;
  * _IPcount = ( int ) ( _Last - _First );
  }

 void setp ( _Elem * _First, _Elem * _Next, _Elem * _Last )
  {
  * _IPfirst = _First;
  * _IPnext = _Next;
  * _IPcount = ( int ) ( _Last - _Next );
  }

 _Elem * _Pninc ( )
  {
  -- * _IPcount;
  return ( ( * _IPnext ) ++ );
  }

 streamsize _Pnavail ( ) const
  {
  return ( * _IPnext != 0 ? * _IPcount : 0 );
  }

 void _Init ( )
  {
  _IGfirst = & _Gfirst, _IPfirst = & _Pfirst;
  _IGnext = & _Gnext, _IPnext = & _Pnext;
  _IGcount = & _Gcount, _IPcount = & _Pcount;
  setp ( 0, 0 ), setg ( 0, 0, 0 );
  }

 void _Init ( _Elem * * _Gf, _Elem * * _Gn, int * _Gc,
  _Elem * * _Pf, _Elem * * _Pn, int * _Pc )
  {
  _IGfirst = _Gf, _IPfirst = _Pf;
  _IGnext = _Gn, _IPnext = _Pn;
  _IGcount = _Gc, _IPcount = _Pc;
  }

 virtual int_type overflow ( int_type = _Traits :: eof ( ) )
  {
  return ( _Traits :: eof ( ) );
  }

 virtual int_type pbackfail ( int_type = _Traits :: eof ( ) )
  {
  return ( _Traits :: eof ( ) );
  }

 virtual streamsize showmanyc ( )
  {
  return ( 0 );
  }

 virtual int_type underflow ( )
  {
  return ( _Traits :: eof ( ) );
  }

 virtual int_type uflow ( )
  {
  return ( _Traits :: eq_int_type ( _Traits :: eof ( ), underflow ( ) )
   ? _Traits :: eof ( ) : _Traits :: to_int_type ( * _Gninc ( ) ) );
  }

 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 virtual streamsize xsgetn ( _Elem * _Ptr,
  streamsize _Count )
  {

  return _Xsgetn_s ( _Ptr, ( size_t ) - 1, _Count );
  }

 virtual streamsize _Xsgetn_s ( _Elem * _Ptr,
  size_t _Ptr_size, streamsize _Count )
  {
  int_type _Meta;
  streamsize _Stream_size, _Size, _Copied;

  for ( _Copied = 0; 0 < _Count; )
   if ( 0 < ( _Stream_size = _Gnavail ( ) ) )
    {
    _Size = _Stream_size;
    if ( _Count < _Size )
     _Size = _Count;
    _Traits_helper :: copy_s < _Traits > ( _Ptr, _Ptr_size, gptr ( ), _Size );
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    gbump ( ( int ) _Size );
    }
   else if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta = uflow ( ) ) )
    break;
   else
    {
    * _Ptr ++ = _Traits :: to_char_type ( _Meta );
    ++ _Copied;
    -- _Count;
    }

  return ( _Copied );
  }

 virtual streamsize xsputn ( const _Elem * _Ptr,
  streamsize _Count )
  {
  streamsize _Stream_size, _Size, _Copied;

  for ( _Copied = 0; 0 < _Count; )
   if ( 0 < ( _Stream_size = _Pnavail ( ) ) )
    {
    _Size = _Stream_size;
    if ( _Count < _Size )
     _Size = _Count;
    _Traits_helper :: copy_s < _Traits > ( pptr ( ), _Stream_size, _Ptr, _Size );
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    pbump ( ( int ) _Size );
    }
   else if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    overflow ( _Traits :: to_int_type ( * _Ptr ) ) ) )
    break;
   else
    {
    ++ _Ptr;
    ++ _Copied;
    -- _Count;
    }

  return ( _Copied );
  }

 virtual pos_type seekoff ( off_type, ios_base :: seekdir,
  ios_base :: openmode = ios_base :: in | ios_base :: out )
  {
  return ( streampos ( _BADOFF ) );
  }

 virtual pos_type seekpos ( pos_type,
  ios_base :: openmode = ios_base :: in | ios_base :: out )
  {
  return ( streampos ( _BADOFF ) );
  }

 virtual _Myt * setbuf ( _Elem *, streamsize )
  {
  return ( this );
  }

 virtual int sync ( )
  {
  return ( 0 );
  }

 virtual void imbue ( const locale & )
  {
  }

private :
 _Mutex _Mylock;
 _Elem * _Gfirst;
 _Elem * _Pfirst;
 _Elem * * _IGfirst;
 _Elem * * _IPfirst;
 _Elem * _Gnext;
 _Elem * _Pnext;
 _Elem * * _IGnext;
 _Elem * * _IPnext;
 int _Gcount;
 int _Pcount;
 int * _IGcount;
 int * _IPcount;
 locale * _Plocale;
 };
#line 443 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\streambuf"
template < class _Elem,
 class _Traits >
 class istreambuf_iterator
  : public iterator < input_iterator_tag,
   _Elem, typename _Traits :: off_type, _Elem *, _Elem & >
 {
 typedef istreambuf_iterator < _Elem, _Traits > _Myt;
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf < _Elem, _Traits > streambuf_type;
 typedef basic_istream < _Elem, _Traits > istream_type;

 typedef typename traits_type :: int_type int_type;


 typedef _Range_checked_iterator_tag _Checked_iterator_category;


 istreambuf_iterator ( streambuf_type * _Sb = 0 ) throw ( )
  : _Strbuf ( _Sb ), _Got ( _Sb == 0 )
  {
  }

 istreambuf_iterator ( istream_type & _Istr ) throw ( )
  : _Strbuf ( _Istr . rdbuf ( ) ), _Got ( _Istr . rdbuf ( ) == 0 )
  {
  }

 _Elem operator * ( ) const
  {
  if ( ! _Got )
   ( ( _Myt * ) this ) -> _Peek ( );






  return ( _Val );
  }

 _Myt & operator ++ ( )
  {






  _Inc ( );
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  if ( ! _Got )
   _Peek ( );
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 bool equal ( const _Myt & _Right ) const
  {
  if ( ! _Got )
   ( ( _Myt * ) this ) -> _Peek ( );
  if ( ! _Right . _Got )
   ( ( _Myt * ) & _Right ) -> _Peek ( );
  return ( _Strbuf == 0 && _Right . _Strbuf == 0
   || _Strbuf != 0 && _Right . _Strbuf != 0 );
  }

private :
 void _Inc ( )
  {
  if ( _Strbuf == 0
   || traits_type :: eq_int_type ( traits_type :: eof ( ),
    _Strbuf -> sbumpc ( ) ) )
   _Strbuf = 0, _Got = true;
  else
   _Got = false;
  }

 _Elem _Peek ( )
  {
  int_type _Meta;
  if ( _Strbuf == 0
   || traits_type :: eq_int_type ( traits_type :: eof ( ),
    _Meta = _Strbuf -> sgetc ( ) ) )
   _Strbuf = 0;
  else
   _Val = traits_type :: to_char_type ( _Meta );
  _Got = true;
  return ( _Val );
  }

 streambuf_type * _Strbuf;
 bool _Got;
 _Elem _Val;
 };
#line 546 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\streambuf"
template < class _Elem,
 class _Traits > inline
 bool operator == (
  const istreambuf_iterator < _Elem, _Traits > & _Left,
  const istreambuf_iterator < _Elem, _Traits > & _Right )
 {
 return ( _Left . equal ( _Right ) );
 }

template < class _Elem,
 class _Traits > inline
 bool operator != (
  const istreambuf_iterator < _Elem, _Traits > & _Left,
  const istreambuf_iterator < _Elem, _Traits > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }


template < class _Elem,
 class _Traits >
 class ostreambuf_iterator
  : public _Outit
 {
 typedef ostreambuf_iterator < _Elem, _Traits > _Myt;
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf < _Elem, _Traits > streambuf_type;
 typedef basic_ostream < _Elem, _Traits > ostream_type;


 typedef _Range_checked_iterator_tag _Checked_iterator_category;


 ostreambuf_iterator ( streambuf_type * _Sb ) throw ( )
  : _Failed ( false ), _Strbuf ( _Sb )
  {
  }

 ostreambuf_iterator ( ostream_type & _Ostr ) throw ( )
  : _Failed ( false ), _Strbuf ( _Ostr . rdbuf ( ) )
  {
  }

 _Myt & operator = ( _Elem _Right )
  {
  if ( _Strbuf == 0
   || traits_type :: eq_int_type ( _Traits :: eof ( ),
    _Strbuf -> sputc ( _Right ) ) )
   _Failed = true;
  return ( * this );
  }

 _Myt & operator * ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( int )
  {
  return ( * this );
  }

 bool failed ( ) const throw ( )
  {
  return ( _Failed );
  }

private :
 bool _Failed;
 streambuf_type * _Strbuf;
 };
#line 624 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\streambuf"
}

#pragma warning(pop)
#line 13 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocnum"
#pragma warning(push,3)
#line 627 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\streambuf"
#pragma pack ( pop )
#line 12 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocnum"
#pragma pack ( push, 8 )
#line 21 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocnum"
extern "C" { extern float __cdecl _Stofx(const char *, char **, long, int *); } 

extern "C" { extern double __cdecl _Stodx(const char *, char **, long, int *); } 

extern "C" { extern long double __cdecl _Stoldx(const char *, char **, long, int *); } 

extern "C" { extern long __cdecl _Stolx(const char *, char **, int, int *); } 

extern "C" { extern unsigned long __cdecl _Stoulx(const char *, char **, int, int *); } 




extern "C" { extern __int64 __cdecl _Stollx(const char *, char **, int, int *); } 

extern "C" { extern unsigned __int64 __cdecl _Stoullx(const char *, char **, int, int *); } 
#line 50 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocnum"
namespace std { 



#pragma warning(push)
#pragma warning(disable:4275)

template < class _Elem >
 class numpunct
  : public locale :: facet
 {
public :
 typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > >
  string_type;
 typedef _Elem char_type;

  static locale :: id id;

 _Elem decimal_point ( ) const
  {
  return ( do_decimal_point ( ) );
  }

 _Elem thousands_sep ( ) const
  {
  return ( do_thousands_sep ( ) );
  }

 string grouping ( ) const
  {
  return ( do_grouping ( ) );
  }

 string_type falsename ( ) const
  {
  return ( do_falsename ( ) );
  }

 string_type truename ( ) const
  {
  return ( do_truename ( ) );
  }

 explicit numpunct ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
   if ( _Kseparator == 0 )
    _Kseparator =
     _Maklocchr ( ',', ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  }
  }

  numpunct ( const _Locinfo & _Lobj, size_t _Refs = 0, bool _Isdef = false )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj, _Isdef );
  }

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new numpunct < _Elem > (
    _Locinfo ( _Ploc -> name ( ) ), 0, true );
  return ( 4 );
  }

protected :
 virtual ~ numpunct ( )
  {
  _Tidy ( );
  }

protected :
  numpunct ( const char * _Locname, size_t _Refs = 0, bool _Isdef = false )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj ( _Locname );
   _Init ( _Lobj, _Isdef );
  }
  }

 void _Init ( const _Locinfo & _Lobj, bool _Isdef = false )
  {
  const lconv * _Ptr = _Lobj . _Getlconv ( );

  _Grouping = 0;
  _Falsename = 0;
  _Truename = 0;

  try {
  _Grouping = _Maklocstr ( _Ptr -> grouping, ( char * ) 0, _Lobj . _Getcvt ( ) );
  _Falsename = _Maklocstr ( _Lobj . _Getfalse ( ), ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  _Truename = _Maklocstr ( _Lobj . _Gettrue ( ), ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  } catch ( ... ) {
  _Tidy ( );
  throw;
  }

  _Dp = _Maklocchr ( _Ptr -> decimal_point [ 0 ], ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  _Kseparator =
   _Maklocchr ( _Ptr -> thousands_sep [ 0 ], ( _Elem * ) 0, _Lobj . _Getcvt ( ) );

  if ( _Isdef )
   {
   _Grouping = _Maklocstr ( "", ( char * ) 0, _Lobj . _Getcvt ( ) );
   _Dp = _Maklocchr ( '.', ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
   _Kseparator = _Maklocchr ( ',', ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
   }
  }

 virtual _Elem do_decimal_point ( ) const
  {
  return ( _Dp );
  }

 virtual _Elem do_thousands_sep ( ) const
  {
  return ( _Kseparator );
  }

 virtual string do_grouping ( ) const
  {
  return ( string ( _Grouping ) );
  }

 virtual string_type do_falsename ( ) const
  {
  return ( string_type ( _Falsename ) );
  }

 virtual string_type do_truename ( ) const
  {
  return ( string_type ( _Truename ) );
  }

private :
 void _Tidy ( )
  {
  delete [ ] ( ( void * ) _Grouping );
  delete [ ] ( ( void * ) _Falsename );
  delete [ ] ( ( void * ) _Truename );
  }

 const char * _Grouping;
 _Elem _Dp;
 _Elem _Kseparator;
 const _Elem * _Falsename;
 const _Elem * _Truename;
 };


template < class _Elem >
 class numpunct_byname
  : public numpunct < _Elem >
 {
public :
 explicit numpunct_byname ( const char * _Locname, size_t _Refs = 0 )
  : numpunct < _Elem > ( _Locname, _Refs )
  {
  }

protected :
 virtual ~ numpunct_byname ( )
  {
  }
 };


template<class _Elem> locale::id 
numpunct< _Elem> ::id; 


template < class _Elem,
 class _InIt = istreambuf_iterator < _Elem, char_traits < _Elem > > >
 class num_get
  : public locale :: facet
 {
public :
 typedef numpunct < _Elem > _Mypunct;
 typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > >
  _Mystr;

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new num_get < _Elem, _InIt > (
    _Locinfo ( _Ploc -> name ( ) ) );
  return ( 4 );
  }

  static locale :: id id;

protected :
 virtual ~ num_get ( )
  {
  }

protected :
 void _Init ( const _Locinfo & _Lobj )
  {
  _Cvt = _Lobj . _Getcvt ( );
  }

 _Locinfo :: _Cvtvec _Cvt;

public :
 explicit num_get ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  num_get ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj );
  }

 typedef _Elem char_type;
 typedef _InIt iter_type;

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   _Bool & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned short & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned int & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned long & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }


 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   __int64 & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned __int64 & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }


 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   float & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   double & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long double & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   void * & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

protected :
 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   _Bool & _Val ) const
  {
  ;
  int _Ans = - 1;

  if ( _Iosbase . flags ( ) & ios_base :: boolalpha )
   {
   typedef typename _Mystr :: size_type _Mystrsize;
   const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
   _Mystr _Str ( ( _Mystrsize ) 1, ( char_type ) 0 );
   _Str += _Punct_fac . falsename ( );
   _Str += ( char_type ) 0;
   _Str += _Punct_fac . truename ( );
   _Ans = _Getloctxt ( _First, _Last, ( size_t ) 2, _Str . c_str ( ) );
   }
  else
   {
   char _Ac [ 32 ], * _Ep;
   int _Errno = 0;
   const unsigned long _Ulo = :: _Stoulx ( _Ac, & _Ep,
    _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
     _Iosbase . getloc ( ) ), & _Errno );
   if ( _Ep != _Ac && _Errno == 0 && _Ulo <= 1 )
    _Ans = _Ulo;
   }

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ans < 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans != 0;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned short & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
   _Iosbase . getloc ( ) );
  char * _Ptr = _Ac [ 0 ] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx ( _Ptr, & _Ep, _Base, & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ptr || _Errno != 0 || 65535 < _Ans )
   _State |= ios_base :: failbit;
  else
   _Val = ( unsigned short ) ( _Ac [ 0 ] == '-'
    ? 0 - _Ans : _Ans );
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned int & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
   _Iosbase . getloc ( ) );
  char * _Ptr = _Ac [ 0 ] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx ( _Ptr, & _Ep, _Base, & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ptr || _Errno != 0 || 4294967295U < _Ans )
   _State |= ios_base :: failbit;
  else
   _Val = _Ac [ 0 ] == '-' ? 0 - _Ans : _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const long _Ans = :: _Stolx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned long & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const unsigned long _Ans = :: _Stoulx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }


 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   __int64 & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const __int64 _Ans = :: _Stollx ( _Ac, & _Ep, _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) ), & _Errno );


  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned __int64 & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const unsigned __int64 _Ans = :: _Stoullx ( _Ac, & _Ep, _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) ), & _Errno );


  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }


 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   float & _Val ) const
  {
  ;
  char _Ac [ 8 + 36 + 16 ], * _Ep;
  int _Errno = 0;
  const float _Ans = :: _Stofx ( _Ac, & _Ep,
   _Getffld ( _Ac, _First, _Last,
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   double & _Val ) const
  {
  ;
  char _Ac [ 8 + 36 + 16 ], * _Ep;
  int _Errno = 0;
  const double _Ans = :: _Stodx ( _Ac, & _Ep,
   _Getffld ( _Ac, _First, _Last,
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long double & _Val ) const
  {
  ;
  char _Ac [ 8 + 36 + 16 ], * _Ep;
  int _Errno = 0;
  const long double _Ans = :: _Stoldx ( _Ac, & _Ep,
   _Getffld ( _Ac, _First, _Last,
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   void * & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;


  int _Base = _Getifld ( _Ac, _First, _Last, ios_base :: hex,
   _Iosbase . getloc ( ) );
  const unsigned __int64 _Ans =
   ( sizeof ( void * ) == sizeof ( unsigned long ) )
    ? ( unsigned __int64 ) :: _Stoulx ( _Ac, & _Ep, _Base, & _Errno )
    : :: _Stoullx ( _Ac, & _Ep, _Base, & _Errno );







  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = ( void * ) ( ( char * ) 0 + _Ans );
  return ( _First );
  }

private :
 int __cdecl _Getifld ( char * _Ac,
  _InIt & _First, _InIt & _Last, ios_base :: fmtflags _Basefield,
   const locale & _Loc ) const
  {
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Loc );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _Kseparator = _Grouping . size ( ) == 0
   ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );
  const _Elem _E0 = _Maklocchr ( '0', ( _Elem * ) 0, _Cvt );
  char * _Ptr = _Ac;

  if ( _First == _Last )
   ;
  else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '+', ++ _First;
  else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '-', ++ _First;

  _Basefield &= ios_base :: basefield;
  int _Base = _Basefield == ios_base :: oct ? 8
   : _Basefield == ios_base :: hex ? 16
   : _Basefield == ios_base :: _Fmtzero ? 0 : 10;

  bool _Seendigit = false;
  bool _Nonzero = false;

  if ( _First != _Last && * _First == _E0 )
   {
   _Seendigit = true, ++ _First;
   if ( _First != _Last && ( * _First == _Maklocchr ( 'x', ( _Elem * ) 0, _Cvt )
     || * _First == _Maklocchr ( 'X', ( _Elem * ) 0, _Cvt ) )
    && ( _Base == 0 || _Base == 16 ) )
    _Base = 16, _Seendigit = false, ++ _First;
   else if ( _Base == 0 )
    _Base = 8;
   }

  int _Dlen = _Base == 0 || _Base == 10 ? 10
   : _Base == 8 ? 8 : 16 + 6;
  string _Groups ( ( size_t ) 1, ( char ) _Seendigit );
  size_t _Group = 0;

  for ( char * const _Pe = & _Ac [ 32 - 1 ];
   _First != _Last; ++ _First )
   if ( :: memchr ( ( const char * ) "0123456789abcdefABCDEF",
    * _Ptr = _Maklocbyte ( ( _Elem ) * _First, _Cvt ), _Dlen ) != 0 )
    {
    if ( ( _Nonzero || * _Ptr != '0' ) && _Ptr < _Pe )
     ++ _Ptr, _Nonzero = true;
    _Seendigit = true;
    if ( _Groups [ _Group ] != 127 )
     ++ _Groups [ _Group ];
    }
   else if ( _Groups [ _Group ] == '\000'
    || _Kseparator == ( _Elem ) 0
    || * _First != _Kseparator )
    break;
   else
    {
    _Groups . append ( ( string :: size_type ) 1, '\000' );
    ++ _Group;
    }

  if ( _Group == 0 )
   ;
  else if ( '\000' < _Groups [ _Group ] )
   ++ _Group;
  else
   _Seendigit = false;

  for ( const char * _Pg = _Grouping . c_str ( ); _Seendigit && 0 < _Group; )
   if ( * _Pg == 127 )
    break;
   else if ( 0 < -- _Group && * _Pg != _Groups [ _Group ]
    || 0 == _Group && * _Pg < _Groups [ _Group ] )
    _Seendigit = false;
   else if ( '\000' < _Pg [ 1 ] )
    ++ _Pg;

  if ( _Seendigit && ! _Nonzero )
   * _Ptr ++ = '0';
  else if ( ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  return ( _Base );
  }

 int __cdecl _Getffld ( char * _Ac,
  _InIt & _First, _InIt & _Last, const locale & _Loc ) const
  {
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Loc );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _E0 = _Maklocchr ( '0', ( _Elem * ) 0, _Cvt );
  char * _Ptr = _Ac;
  bool _Bad = false;

  if ( _First == _Last )
   ;
  else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '+', ++ _First;
  else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '-', ++ _First;

  bool _Seendigit = false;
  int _Significant = 0;
  int _Pten = 0;

  if ( * _Grouping . c_str ( ) == 127 || * _Grouping . c_str ( ) <= '\000' )
   for (; _First != _Last
    && _E0 <= * _First && * _First <= _E0 + 9;
     _Seendigit = true, ++ _First )
    if ( 36 <= _Significant )
     ++ _Pten;
    else if ( * _First == _E0 && _Significant == 0 )
     ;
    else
     {
     * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
     ++ _Significant;
     }
  else
   {
   const _Elem _Kseparator = _Punct_fac . thousands_sep ( );

   string _Groups ( ( size_t ) 1, '\000' );
   size_t _Group = 0;

   for (; _First != _Last; ++ _First )
    if ( _E0 <= * _First && * _First <= _E0 + 9 )
     {
     _Seendigit = true;
     if ( 36 <= _Significant )
      ++ _Pten;
     else if ( * _First == _E0 && _Significant == 0 )
      ;
     else
      {
      * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
      ++ _Significant;
      }
     if ( _Groups [ _Group ] != 127 )
      ++ _Groups [ _Group ];
     }
    else if ( _Groups [ _Group ] == '\000'
     || _Kseparator == ( _Elem ) 0
     || * _First != _Kseparator )
     break;
    else
     {
     _Groups . append ( ( size_t ) 1, '\000' );
     ++ _Group;
     }
   if ( _Group == 0 )
    ;
   else if ( '\000' < _Groups [ _Group ] )
    ++ _Group;
   else
    _Bad = true;

   for ( const char * _Pg = _Grouping . c_str ( );
    ! _Bad && 0 < _Group; )
    if ( * _Pg == 127 )
     break;
    else if ( 0 < -- _Group && * _Pg != _Groups [ _Group ]
     || 0 == _Group && * _Pg < _Groups [ _Group ] )
     _Bad = true;
    else if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
   }

  if ( _Seendigit && _Significant == 0 )
   * _Ptr ++ = '0';

  if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) )
   * _Ptr ++ = localeconv ( ) -> decimal_point [ 0 ], ++ _First;

  if ( _Significant == 0 )
   {
   for (; _First != _Last && * _First == _E0;
    _Seendigit = true, ++ _First )
    -- _Pten;
   if ( _Pten < 0 )
    * _Ptr ++ = '0', ++ _Pten;
   }

  for (; _First != _Last
    && _E0 <= * _First && * _First <= _E0 + 9;
    _Seendigit = true, ++ _First )
   if ( _Significant < 36 )
    {
    * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
    ++ _Significant;
    }

  if ( _Seendigit && _First != _Last
   && ( * _First == _Maklocchr ( 'e', ( _Elem * ) 0, _Cvt )
    || * _First == _Maklocchr ( 'E', ( _Elem * ) 0, _Cvt ) ) )
   {
   * _Ptr ++ = 'e', ++ _First;
   _Seendigit = false, _Significant = 0;

   if ( _First == _Last )
    ;
   else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
    * _Ptr ++ = '+', ++ _First;
   else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
    * _Ptr ++ = '-', ++ _First;
   for (; _First != _Last && * _First == _E0; )
    _Seendigit = true, ++ _First;
   if ( _Seendigit )
    * _Ptr ++ = '0';
   for (; _First != _Last
    && _E0 <= * _First && * _First <= _E0 + 9;
    _Seendigit = true, ++ _First )
    if ( _Significant < 8 )
     {
     * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
     ++ _Significant;
     }
   }

  if ( _Bad || ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  return ( _Pten );
  }


 int _Hexdig ( const _Elem _Dig, const _Elem _E0,
  const _Elem _Al, const _Elem _Au ) const
  {
  if ( _E0 <= _Dig && _Dig <= _E0 + 9 )
   return ( _Dig - _E0 );
  else if ( _Al <= _Dig && _Dig <= _Al + 5 )
   return ( _Dig - _Al + 10 );
  else if ( _Au <= _Dig && _Dig <= _Au + 5 )
   return ( _Dig - _Au + 10 );
  else
   return ( - 1 );
  }

 int __cdecl _Getffldx ( char * _Ac,
  _InIt & _First, _InIt & _Last,
  ios_base & _Iosbase, int * _Phexexp ) const
  {
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _E0 = _Maklocchr ( '0', ( _Elem * ) 0, _Cvt );
  const _Elem _Al = _Maklocchr ( 'a', ( _Elem * ) 0, _Cvt );
  const _Elem _Au = _Maklocchr ( 'A', ( _Elem * ) 0, _Cvt );
  char * _Ptr = _Ac;
  bool _Bad = false;
  int _Dig;

  if ( _First == _Last )
   ;
  else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '+', ++ _First;
  else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
   * _Ptr ++ = '-', ++ _First;

  * _Ptr ++ = '0';
  * _Ptr ++ = 'x';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Phex = 0;

  if ( _First == _Last || * _First != _E0 )
   ;
  else if ( ++ _First != _Last
   && ( * _First == _Maklocchr ( 'x', ( _Elem * ) 0, _Cvt )
     || * _First == _Maklocchr ( 'X', ( _Elem * ) 0, _Cvt ) ) )
   ++ _First;
  else
   _Seendigit = true;

  if ( * _Grouping . c_str ( ) == 127 || * _Grouping . c_str ( ) <= '\000' )
   for (; _First != _Last
    && 0 <= ( _Dig = _Hexdig ( * _First, _E0, _Al, _Au ) );
     _Seendigit = true, ++ _First )
    if ( 36 <= _Significant )
     ++ _Phex;
    else if ( * _First == _E0 && _Significant == 0 )
     ;
    else
     {
     * _Ptr ++ = "0123456789abcdef" [ _Dig ];
     ++ _Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping . size ( ) == 0
    ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );
   string _Groups ( ( size_t ) 1, '\000' );
   size_t _Group = 0;

   for (; _First != _Last; ++ _First )
    if ( 0 <= ( _Dig = _Hexdig ( * _First, _E0, _Al, _Au ) ) )
     {
     _Seendigit = true;
     if ( 36 <= _Significant )
      ++ _Phex;
     else if ( * _First == _E0 && _Significant == 0 )
      ;
     else
      {
      * _Ptr ++ = "0123456789abcdef" [ _Dig ];
      ++ _Significant;
      }
     if ( _Groups [ _Group ] != 127 )
      ++ _Groups [ _Group ];
     }
    else if ( _Groups [ _Group ] == '\000'
     || _Kseparator == ( _Elem ) 0
     || * _First != _Kseparator )
     break;
    else
     {
     _Groups . append ( ( size_t ) 1, '\000' );
     ++ _Group;
     }
   if ( _Group == 0 )
    ;
   else if ( '\000' < _Groups [ _Group ] )
    ++ _Group;
   else
    _Bad = true;

   for ( const char * _Pg = _Grouping . c_str ( );
    ! _Bad && 0 < _Group; )
    if ( * _Pg == 127 )
     break;
    else if ( 0 < -- _Group && * _Pg != _Groups [ _Group ]
     || 0 == _Group && * _Pg < _Groups [ _Group ] )
     _Bad = true;
    else if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
   }

  if ( _Seendigit && _Significant == 0 )
   * _Ptr ++ = '0';

  if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) )
   * _Ptr ++ = localeconv ( ) -> decimal_point [ 0 ], ++ _First;

  if ( _Significant == 0 )
   {
   for (; _First != _Last && * _First == _E0;
    _Seendigit = true, ++ _First )
    -- _Phex;
   if ( _Phex < 0 )
    * _Ptr ++ = '0', ++ _Phex;
   }

  for (; _First != _Last
    && 0 <= ( _Dig = _Hexdig ( * _First, _E0, _Al, _Au ) );
    _Seendigit = true, ++ _First )
   if ( _Significant < 36 )
    {
    * _Ptr ++ = "0123456789abcdef" [ _Dig ];
    ++ _Significant;
    }

  if ( _Seendigit && _First != _Last
   && ( * _First == _Maklocchr ( 'p', ( _Elem * ) 0, _Cvt )
    || * _First == _Maklocchr ( 'P', ( _Elem * ) 0, _Cvt ) ) )
   {
   * _Ptr ++ = 'p', ++ _First;
   _Seendigit = false, _Significant = 0;

   if ( _First == _Last )
    ;
   else if ( * _First == _Maklocchr ( '+', ( _Elem * ) 0, _Cvt ) )
    * _Ptr ++ = '+', ++ _First;
   else if ( * _First == _Maklocchr ( '-', ( _Elem * ) 0, _Cvt ) )
    * _Ptr ++ = '-', ++ _First;
   for (; _First != _Last && * _First == _E0; )
    _Seendigit = true, ++ _First;
   if ( _Seendigit )
    * _Ptr ++ = '0';
   for (; _First != _Last
    && _E0 <= * _First && * _First <= _E0 + 9;
    _Seendigit = true, ++ _First )
    if ( _Significant < 8 )
     {
     * _Ptr ++ = ( char ) ( ( * _First - _E0 ) + '0' );
     ++ _Significant;
     }
   }

  if ( _Bad || ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  * _Phexexp = _Phex;
  return ( 0 );
  }
 };
#line 1013 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocnum"
template<class _Elem, class 
_InIt> locale::id 
num_get< _Elem, _InIt> ::id; 


template < class _Elem,
 class _OutIt = ostreambuf_iterator < _Elem, char_traits < _Elem > > >
 class num_put
  : public locale :: facet
 {
public :
 typedef numpunct < _Elem > _Mypunct;
 typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > >
  _Mystr;

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new num_put < _Elem, _OutIt > (
    _Locinfo ( _Ploc -> name ( ) ) );
  return ( 4 );
  }

  static locale :: id id;

protected :
 virtual ~ num_put ( )
  {
  }

protected :
 void _Init ( const _Locinfo & _Lobj )
  {
  _Cvt = _Lobj . _Getcvt ( );
  }

 _Locinfo :: _Cvtvec _Cvt;

public :
 explicit num_put ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  num_put ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj );
  }

 typedef _Elem char_type;
 typedef _OutIt iter_type;

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, _Bool _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned long _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }


 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, __int64 _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned __int64 _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }


 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, double _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long double _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

protected :
 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, _Bool _Val ) const
  {
  ;
  if ( ! ( _Iosbase . flags ( ) & ios_base :: boolalpha ) )
   return ( do_put ( _Dest, _Iosbase, _Fill, ( long ) _Val ) );
  else
   {
   const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
   _Mystr _Str;
   if ( _Val )
    _Str . assign ( _Punct_fac . truename ( ) );
   else
    _Str . assign ( _Punct_fac . falsename ( ) );

   size_t _Fillcount = _Iosbase . width ( ) <= 0
    || ( size_t ) _Iosbase . width ( ) <= _Str . size ( )
     ? 0 : ( size_t ) _Iosbase . width ( ) - _Str . size ( );

   if ( ( _Iosbase . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
    {
    _Dest = _Rep ( _Dest, _Fill, _Fillcount );
    _Fillcount = 0;
    }
   _Dest = _Put ( _Dest, _Str . c_str ( ), _Str . size ( ) );
   _Iosbase . width ( 0 );
   return ( _Rep ( _Dest, _Fill, _Fillcount ) );
   }
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long _Val ) const
  {
  const size_t _Buf_size = 2 * 32;
  char _Buf [ _Buf_size ], _Fmt [ 6 ];
  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, _Buf_size, _Ifmt ( _Fmt, "ld",
    _Iosbase . flags ( ) ), _Val ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned long _Val ) const
  {
  const size_t _Buf_size = 2 * 32;
  char _Buf [ _Buf_size ], _Fmt [ 6 ];
  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, _Buf_size, _Ifmt ( _Fmt, "lu",
    _Iosbase . flags ( ) ), _Val ) ) );
  }


 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, __int64 _Val ) const
  {
  const size_t _Buf_size = 2 * 32;
  char _Buf [ _Buf_size ], _Fmt [ 8 ];
  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, _Buf_size, _Ifmt ( _Fmt, "Ld",
    _Iosbase . flags ( ) ), _Val ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned __int64 _Val ) const
  {
  const size_t _Buf_size = 2 * 32;
  char _Buf [ _Buf_size ], _Fmt [ 8 ];
  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, _Buf_size, _Ifmt ( _Fmt, "Lu",
    _Iosbase . flags ( ) ), _Val ) ) );
  }


 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, double _Val ) const
  {
  const size_t _Buf_size = 8 + 36 + 64;
  char _Buf [ _Buf_size ], _Fmt [ 8 ];
  streamsize _Precision = _Iosbase . precision ( ) <= 0
   && ! ( _Iosbase . flags ( ) & ios_base :: fixed )
    ? 6 : _Iosbase . precision ( );
  int _Significance = 36 < _Precision
   ? 36 : ( int ) _Precision;
  _Precision -= _Significance;
  size_t _Beforepoint = 0;
  size_t _Afterpoint = 0;

  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: fixed
   && _Val * (0.5) != _Val )
   {
   bool _Signed = _Val < 0;
   if ( _Signed )
    _Val = - _Val;

   for (; (9.9999999999999997e+034) <= _Val && _Beforepoint < 5000; _Beforepoint += 10 )
    _Val /= (10000000000.0);

   if ( 0 < _Val )
    for (; 10 <= _Precision && _Val <= (1e-035)
     && _Afterpoint < 5000; _Afterpoint += 10 )
     {
     _Val *= (10000000000.0);
     _Precision -= 10;
     }

   if ( _Signed )
    _Val = - _Val;
   }

  return ( _Fput ( _Dest, _Iosbase, _Fill, _Buf,
   _Beforepoint, _Afterpoint, _Precision,
    :: sprintf_s ( _Buf, _Buf_size, _Ffmt ( _Fmt, 0, _Iosbase . flags ( ) ),
     _Significance, _Val ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long double _Val ) const
  {
  const size_t _Buf_size = 8 + 36 + 64;
  char _Buf [ _Buf_size ], _Fmt [ 8 ];
  streamsize _Precision = _Iosbase . precision ( ) <= 0
   && ! ( _Iosbase . flags ( ) & ios_base :: fixed )
    ? 6 : _Iosbase . precision ( );
  int _Significance = 36 < _Precision
   ? 36 : ( int ) _Precision;
  _Precision -= _Significance;
  size_t _Beforepoint = 0;
  size_t _Afterpoint = 0;

  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: fixed )
   {
   bool _Signed = _Val < 0;
   if ( _Signed )
    _Val = - _Val;

   for (; (9.9999999999999997e+034) <= _Val && _Beforepoint < 5000; _Beforepoint += 10 )
    _Val /= (10000000000.0);

   if ( 0 < _Val )
    for (; 10 <= _Precision && _Val <= (1e-035)
     && _Afterpoint < 5000; _Afterpoint += 10 )
     {
     _Val *= (10000000000.0);
     _Precision -= 10;
     }

   if ( _Signed )
    _Val = - _Val;
   }

  return ( _Fput ( _Dest, _Iosbase, _Fill, _Buf,
   _Beforepoint, _Afterpoint, _Precision,
    :: sprintf_s ( _Buf, _Buf_size, _Ffmt ( _Fmt, 'L', _Iosbase . flags ( ) ),
     _Significance, _Val ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const
  {
  const size_t _Buf_size = 2 * 32;
  char _Buf [ _Buf_size ];
  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, _Buf_size, "%p", _Val ) ) );
  }

private :
 char * __cdecl _Ffmt ( char * _Fmt,
  char _Spec, ios_base :: fmtflags _Flags ) const
  {
  char * _Ptr = _Fmt;
  * _Ptr ++ = '%';

  if ( _Flags & ios_base :: showpos )
   * _Ptr ++ = '+';
  if ( _Flags & ios_base :: showpoint )
   * _Ptr ++ = '#';
  * _Ptr ++ = '.';
  * _Ptr ++ = '*';
  if ( _Spec != '\000' )
   * _Ptr ++ = _Spec;

  ios_base :: fmtflags _Ffl = _Flags & ios_base :: floatfield;
  * _Ptr ++ = _Ffl == ios_base :: fixed ? 'f'
   : _Ffl == ios_base :: hexfloat ? 'a'
   : _Ffl == ios_base :: scientific ? 'e' : 'g';
  * _Ptr = '\000';
  return ( _Fmt );
  }

 _OutIt __cdecl _Fput ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const char * _Buf,
   size_t _Beforepoint, size_t _Afterpoint,
    size_t _Trailing, size_t _Count ) const
  {
  ;
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _Kseparator = _Punct_fac . thousands_sep ( );
  string _Groupstring;
  const _Elem _E0 = _Maklocchr ( '0', ( _Elem * ) 0, _Cvt );
  size_t _Prefix = _Buf [ 0 ] == '+' || _Buf [ 0 ] == '-' ? 1 : 0;

  char _Enders [ 3 ];
  _Enders [ 0 ] = :: localeconv ( ) -> decimal_point [ 0 ];
  _Enders [ 1 ] = 'e';
  _Enders [ 2 ] = '\000';

  const char * _Eptr = ( const char * ) :: memchr ( _Buf,
   'e', _Count );
  const char * _Pointptr = ( const char * ) :: memchr ( _Buf,
   _Enders [ 0 ], _Count );
  if ( _Pointptr == 0 )
   _Trailing = 0;

  if ( * _Grouping . c_str ( ) != 127 && '\000' < * _Grouping . c_str ( ) )
   {
   _Groupstring . append ( _Buf, _Count );
   if ( _Eptr == 0 )
    _Groupstring . append ( _Trailing, '0' );
   else
    {
    if ( _Pointptr == 0 )
     {
     _Groupstring . append ( _Beforepoint, '0' );
     _Beforepoint = 0;
     }
    _Groupstring . insert ( _Eptr - _Buf, _Trailing, '0' );
    }
   _Trailing = 0;

   if ( _Pointptr == 0 )
    _Groupstring . append ( _Beforepoint, '0' );
   else
    {
    _Groupstring . insert ( _Pointptr - _Buf + 1, _Afterpoint, '0' );
    _Groupstring . insert ( _Pointptr - _Buf, _Beforepoint, '0' );
    _Afterpoint = 0;
    }
   _Beforepoint = 0;

   const char * _Pg = _Grouping . c_str ( );
   size_t _Off = :: strcspn ( & _Groupstring [ 0 ], & _Enders [ 0 ] );
   while ( * _Pg != 127 && '\000' < * _Pg
    && ( size_t ) * _Pg < _Off - _Prefix )
    {
    _Groupstring . insert ( _Off -= * _Pg, ( size_t ) 1, '\000' );
    if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
    }

   _Buf = & _Groupstring [ 0 ];
   _Trailing = 0;
   _Count = _Groupstring . size ( );
   }

  size_t _Fillcount = _Beforepoint + _Afterpoint + _Trailing + _Count;
  _Fillcount = _Iosbase . width ( ) <= 0
   || ( size_t ) _Iosbase . width ( ) <= _Fillcount
    ? 0 : ( size_t ) _Iosbase . width ( ) - _Fillcount;
  ios_base :: fmtflags _Adjustfield =
   _Iosbase . flags ( ) & ios_base :: adjustfield;
  if ( _Adjustfield != ios_base :: left
   && _Adjustfield != ios_base :: internal )
   {
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }
  else if ( _Adjustfield == ios_base :: internal )
   {
   if ( 0 < _Prefix )
    {
    _Dest = _Putc ( _Dest, _Buf, 1 );
    ++ _Buf, -- _Count;
    }
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }

  _Pointptr = ( const char * ) :: memchr ( _Buf,
   _Enders [ 0 ], _Count );
  if ( _Pointptr != 0 )
   {
   size_t _Fracoffset = _Pointptr - _Buf + 1;
   _Dest = _Putgrouped ( _Dest, _Buf, _Fracoffset - 1, _Kseparator );
   _Dest = _Rep ( _Dest, _E0, _Beforepoint );
   _Dest = _Rep ( _Dest, _Punct_fac . decimal_point ( ), 1 );
   _Dest = _Rep ( _Dest, _E0, _Afterpoint );
   _Buf += _Fracoffset, _Count -= _Fracoffset;
   }

  _Eptr = ( const char * ) :: memchr ( _Buf,
   'e', _Count );
  if ( _Eptr != 0 )
   {
   size_t _Expoffset = _Eptr - _Buf + 1;
   _Dest = _Putgrouped ( _Dest, _Buf, _Expoffset - 1, _Kseparator );
   _Dest = _Rep ( _Dest, _E0, _Trailing ), _Trailing = 0;
   _Dest = _Putc ( _Dest, _Iosbase . flags ( ) & ios_base :: uppercase
    ? "E" : "e", 1 );
   _Buf += _Expoffset, _Count -= _Expoffset;
   }

  _Dest = _Putgrouped ( _Dest, _Buf, _Count,
   _Kseparator );
  _Dest = _Rep ( _Dest, _E0, _Trailing );
  _Iosbase . width ( 0 );
  return ( _Rep ( _Dest, _Fill, _Fillcount ) );
  }

 char * __cdecl _Ifmt ( char * _Fmt,
  const char * _Spec, ios_base :: fmtflags _Flags ) const
  {
  char * _Ptr = _Fmt;
  * _Ptr ++ = '%';

  if ( _Flags & ios_base :: showpos )
   * _Ptr ++ = '+';
  if ( _Flags & ios_base :: showbase )
   * _Ptr ++ = '#';
  if ( _Spec [ 0 ] != 'L' )
   * _Ptr ++ = _Spec [ 0 ];
  else
   {
   * _Ptr ++ = 'I';
   * _Ptr ++ = '6';
   * _Ptr ++ = '4';
   }

  ios_base :: fmtflags _Basefield = _Flags & ios_base :: basefield;
  * _Ptr ++ = _Basefield == ios_base :: oct ? 'o'
   : _Basefield != ios_base :: hex ? _Spec [ 1 ]
   : _Flags & ios_base :: uppercase ? 'X' : 'x';
  * _Ptr = '\000';
  return ( _Fmt );
  }

 _OutIt __cdecl _Iput ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, char * _Buf, size_t _Count ) const
  {
  ;
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const size_t _Prefix = * _Buf == '+' || * _Buf == '-' ? 1
   : * _Buf == '0' && ( _Buf [ 1 ] == 'x' || _Buf [ 1 ] == 'X' ) ? 2
   : 0;

  if ( * _Grouping . c_str ( ) != 127 && '\000' < * _Grouping . c_str ( ) )
   {
   const char * _Pg = _Grouping . c_str ( );
   size_t _Off = _Count;
   while ( * _Pg != 127 && '\000' < * _Pg
    && ( size_t ) * _Pg < _Off - _Prefix )
    {
    _Off -= * _Pg;
    :: memmove_s ( ( & _Buf [ _Off + 1 ] ), ( _Count + 1 - _Off ), ( & _Buf [ _Off ] ), ( _Count + 1 - _Off ) );

    _Buf [ _Off ] = '\000', ++ _Count;
    if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
    }
   }

  size_t _Fillcount = _Iosbase . width ( ) <= 0
   || ( size_t ) _Iosbase . width ( ) <= _Count
    ? 0 : ( size_t ) _Iosbase . width ( ) - _Count;

  ios_base :: fmtflags _Adjustfield =
   _Iosbase . flags ( ) & ios_base :: adjustfield;
  if ( _Adjustfield != ios_base :: left
   && _Adjustfield != ios_base :: internal )
   {
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }
  else if ( _Adjustfield == ios_base :: internal )
   {
   _Dest = _Putc ( _Dest, _Buf, _Prefix );
   _Buf += _Prefix, _Count -= _Prefix;
   _Dest = _Rep ( _Dest, _Fill, _Fillcount ), _Fillcount = 0;
   }

  _Dest = _Putgrouped ( _Dest, _Buf, _Count,
   _Punct_fac . thousands_sep ( ) );
  _Iosbase . width ( 0 );
  return ( _Rep ( _Dest, _Fill, _Fillcount ) );
  }

 _OutIt __cdecl _Put ( _OutIt _Dest,
  const _Elem * _Ptr, size_t _Count ) const
  {
  for (; 0 < _Count; -- _Count, ++ _Dest, ++ _Ptr )
   * _Dest = * _Ptr;
  return ( _Dest );
  }

 _OutIt __cdecl _Putc ( _OutIt _Dest,
  const char * _Ptr, size_t _Count ) const
  {
  for (; 0 < _Count; -- _Count, ++ _Dest, ++ _Ptr )
   * _Dest = _Maklocchr ( * _Ptr, ( _Elem * ) 0, _Cvt );
  return ( _Dest );
  }

 _OutIt __cdecl _Putgrouped ( _OutIt _Dest,
  const char * _Ptr, size_t _Count, _Elem _Kseparator ) const
  {
  for (;; ++ _Ptr, -- _Count )
   {
   const char * _Pend =
    ( const char * ) :: memchr ( _Ptr, '\000', _Count );
   size_t _Groupsize = _Pend != 0 ? _Pend - _Ptr : _Count;

   _Dest = _Putc ( _Dest, _Ptr, _Groupsize );
   _Ptr += _Groupsize, _Count -= _Groupsize;
   if ( _Count == 0 )
    break;
   if ( _Kseparator != ( _Elem ) 0 )
    _Dest = _Rep ( _Dest, _Kseparator, 1 );
   }
  return ( _Dest );
  }

 _OutIt __cdecl _Rep ( _OutIt _Dest,
  _Elem _Ch, size_t _Count ) const
  {
  for (; 0 < _Count; -- _Count, ++ _Dest )
   * _Dest = _Ch;
  return ( _Dest );
  }
 };
#line 1552 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocnum"
template<class _Elem, class 
_OutIt> locale::id 
num_put< _Elem, _OutIt> ::id; 
#line 1574 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocnum"
#pragma warning(pop)
}


#pragma warning(pop)
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ios"
#pragma warning(push,3)
#line 1579 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xlocnum"
#pragma pack ( pop )
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ios"
#pragma pack ( push, 8 )
#line 13 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ios"
namespace std { 


template < class _Elem,
 class _Traits >
 class basic_ios
  : public ios_base
 {
public :
 typedef basic_ios < _Elem, _Traits > _Myt;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef ctype < _Elem > _Ctype;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 explicit basic_ios ( _Mysb * _Strbuf )
  {
  init ( _Strbuf );
  }

 virtual ~ basic_ios ( )
  {
  }

 void clear ( iostate _State = goodbit, bool _Reraise = false )
  {
  ios_base :: clear ( ( iostate ) ( _Mystrbuf == 0
   ? ( int ) _State | ( int ) badbit : ( int ) _State ), _Reraise );
  }

 void clear ( io_state _State )
  {
  clear ( ( iostate ) _State );
  }

 void setstate ( iostate _State, bool _Reraise = false )
  {
  if ( _State != goodbit )
   clear ( ( iostate ) ( ( int ) rdstate ( ) | ( int ) _State ), _Reraise );
  }

 void setstate ( io_state _State )
  {
  setstate ( ( iostate ) _State );
  }

 _Myt & copyfmt ( const _Myt & _Right )
  {
  _Tiestr = _Right . tie ( );
  _Fillch = _Right . fill ( );
  ios_base :: copyfmt ( _Right );
  return ( * this );
  }

 _Myos * tie ( ) const
  {
  return ( _Tiestr );
  }

 _Myos * tie ( _Myos * _Newtie )
  {
  _Myos * _Oldtie = _Tiestr;
  _Tiestr = _Newtie;
  return ( _Oldtie );
  }

 _Mysb * rdbuf ( ) const
  {
  return ( _Mystrbuf );
  }

 _Mysb * rdbuf ( _Mysb * _Strbuf )
  {
  _Mysb * _Oldstrbuf = _Mystrbuf;
  _Mystrbuf = _Strbuf;
  clear ( );
  return ( _Oldstrbuf );
  }

 locale imbue ( const locale & _Loc )
  {
  locale _Oldlocale = ios_base :: imbue ( _Loc );
  if ( rdbuf ( ) != 0 )
   rdbuf ( ) -> pubimbue ( _Loc );
  return ( _Oldlocale );
  }

 _Elem fill ( ) const
  {
  return ( _Fillch );
  }

 _Elem fill ( _Elem _Newfill )
  {
  _Elem _Oldfill = _Fillch;
  _Fillch = _Newfill;
  return ( _Oldfill );
  }

 char narrow ( _Elem _Ch, char _Dflt = '\000' ) const
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( getloc ( ) );
  return ( _Ctype_fac . narrow ( _Ch, _Dflt ) );
  }

 _Elem widen ( char _Byte ) const
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( getloc ( ) );
  return ( _Ctype_fac . widen ( _Byte ) );
  }

protected :
 void init ( _Mysb * _Strbuf = 0,
  bool _Isstd = false )
  {
  _Init ( );
  _Mystrbuf = _Strbuf;
  _Tiestr = 0;
  _Fillch = widen ( ' ' );

  if ( _Mystrbuf == 0 )
   setstate ( badbit );

  if ( _Isstd )
   _Addstd ( this );
  else
  _Stdstr = 0;
  }

  basic_ios ( )
  {
  }

private :
  basic_ios ( const _Myt & );
 _Myt & operator = ( const _Myt & );

 _Mysb * _Mystrbuf;
 _Myos * _Tiestr;
 _Elem _Fillch;
 };
#line 171 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ios"
inline ios_base &__cdecl boolalpha(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)16384); 
return _Iosbase; 
} 

inline ios_base &__cdecl dec(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)512, (_Iosb< int> ::_Fmtflags)3584); 
return _Iosbase; 
} 

inline ios_base &__cdecl fixed(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)8192, (_Iosb< int> ::_Fmtflags)12288); 
return _Iosbase; 
} 

inline ios_base &__cdecl hex(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)2048, (_Iosb< int> ::_Fmtflags)3584); 
return _Iosbase; 
} 

namespace tr1 { 
inline ios_base &__cdecl hexfloat(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)12288, (_Iosb< int> ::_Fmtflags)12288); 
return _Iosbase; 
} 
}
using tr1::hexfloat;

inline ios_base &__cdecl internal(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)256, (_Iosb< int> ::_Fmtflags)448); 
return _Iosbase; 
} 

inline ios_base &__cdecl left(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)64, (_Iosb< int> ::_Fmtflags)448); 
return _Iosbase; 
} 

inline ios_base &__cdecl noboolalpha(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)16384); 
return _Iosbase; 
} 

inline ios_base &__cdecl noshowbase(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)8); 
return _Iosbase; 
} 

inline ios_base &__cdecl noshowpoint(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)16); 
return _Iosbase; 
} 

inline ios_base &__cdecl noshowpos(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)32); 
return _Iosbase; 
} 

inline ios_base &__cdecl noskipws(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)1); 
return _Iosbase; 
} 

inline ios_base &__cdecl nounitbuf(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)2); 
return _Iosbase; 
} 

inline ios_base &__cdecl nouppercase(ios_base &_Iosbase) 
{ 
_Iosbase.unsetf((_Iosb< int> ::_Fmtflags)4); 
return _Iosbase; 
} 

inline ios_base &__cdecl oct(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)1024, (_Iosb< int> ::_Fmtflags)3584); 
return _Iosbase; 
} 

inline ios_base &__cdecl right(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)128, (_Iosb< int> ::_Fmtflags)448); 
return _Iosbase; 
} 

inline ios_base &__cdecl scientific(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)4096, (_Iosb< int> ::_Fmtflags)12288); 
return _Iosbase; 
} 

inline ios_base &__cdecl showbase(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)8); 
return _Iosbase; 
} 

inline ios_base &__cdecl showpoint(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)16); 
return _Iosbase; 
} 

inline ios_base &__cdecl showpos(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)32); 
return _Iosbase; 
} 

inline ios_base &__cdecl skipws(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)1); 
return _Iosbase; 
} 

inline ios_base &__cdecl unitbuf(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)2); 
return _Iosbase; 
} 

inline ios_base &__cdecl uppercase(ios_base &_Iosbase) 
{ 
_Iosbase.setf((_Iosb< int> ::_Fmtflags)4); 
return _Iosbase; 
} 
}


#pragma warning(pop)
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ostream"
#pragma warning(push,3)
#pragma warning(disable: 4390)
#line 315 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ios"
#pragma pack ( pop )
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ostream"
#pragma pack ( push, 8 )
#line 14 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ostream"
namespace std { 
#line 38 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ostream"
template < class _Elem,
 class _Traits >
 class basic_ostream
  : virtual public basic_ios < _Elem, _Traits >
 {
public :
 typedef basic_ostream < _Elem, _Traits > _Myt;
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef ostreambuf_iterator < _Elem, _Traits > _Iter;
 typedef num_put < _Elem, _Iter > _Nput;

 explicit basic_ostream ( basic_streambuf < _Elem, _Traits > * _Strbuf,
  bool _Isstd = false )
  {
  _Myios :: init ( _Strbuf, _Isstd );
  }

  basic_ostream ( _Uninitialized, bool _Addit = true )
  {
  if ( _Addit )
   ios_base :: _Addstd ( this );
  }

 virtual ~ basic_ostream ( )
  {
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 class _Sentry_base
  {
 public :
   _Sentry_base ( _Myt & _Ostr )
   : _Myostr ( _Ostr )
   {
   if ( _Myostr . rdbuf ( ) != 0 )
    _Myostr . rdbuf ( ) -> _Lock ( );
   }

   ~ _Sentry_base ( )
   {
   if ( _Myostr . rdbuf ( ) != 0 )
    _Myostr . rdbuf ( ) -> _Unlock ( );
   }

  _Myt & _Myostr;
  };

 class sentry
  : public _Sentry_base
  {
 public :
  explicit sentry ( _Myt & _Ostr )
   : _Sentry_base ( _Ostr )
   {
   if ( _Ostr . good ( ) && _Ostr . tie ( ) != 0 )
    _Ostr . tie ( ) -> flush ( );
   _Ok = _Ostr . good ( );
   }

   ~ sentry ( )
   {


   if ( ! std :: uncaught_exception ( ) )
    this -> _Myostr . _Osfx ( );
   }






   operator bool ( ) const
   {
   return ( _Ok );
   }

 private :
   sentry ( const sentry & );
  sentry & operator = ( const sentry & );

  bool _Ok;
  };

 bool opfx ( )
  {
  if ( ios_base :: good ( ) && _Myios :: tie ( ) != 0 )
   _Myios :: tie ( ) -> flush ( );
  return ( ios_base :: good ( ) );
  }

 void osfx ( )
  {
  _Osfx ( );
  }

 void _Osfx ( )
  {
  try {
  if ( ios_base :: flags ( ) & ios_base :: unitbuf )
   flush ( );
  } catch ( ... ) {
  }
  }
























 _Myt & operator << ( _Myt & ( __cdecl * _Pfn ) ( _Myt & ) )
  {
  ;
  return ( ( * _Pfn ) ( * this ) );
  }

 _Myt & operator << ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) )
  {
  ;
  ( * _Pfn ) ( * ( _Myios * ) this );
  return ( * this );
  }

 _Myt & operator << ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) )
  {
  ;
  ( * _Pfn ) ( * ( ios_base * ) this );
  return ( * this );
  }

 _Myt & operator << ( _Bool _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( short _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );
   ios_base :: fmtflags _Bfl =
    ios_base :: flags ( ) & ios_base :: basefield;
   long _Tmp = ( _Bfl == ios_base :: oct
    || _Bfl == ios_base :: hex )
    ? ( long ) ( unsigned short ) _Val : ( long ) _Val;

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Tmp ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }









 _Myt & operator << ( unsigned short _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( unsigned long ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( int __w64 _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );
   ios_base :: fmtflags _Bfl =
    ios_base :: flags ( ) & ios_base :: basefield;
   long _Tmp = ( _Bfl == ios_base :: oct
    || _Bfl == ios_base :: hex )
    ? ( long ) ( unsigned int ) _Val : ( long ) _Val;

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Tmp ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( unsigned int __w64 _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( unsigned long ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( long _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( unsigned long __w64 _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( unsigned long ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


 _Myt & operator << ( __int64 _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( unsigned __int64 _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


 _Myt & operator << ( float _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( double ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( double _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( long double _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( const void * _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( ios_base :: getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( _Mysb * _Strbuf )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  bool _Copied = false;
  const sentry _Ok ( * this );

  if ( _Ok && _Strbuf != 0 )
   for ( int_type _Meta = _Traits :: eof ( );; _Copied = true )
    {
    try {
    _Meta = _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta )
     ? _Strbuf -> sgetc ( ) : _Strbuf -> snextc ( );
    } catch ( ... ) {
     _Myios :: setstate ( ios_base :: failbit );
     throw;
    }

    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     break;

    try {
     if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
      _Myios :: rdbuf ( ) -> sputc (
       _Traits :: to_char_type ( _Meta ) ) ) )
      {
      _State |= ios_base :: badbit;
      break;
      }
    } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
    }

  ios_base :: width ( 0 );
  _Myios :: setstate ( _Strbuf == 0 ? ios_base :: badbit
   : ! _Copied ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

 _Myt & put ( _Elem _Ch )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( ! _Ok )
   _State |= ios_base :: badbit;
  else
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sputc ( _Ch ) ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & write ( const _Elem * _Str,
  streamsize _Count )
  {
  if ( 0 < _Count )
   ;
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( ! _Ok )
   _State |= ios_base :: badbit;
  else
   {
   try {
   if ( _Myios :: rdbuf ( ) -> sputn ( _Str, _Count ) != _Count )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & flush ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  if ( ! ios_base :: fail ( ) && _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 )
   _State |= ios_base :: badbit;
  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & seekp ( pos_type _Pos )
  {
  if ( ! ios_base :: fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekpos ( _Pos,
    ios_base :: out ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

 _Myt & seekp ( off_type _Off, ios_base :: seekdir _Way )
  {
  if ( ! ios_base :: fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way,
    ios_base :: out ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

 pos_type tellp ( )
  {
  if ( ! ios_base :: fail ( ) )
   return ( _Myios :: rdbuf ( ) -> pubseekoff ( 0,
    ios_base :: cur, ios_base :: out ) );
  else
   return ( pos_type ( _BADOFF ) );
  }
 };
#line 651 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ostream"
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & __cdecl operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, const char * _Val )
 {
 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) :: strlen ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  const ctype < _Elem > & _Ctype_fac = use_facet < ctype < _Elem > > ( _Ostr . getloc ( ) );
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  for (; _State == ios_base :: goodbit && 0 < _Count; -- _Count, ++ _Val )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( * _Val ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }

template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & __cdecl operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, char _Ch )
 {
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  const ctype < _Elem > & _Ctype_fac = use_facet < ctype < _Elem > > ( _Ostr . getloc ( ) );
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( _Ch ) ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }

template < class _Traits > inline
 basic_ostream < char, _Traits > & __cdecl operator << (
  basic_ostream < char, _Traits > & _Ostr,
  const char * _Val )
 {
 typedef char _Elem;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) _Traits :: length ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count )
   _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }

template < class _Traits > inline
 basic_ostream < char, _Traits > & __cdecl operator << (
  basic_ostream < char, _Traits > & _Ostr, char _Ch )
 {
 typedef char _Elem;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }

template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & __cdecl operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, const _Elem * _Val )
 {
 typedef basic_ostream < _Elem, _Traits > _Myos;
 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) _Traits :: length ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count )
   _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }

template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & __cdecl operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, _Elem _Ch )
 {
 typedef basic_ostream < _Elem, _Traits > _Myos;
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }

template < class _Traits > inline
 basic_ostream < char, _Traits > & __cdecl operator << (
  basic_ostream < char, _Traits > & _Ostr, const signed char * _Val )
 {
 return ( _Ostr << ( const char * ) _Val );
 }

template < class _Traits > inline
 basic_ostream < char, _Traits > & __cdecl operator << (
  basic_ostream < char, _Traits > & _Ostr, signed char _Ch )
 {
 return ( _Ostr << ( char ) _Ch );
 }

template < class _Traits > inline
 basic_ostream < char, _Traits > & __cdecl operator << (
  basic_ostream < char, _Traits > & _Ostr, const unsigned char * _Val )
 {
 return ( _Ostr << ( const char * ) _Val );
 }

template < class _Traits > inline
 basic_ostream < char, _Traits > & __cdecl operator << (
  basic_ostream < char, _Traits > & _Ostr, unsigned char _Ch )
 {
 return ( _Ostr << ( char ) _Ch );
 }


template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl endl ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . put ( _Ostr . widen ( '\n' ) );
 _Ostr . flush ( );
 return ( _Ostr );
 }

template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl ends ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . put ( _Elem ( ) );
 return ( _Ostr );
 }

template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl flush ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . flush ( );
 return ( _Ostr );
 }


inline basic_ostream< char, char_traits< char> >  &__cdecl endl(basic_ostream< char, char_traits< char> >  &_Ostr) 
{ 
_Ostr.put('\n'); 
_Ostr.flush(); 
return _Ostr; 
} 


inline basic_ostream< __wchar_t, char_traits< __wchar_t> >  &__cdecl endl(basic_ostream< __wchar_t, char_traits< __wchar_t> >  &
_Ostr) 
{ 
_Ostr.put('\n'); 
_Ostr.flush(); 
return _Ostr; 
} 



inline basic_ostream< char, char_traits< char> >  &__cdecl ends(basic_ostream< char, char_traits< char> >  &_Ostr) 
{ 
_Ostr.put('\000'); 
return _Ostr; 
} 


inline basic_ostream< __wchar_t, char_traits< __wchar_t> >  &__cdecl ends(basic_ostream< __wchar_t, char_traits< __wchar_t> >  &
_Ostr) 
{ 
_Ostr.put('\000'); 
return _Ostr; 
} 



inline basic_ostream< char, char_traits< char> >  &__cdecl flush(basic_ostream< char, char_traits< char> >  &_Ostr) 
{ 
_Ostr.flush(); 
return _Ostr; 
} 


inline basic_ostream< __wchar_t, char_traits< __wchar_t> >  &__cdecl flush(basic_ostream< __wchar_t, char_traits< __wchar_t> >  &
_Ostr) 
{ 
_Ostr.flush(); 
return _Ostr; 
} 
#line 1019 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ostream"
}


#pragma warning(default: 4390)
#pragma warning(pop)
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\istream"
#pragma warning(push,3)
#line 1024 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\ostream"
#pragma pack ( pop )
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\istream"
#pragma pack ( push, 8 )
#line 13 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\istream"
namespace std { 


template < class _Elem,
 class _Traits >
 class basic_istream
  : virtual public basic_ios < _Elem, _Traits >
 {
public :
 typedef basic_istream < _Elem, _Traits > _Myt;
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef istreambuf_iterator < _Elem, _Traits > _Iter;
 typedef ctype < _Elem > _Ctype;
 typedef num_get < _Elem, _Iter > _Nget;


 explicit basic_istream ( _Mysb * _Strbuf, bool _Isstd = false )
  : _Chcount ( 0 )
  {
  _Myios :: init ( _Strbuf, _Isstd );
  }

  basic_istream ( _Uninitialized )
  {
  ios_base :: _Addstd ( this );
  }

 virtual ~ basic_istream ( )
  {
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;


 class _Sentry_base
  {
 public :
   _Sentry_base ( _Myt & _Istr )
   : _Myistr ( _Istr )
   {
   if ( _Myistr . rdbuf ( ) != 0 )
    _Myistr . rdbuf ( ) -> _Lock ( );
   }

   ~ _Sentry_base ( )
   {
   if ( _Myistr . rdbuf ( ) != 0 )
    _Myistr . rdbuf ( ) -> _Unlock ( );
   }

  _Myt & _Myistr;
  };

 class sentry
  : public _Sentry_base
  {
 public :
  explicit sentry ( _Myt & _Istr, bool _Noskip = false )
   : _Sentry_base ( _Istr )
   {
   _Ok = this -> _Myistr . _Ipfx ( _Noskip );
   }

   operator bool ( ) const
   {
   return ( _Ok );
   }

 private :
   sentry ( const sentry & );
  sentry & operator = ( const sentry & );

  bool _Ok;
  };

 bool _Ipfx ( bool _Noskip = false )
  {
  if ( ios_base :: good ( ) )
   {
   if ( _Myios :: tie ( ) != 0 )
    _Myios :: tie ( ) -> flush ( );

   if ( ! _Noskip && ios_base :: flags ( ) & ios_base :: skipws )
    {
    const _Ctype & _Ctype_fac = use_facet < _Ctype > ( ios_base :: getloc ( ) );

    try {
    int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

    for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
     if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
      {
      _Myios :: setstate ( ios_base :: eofbit );
      break;
      }
     else if ( ! _Ctype_fac . is ( _Ctype :: space,
      _Traits :: to_char_type ( _Meta ) ) )
      break;
    } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
    }

   if ( ios_base :: good ( ) )
    return ( true );
   }
  _Myios :: setstate ( ios_base :: failbit );
  return ( false );
  }

 bool ipfx ( bool _Noskip = false )
  {
  return _Ipfx ( _Noskip );
  }

 void isfx ( )
  {
  }























 _Myt & operator >> ( _Myt & ( __cdecl * _Pfn ) ( _Myt & ) )
  {
  ;
  return ( ( * _Pfn ) ( * this ) );
  }

 _Myt & operator >> ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) )
  {
  ;
  ( * _Pfn ) ( * ( _Myios * ) this );
  return ( * this );
  }

 _Myt & operator >> ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) )
  {
  ;
  ( * _Pfn ) ( * ( ios_base * ) this );
  return ( * this );
  }

 _Myt & operator >> ( _Bool & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( short & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   long _Tmp = 0;
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Tmp );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }

   if ( _State & ios_base :: failbit
    || _Tmp < ( - 32768 ) || 32767 < _Tmp )
    _State |= ios_base :: failbit;
   else
    _Val = ( short ) _Tmp;
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }









 _Myt & operator >> ( unsigned short & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( int & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   long _Tmp = 0;
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Tmp );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }

   if ( _State & ios_base :: failbit
    || _Tmp < ( - 2147483647 - 1 ) || 2147483647 < _Tmp )
    _State |= ios_base :: failbit;
   else
    _Val = _Tmp;
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( unsigned int & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );
  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( long & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );
   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( unsigned long __w64 & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


 _Myt & operator >> ( __int64 & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( unsigned __int64 & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );
  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


 _Myt & operator >> ( float & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( double & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );
  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( long double & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );
   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( void * & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( ios_base :: getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( _Mysb * _Strbuf )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  bool _Copied = false;
  const sentry _Ok ( * this );

  if ( _Ok && _Strbuf != 0 )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     try {
      if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
       _Strbuf -> sputc ( _Traits :: to_char_type ( _Meta ) ) ) )
       break;
     } catch ( ... ) {
      break;
     }
     _Copied = true;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( ! _Copied ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

 int_type get ( )
  {
  int_type _Meta = 0;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( ! _Ok )
   _Meta = _Traits :: eof ( );
  else
   {
   try {
   _Meta = _Myios :: rdbuf ( ) -> sbumpc ( );

   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    _State |= ios_base :: eofbit | ios_base :: failbit;
   else
    ++ _Chcount;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( _Meta );
  }

 _Myt & get ( _Elem * _Str, streamsize _Count )
  {
  return ( get ( _Str, _Count, _Myios :: widen ( '\n' ) ) );
  }

 _Myt & get ( _Elem * _Str,
  streamsize _Count, _Elem _Delim )
  {
  ;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (; 0 < -- _Count; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( _Traits :: to_char_type ( _Meta ) == _Delim )
     break;
    else
     {
     * _Str ++ = _Traits :: to_char_type ( _Meta );
     ++ _Chcount;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _Chcount == 0
   ? _State | ios_base :: failbit : _State );
  * _Str = _Elem ( );
  return ( * this );
  }

 _Myt & get ( _Elem & _Ch )
  {
  int_type _Meta = get ( );
  if ( ! _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   _Ch = _Traits :: to_char_type ( _Meta );
  return ( * this );
  }

 _Myt & get ( _Mysb & _Strbuf )
  {
  return ( get ( _Strbuf, _Myios :: widen ( '\n' ) ) );
  }

 _Myt & get ( _Mysb & _Strbuf, _Elem _Delim )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     try {
      _Elem _Ch = _Traits :: to_char_type ( _Meta );
      if ( _Ch == _Delim
       || _Traits :: eq_int_type ( _Traits :: eof ( ),
        _Strbuf . sputc ( _Ch ) ) )
       break;
     } catch ( ... ) {
      break;
     }
     ++ _Chcount;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  if ( _Chcount == 0 )
   _State |= ios_base :: failbit;
  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & getline ( _Elem * _Str, streamsize _Count )
  {
  return ( getline ( _Str, _Count, _Myios :: widen ( '\n' ) ) );
  }

 _Myt & getline ( _Elem * _Str,
  streamsize _Count, _Elem _Delim )
  {
  ;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   int_type _Metadelim = _Traits :: to_int_type ( _Delim );

   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( _Meta == _Metadelim )
     {
     ++ _Chcount;
     _Myios :: rdbuf ( ) -> sbumpc ( );
     break;
     }
    else if ( -- _Count <= 0 )
     {
     _State |= ios_base :: failbit;
     break;
     }
    else
     {
     ++ _Chcount;
     * _Str ++ = _Traits :: to_char_type ( _Meta );
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  * _Str = _Elem ( );
  _Myios :: setstate ( _Chcount == 0 ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

 _Myt & ignore ( streamsize _Count = 1,
  int_type _Metadelim = _Traits :: eof ( ) )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   try {
   for (;; )
    {
    int_type _Meta;
    if ( _Count != 2147483647 && -- _Count < 0 )
     break;
    else if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Meta = _Myios :: rdbuf ( ) -> sbumpc ( ) ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     ++ _Chcount;
     if ( _Meta == _Metadelim )
      break;
     }
    }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & _Read_s ( _Elem * _Str, size_t _Str_size, streamsize _Count )
  {
  ;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   const streamsize _Num = _Myios :: rdbuf ( ) -> _Sgetn_s ( _Str, _Str_size, _Count );
   _Chcount += _Num;
   if ( _Num != _Count )
    _State |= ios_base :: eofbit | ios_base :: failbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & read ( _Elem * _Str, streamsize _Count )
  {
  return _Read_s ( _Str, ( size_t ) - 1, _Count );
  }

 streamsize _Readsome_s ( _Elem * _Str, size_t _Str_size, streamsize _Count )
  {
  ;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );
  streamsize _Num;

  if ( ! _Ok )
   _State |= ios_base :: failbit;
  else if ( ( _Num = _Myios :: rdbuf ( ) -> in_avail ( ) ) < 0 )
   _State |= ios_base :: eofbit;
  else if ( 0 < _Num )
   _Read_s ( _Str, _Str_size, _Num < _Count ? _Num : _Count );

  _Myios :: setstate ( _State );
  return ( gcount ( ) );
  }

 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
 streamsize readsome ( _Elem * _Str, streamsize _Count )
  {
  return _Readsome_s ( _Str, ( size_t ) - 1, _Count );
  }

 int_type peek ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  int_type _Meta = 0;
  const sentry _Ok ( * this, true );

  if ( ! _Ok )
   _Meta = _Traits :: eof ( );
  else
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Meta = _Myios :: rdbuf ( ) -> sgetc ( ) ) )
    _State |= ios_base :: eofbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( _Meta );
  }

 _Myt & putback ( _Elem _Ch )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sputbackc ( _Ch ) ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & unget ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sungetc ( ) ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 streamsize gcount ( ) const
  {
  return ( _Chcount );
  }

 int sync ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  int _Ans;

  if ( _Myios :: rdbuf ( ) == 0 )
   _Ans = - 1;
  else if ( _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 )
   {
   _State |= ios_base :: badbit;
   _Ans = - 1;
   }
  else
   _Ans = 0;

  _Myios :: setstate ( _State );
  return ( _Ans );
  }

 _Myt & seekg ( pos_type _Pos )
  {
  if ( ! ios_base :: fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekpos ( _Pos,
    ios_base :: in ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  return ( * this );
  }

 _Myt & seekg ( off_type _Off, ios_base :: seekdir _Way )
  {
  if ( ! ios_base :: fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way,
    ios_base :: in ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  return ( * this );
  }

 pos_type tellg ( )
  {
  if ( ! ios_base :: fail ( ) )
   return ( _Myios :: rdbuf ( ) -> pubseekoff ( 0,
    ios_base :: cur, ios_base :: in ) );
  else
   return ( pos_type ( _BADOFF ) );
  }

private :
 streamsize _Chcount;
 };
#line 898 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\istream"
template < class _Elem,
 class _Traits >
 class basic_iostream
 : public basic_istream < _Elem, _Traits >,
  public basic_ostream < _Elem, _Traits >
 {
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 explicit basic_iostream ( basic_streambuf < _Elem, _Traits > * _Strbuf )
  : basic_istream < _Elem, _Traits > ( _Strbuf, false ),
   basic_ostream < _Elem, _Traits > ( _Noinit, false )
  {
  }

 virtual ~ basic_iostream ( )
  {
  }
 };
#line 932 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\istream"
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & __cdecl operator >> (
  basic_istream < _Elem, _Traits > & _Istr, _Elem * _Str )
 {
 ;
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef ctype < _Elem > _Ctype;
 ios_base :: iostate _State = ios_base :: goodbit;
 _Elem * _Str0 = _Str;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( _Istr . getloc ( ) );

  try {
  streamsize _Count = 0 < _Istr . width ( ) ? _Istr . width ( ) : 2147483647;
  typename _Myis :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );
  _Elem _Ch;
  for (; 0 < -- _Count; _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    {
    _State |= ios_base :: eofbit;
    break;
    }
   else if ( _Ctype_fac . is ( _Ctype :: space,
    _Ch = _Traits :: to_char_type ( _Meta ) )
     || _Ch == _Elem ( ) )
    break;
   else
    * _Str ++ = _Traits :: to_char_type ( _Meta );
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 * _Str = _Elem ( );
 _Istr . width ( 0 );
 _Istr . setstate ( _Str == _Str0 ? _State | ios_base :: failbit : _State );
 return ( _Istr );
 }

template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & __cdecl operator >> (
  basic_istream < _Elem, _Traits > & _Istr, _Elem & _Ch )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;
 typename _Myis :: int_type _Meta;
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  try {
  _Meta = _Istr . rdbuf ( ) -> sbumpc ( );
  if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   _State |= ios_base :: eofbit | ios_base :: failbit;
  else
   _Ch = _Traits :: to_char_type ( _Meta );
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Istr . setstate ( _State );
 return ( _Istr );
 }


template < class _Traits > inline
 basic_istream < char, _Traits > & __cdecl operator >> (
  basic_istream < char, _Traits > & _Istr, signed char * _Str )
 {
 return ( _Istr >> ( char * ) _Str );
 }

template < class _Traits > inline
 basic_istream < char, _Traits > & __cdecl operator >> (
  basic_istream < char, _Traits > & _Istr, signed char & _Ch )
 {
 return ( _Istr >> ( char & ) _Ch );
 }

template < class _Traits > inline
 basic_istream < char, _Traits > & __cdecl operator >> (
  basic_istream < char, _Traits > & _Istr, unsigned char * _Str )
 {
 return ( _Istr >> ( char * ) _Str );
 }

template < class _Traits > inline
 basic_istream < char, _Traits > & __cdecl operator >> (
  basic_istream < char, _Traits > & _Istr, unsigned char & _Ch )
 {
 return ( _Istr >> ( char & ) _Ch );
 }
#line 1030 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\istream"
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > &
  __cdecl ws ( basic_istream < _Elem, _Traits > & _Istr )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef ctype < _Elem > _Ctype;

 if ( ! _Istr . eof ( ) )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const typename _Myis :: sentry _Ok ( _Istr, true );

  if ( _Ok )
   {
   const _Ctype & _Ctype_fac = use_facet < _Ctype > ( _Istr . getloc ( ) );

   try {
   for ( typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );;
    _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( ! _Ctype_fac . is ( _Ctype :: space,
     _Traits :: to_char_type ( _Meta ) ) )
     break;
   } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
   }

  _Istr . setstate ( _State );
  }
 return ( _Istr );
 }


inline basic_istream< char, char_traits< char> >  &__cdecl ws(basic_istream< char, char_traits< char> >  &_Istr) 
{ 
typedef char _Elem; 
typedef char_traits< char>  _Traits; 

if (!_Istr.eof()) 
{ 
auto ios_base::iostate _State = ((_Iosb< int> ::_Iostate)0); 
auto const basic_istream< char, char_traits< char> > ::sentry _Ok(_Istr, true); 

if (_Ok) 
{ 
auto const ctype< char>  &_Ctype_fac = use_facet< ctype< char> > (_Istr.getloc()); 


try { 
for (char_traits< char> ::int_type _Meta = (*_Istr.rdbuf()).sgetc(); ; _Meta = (*_Istr.rdbuf()).snextc()) { 

if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
{ 
_State |= ((_Iosb< int> ::_Iostate)1); 
break; 
} else { 
if (!_Ctype_fac.is(ctype< char> ::space, _Traits::to_char_type(_Meta))) { 

break; }  }  }  
} catch (...) { _Istr.setstate((_Iosb< int> ::_Iostate)4, true); }  
}  

_Istr.setstate(_State); 
}  
return _Istr; 
} 


inline basic_istream< __wchar_t, char_traits< __wchar_t> >  &__cdecl ws(basic_istream< __wchar_t, char_traits< __wchar_t> >  &_Istr) 
{ 
typedef __wchar_t _Elem; 
typedef char_traits< __wchar_t>  _Traits; 

if (!_Istr.eof()) 
{ 
auto ios_base::iostate _State = ((_Iosb< int> ::_Iostate)0); 
auto const basic_istream< __wchar_t, char_traits< __wchar_t> > ::sentry _Ok(_Istr, true); 

if (_Ok) 
{ 
auto const ctype< __wchar_t>  &_Ctype_fac = use_facet< ctype< __wchar_t> > (_Istr.getloc()); 


try { 
for (char_traits< __wchar_t> ::int_type _Meta = (*_Istr.rdbuf()).sgetc(); ; _Meta = (*_Istr.rdbuf()).snextc()) { 

if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
{ 
_State |= ((_Iosb< int> ::_Iostate)1); 
break; 
} else { 
if (!_Ctype_fac.is(ctype< __wchar_t> ::space, _Traits::to_char_type(_Meta))) { 

break; }  }  }  
} catch (...) { _Istr.setstate((_Iosb< int> ::_Iostate)4, true); }  
}  

_Istr.setstate(_State); 
}  
return _Istr; 
} 
#line 1159 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\istream"
}


#pragma warning(pop)
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iostream"
#pragma warning(push,3)
#line 1163 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\istream"
#pragma pack ( pop )
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iostream"
#pragma pack ( push, 8 )
#line 12 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iostream"
namespace std { 



extern istream *_Ptr_cin; 
extern ostream *_Ptr_cout; 
extern ostream *_Ptr_cerr; 
extern ostream *_Ptr_clog; 
#line 24 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iostream"
class _Winit { 

public: __thiscall _Winit(); 
__thiscall ~_Winit(); 

private: static int _Init_cnt; 
}; 
#line 35 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iostream"
extern wistream *_Ptr_wcin; 
extern wostream *_Ptr_wcout; 
extern wostream *_Ptr_wcerr; 
extern wostream *_Ptr_wclog; 
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iostream"
extern istream cin; 
extern ostream cout; 
extern ostream cerr; 
extern ostream clog; 

extern wistream wcin; 
extern wostream wcout; 
extern wostream wcerr; 
extern wostream wclog; 
#line 62 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iostream"
}

#pragma warning(pop)
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iterator"
#pragma warning(push,3)
#line 65 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iostream"
#pragma pack ( pop )
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iterator"
#pragma pack ( push, 8 )
#line 13 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iterator"
namespace std { 


template < class _Container >
 class back_insert_iterator
  : public _Outit
 {
public :
 typedef _Container container_type;
 typedef typename _Container :: reference reference;

 typedef _Range_checked_iterator_tag _Checked_iterator_category;

 explicit back_insert_iterator ( _Container & _Cont )
  : container ( & _Cont )
  {
  }

 back_insert_iterator < _Container > & operator = (
  typename _Container :: const_reference _Val )
  {
  container -> push_back ( _Val );
  return ( * this );
  }

 back_insert_iterator < _Container > & operator * ( )
  {
  return ( * this );
  }

 back_insert_iterator < _Container > & operator ++ ( )
  {
  return ( * this );
  }

 back_insert_iterator < _Container > operator ++ ( int )
  {
  return ( * this );
  }

protected :
 _Container * container;
 };


template < class _Container > inline
 back_insert_iterator < _Container > back_inserter ( _Container & _Cont )
 {
 return ( std :: back_insert_iterator < _Container > ( _Cont ) );
 }


template < class _Container >
 class front_insert_iterator
  : public _Outit
 {
public :
 typedef _Container container_type;
 typedef typename _Container :: reference reference;

 typedef _Range_checked_iterator_tag _Checked_iterator_category;

 explicit front_insert_iterator ( _Container & _Cont )
  : container ( & _Cont )
  {
  }

 front_insert_iterator < _Container > & operator = (
  typename _Container :: const_reference _Val )
  {
  container -> push_front ( _Val );
  return ( * this );
  }

 front_insert_iterator < _Container > & operator * ( )
  {
  return ( * this );
  }

 front_insert_iterator < _Container > & operator ++ ( )
  {
  return ( * this );
  }

 front_insert_iterator < _Container > operator ++ ( int )
  {
  return ( * this );
  }

protected :
 _Container * container;
 };


template < class _Container > inline
 front_insert_iterator < _Container > front_inserter ( _Container & _Cont )
 {
 return ( std :: front_insert_iterator < _Container > ( _Cont ) );
 }


template < class _Container >
 class insert_iterator
  : public _Outit
 {
public :
 typedef _Container container_type;
 typedef typename _Container :: reference reference;

 typedef _Range_checked_iterator_tag _Checked_iterator_category;

 insert_iterator ( _Container & _Cont, typename _Container :: iterator _Where )
  : container ( & _Cont ), iter ( _Where )
  {
  }

 insert_iterator < _Container > & operator = (
  typename _Container :: const_reference _Val )
  {
  iter = container -> insert ( iter, _Val );
  ++ iter;
  return ( * this );
  }

 insert_iterator < _Container > & operator * ( )
  {
  return ( * this );
  }

 insert_iterator < _Container > & operator ++ ( )
  {
  return ( * this );
  }

 insert_iterator < _Container > & operator ++ ( int )
  {
  return ( * this );
  }

protected :
 _Container * container;
 typename _Container :: iterator iter;
 };


template < class _Container,
 class _Iter > inline
 insert_iterator < _Container > inserter ( _Container & _Cont, _Iter _Where )
 {
 return ( std :: insert_iterator < _Container > ( _Cont, _Where ) );
 }


template < class _Ty,
 class _Elem = char,
 class _Traits = char_traits < _Elem >,
 class _Diff = ptrdiff_t >
 class istream_iterator
  : public iterator < input_iterator_tag, _Ty, _Diff,
   const _Ty *, const _Ty & >
 {
 typedef istream_iterator < _Ty, _Elem, _Traits, _Diff > _Myt;
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_istream < _Elem, _Traits > istream_type;


 typedef _Range_checked_iterator_tag _Checked_iterator_category;


 istream_iterator ( )
  : _Myistr ( 0 )
  {
  }

 istream_iterator ( istream_type & _Istr )
  : _Myistr ( & _Istr )
  {
  _Getval ( );
  }

 const _Ty & operator * ( ) const
  {








  { if ( ! ( _Myistr != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };


  return ( _Myval );
  }

 const _Ty * operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myt & operator ++ ( )
  {








  { if ( ! ( _Myistr != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };


  _Getval ( );
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 bool _Equal ( const _Myt & _Right ) const
  {
  return ( _Myistr == _Right . _Myistr );
  }

protected :
 void _Getval ( )
  {
  if ( _Myistr != 0 && ! ( * _Myistr >> _Myval ) )
   _Myistr = 0;
  }

 static void _Xran ( )
  {
  throw out_of_range ( "invalid istream_iterator" );
  }

 istream_type * _Myistr;
 _Ty _Myval;
 };
#line 262 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iterator"
template < class _Ty,
 class _Elem,
 class _Traits,
 class _Diff > inline
 bool operator == (
  const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Left,
  const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }

template < class _Ty,
 class _Elem,
 class _Traits,
 class _Diff > inline
 bool operator != (
  const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Left,
  const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }


template < class _Ty,
 class _Elem = char,
 class _Traits = char_traits < _Elem > >
 class ostream_iterator
  : public _Outit
 {
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_ostream < _Elem, _Traits > ostream_type;


 typedef _Range_checked_iterator_tag _Checked_iterator_category;


 ostream_iterator ( ostream_type & _Ostr,
  const _Elem * _Delim = 0 )
  : _Myostr ( & _Ostr ), _Mydelim ( _Delim )
  {
  }

 ostream_iterator < _Ty, _Elem, _Traits > & operator = ( const _Ty & _Val )
  {
  * _Myostr << _Val;
  if ( _Mydelim != 0 )
   * _Myostr << _Mydelim;








  { if ( ! ( * _Myostr != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };


  return ( * this );
  }

 ostream_iterator < _Ty, _Elem, _Traits > & operator * ( )
  {
  return ( * this );
  }

 ostream_iterator < _Ty, _Elem, _Traits > & operator ++ ( )
  {
  return ( * this );
  }

 ostream_iterator < _Ty, _Elem, _Traits > operator ++ ( int )
  {
  return ( * this );
  }

protected :
 static void _Xran ( )
  {
  throw out_of_range ( "invalid ostream_iterator" );
  }

 const _Elem * _Mydelim;
 ostream_type * _Myostr;
 };
#line 350 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iterator"
}

namespace stdext { 


template < class _Cont, class _Iter = typename _Cont :: iterator >
 class checked_iterator
  : public :: std :: iterator <
   typename :: std :: iterator_traits < _Iter > :: iterator_category,
   typename :: std :: iterator_traits < _Iter > :: value_type,
   typename :: std :: iterator_traits < _Iter > :: difference_type,
   typename :: std :: iterator_traits < _Iter > :: pointer,
   typename :: std :: iterator_traits < _Iter > :: reference >
 {
 friend class checked_iterator;
public :
 typedef checked_iterator < _Cont, _Iter > _Myt;
 typedef typename :: std :: iterator_traits < _Iter > :: difference_type difference_type;
 typedef typename :: std :: iterator_traits < _Iter > :: pointer pointer;
 typedef typename :: std :: iterator_traits < _Iter > :: reference reference;

 typedef :: std :: _Range_checked_iterator_tag _Checked_iterator_category;
 typedef _Iter _Inner_type;

 typedef _Iter _Checked_iterator_base_type;

 _Checked_iterator_base_type _Checked_iterator_base ( ) const
 {
  return _Current;
 }

 void _Checked_iterator_assign_from_base ( _Checked_iterator_base_type _Base )
 {
  _Current = _Base;
 }



 checked_iterator ( )
  : _Mycont ( 0 )
 {
 }

 checked_iterator ( _Cont & _C, _Iter _Ptr )
  : _Mycont ( & _C ), _Current ( _Ptr )
 {
 }

 checked_iterator ( const _Myt & _Right )
  : _Mycont ( _Right . _Mycont ), _Current ( _Right . _Current )
 {
 }

 template < class Iter2 >
 checked_iterator ( const checked_iterator < _Cont, Iter2 > & _Right )
  : _Mycont ( _Right . _Mycont ), _Current ( _Right . _Current )
 {
 }

 _Iter base ( ) const
 {
  { if ( ! ( _Mycont != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  return _Current;
 }

 template < class Iter2 >
 bool operator == ( const checked_iterator < _Cont, Iter2 > & _Right ) const
 {
  { if ( ! ( _Mycont == _Right . _Mycont ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  return _Current == _Right . _Current;
 }

 template < class Iter2 >
 bool operator != ( const checked_iterator < _Cont, Iter2 > & _Right ) const
 {
  { if ( ! ( _Mycont != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  return ! ( * this == _Right );
 }

 template < class Iter2 >
 bool operator < ( const checked_iterator < _Cont, Iter2 > & _Right ) const
 {
  { if ( ! ( _Mycont != 0 && _Mycont == _Right . _Mycont ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  return _Current < _Right . _Current;
 }

 template < class Iter2 >
 bool operator > ( const checked_iterator < _Cont, Iter2 > & _Right ) const
 {
  return _Right < * this;
 }

 template < class Iter2 >
 bool operator <= ( const checked_iterator < _Cont, Iter2 > & _Right ) const
 {
  return ! ( _Right < * this );
 }

 template < class Iter2 >
 bool operator >= ( const checked_iterator < _Cont, Iter2 > & _Right ) const
 {
  return ! ( * this < _Right );
 }

 reference operator * ( ) const
 {
  { if ( ! ( _Mycont != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  { if ( ! ( _Current != _Mycont -> end ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  return * _Current;
 }

 pointer operator -> ( ) const
 {
  return ( & * * this );
 }

 _Myt & operator ++ ( )
 {
  { if ( ! ( _Mycont != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  { if ( ! ( _Current != _Mycont -> end ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  ++ _Current;
  return * this;
 }

 _Myt operator ++ ( int )
 {
  _Myt _Tmp = * this;
  ++ * this;
  return _Tmp;
 }

 _Myt & operator -- ( )
 {
  { if ( ! ( _Mycont != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  { if ( ! ( _Current != _Mycont -> begin ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  -- _Current;
  return * this;
 }

 _Myt operator -- ( int )
 {
  _Myt _Tmp = * this;
  -- * this;
  return _Tmp;
 }



 _Myt & operator += ( difference_type _Off )
 {
  { if ( ! ( _Mycont != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  { if ( ! ( ( _Mycont -> end ( ) - _Current ) >= _Off && ( _Mycont -> begin ( ) - _Current ) <= _Off ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  _Current += _Off;
  return * this;
 }

 _Myt operator + ( difference_type _Off ) const
 {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
 }

 _Myt & operator -= ( difference_type _Off )
 {
  return ( * this += - _Off );
 }

 _Myt operator - ( difference_type _Off ) const
 {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
 }

 difference_type operator - ( const _Myt & _Right ) const
 {
  { if ( ! ( _Mycont != 0 && _Mycont == _Right . _Mycont ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  return _Current - _Right . _Current;
 }

 reference operator [ ] ( difference_type _Off ) const
 {
  { if ( ! ( _Mycont != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  { if ( ! ( ( _Mycont -> end ( ) - _Current ) > _Off && ( _Mycont -> begin ( ) - _Current ) <= _Off ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  return _Current [ _Off ];
 }

protected :
 void _Xran ( ) const
 {
  throw :: std :: out_of_range ( "invalid checked_iterator<T> subscript" );
 }

 void _Xinvarg ( ) const
 {
  throw :: std :: invalid_argument ( "invalid checked_iterator<T> argument" );
 }

 _Cont * _Mycont;
 _Iter _Current;
 };

}


#pragma warning(pop)
#line 11 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
#pragma warning(push,3)
#line 555 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\iterator"
#pragma pack ( pop )
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
#pragma pack ( push, 8 )
#line 13 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
namespace std { 


template < class _Ty > inline
 pair < _Ty *, ptrdiff_t >
  get_temporary_buffer ( ptrdiff_t _Count )
 {
 _Ty * _Pbuf;

 if ( _Count <= 0 )
  _Count = 0;
 else if ( ( ( size_t ) ( - 1 ) / _Count ) < sizeof ( _Ty ) )
  throw std :: bad_alloc ( 0 );

 for ( _Pbuf = 0; 0 < _Count; _Count /= 2 )
  if ( ( _Pbuf = ( _Ty * ) operator new (
   ( size_t ) _Count * sizeof ( _Ty ), nothrow ) ) != 0 )
   break;

 return ( pair < _Ty *, ptrdiff_t > ( _Pbuf, _Count ) );
 }


template < class _Ty > inline
 void return_temporary_buffer ( _Ty * _Pbuf )
 {
 operator delete ( _Pbuf );
 }


template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninit_copy ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {
 ;
 ;
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++ _Dest, ++ _First )
  _Construct ( & * _Dest, * _First );
 } catch ( ... ) {
 for (; _Next != _Dest; ++ _Next )
  _Destroy ( & * _Next );
 throw;
 }
 return ( _Dest );
 }

template < class _Ty1,
 class _Ty2 > inline
 _Ty2 _Uninit_copy ( _Ty1 _First, _Ty1 _Last, _Ty2 _Dest,
  _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {
 ;
 ;
 size_t _Count = ( size_t ) ( _Last - _First );
 _Ty2 _Result = _Dest + _Count;
 if ( _Count > 0 )
  :: memmove_s ( ( & * _Dest ), ( _Count * sizeof ( * _First ) ), ( & * _First ), ( _Count * sizeof ( * _First ) ) );

 return ( _Result );
 }
#line 81 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
template < class _InIt,
 class _FwdIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _FwdIt > :: _Result, _FwdIt > :: _Result uninitialized_copy ( _InIt _First, _InIt _Last, _FwdIt _Dest )
 {
 return ( _Uninit_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _FwdElem, size_t _Size >
inline
_FwdElem * uninitialized_copy ( _InIt _First, _InIt _Last, _FwdElem ( & _Dest ) [ _Size ] )
 {
 return ( uninitialized_copy ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _InIt,
 class _FwdIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _FwdIt > :: _Result, _FwdIt > :: _Result uninitialized_copy ( _InIt _First, _InIt _Last, _FwdIt _Dest )
 {
 return ( _Uninit_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
  _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }
#line 119 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninit_copy ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {
 ;
 ;
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++ _Dest, ++ _First )
  _Al . construct ( _Dest, * _First );
 } catch ( ... ) {
 for (; _Next != _Dest; ++ _Next )
  _Al . destroy ( _Next );
 throw;
 }
 return ( _Dest );
 }

template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninit_copy ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc &, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {
 ;
 ;
 size_t _Count = ( size_t ) ( _Last - _First );
 _FwdIt _Result = _Dest + _Count;
 if ( _Count > 0 )
  :: memmove_s ( ( & * _Dest ), ( _Count * sizeof ( * _First ) ), ( & * _First ), ( _Count * sizeof ( * _First ) ) );
 return ( _Result );
 }



template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _FwdIt > :: _Result, _FwdIt > :: _Result _Uninitialized_copy ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al )
 {
 return ( _Uninit_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Al,
  _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _FwdElem, class _Alloc, size_t _Size >
inline
_FwdElem * _Uninitialized_copy ( _InIt _First, _InIt _Last, _FwdElem ( & _Dest ) [ _Size ],
  _Alloc & _Al )
 {
 return ( _Uninitialized_copy ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Al ) . base ( ) );
 }

template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _FwdIt > :: _Result, _FwdIt > :: _Result _Uninitialized_copy ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al )
 {
 return ( _Uninit_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Al,
  _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }
#line 202 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
template < class _InIt, class _FwdIt, class _Alloc, class _MoveCatTy >
inline
 _FwdIt _Uninit_move ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al, _MoveCatTy, _Range_checked_iterator_tag )
 {
 return ( :: stdext :: unchecked_uninitialized_copy ( _First, _Last, _Dest, _Al ) );
 }

template < class _InIt, class _FwdIt, class _Alloc >
inline
 _FwdIt _Uninit_move ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al, _Swap_move_tag, _Range_checked_iterator_tag )
 {
 ;
 ;
 _FwdIt _Next = _Dest;

 typename _Alloc :: value_type _Val;

 try {
 for (; _First != _Last; ++ _Dest, ++ _First )
  {
  _Al . construct ( _Dest, _Val );
  :: std :: _Swap_adl ( * _Dest, * _First );
  }
 } catch ( ... ) {
 for (; _Next != _Dest; ++ _Next )
  _Al . destroy ( _Next );
 throw;
 }
 return ( _Dest );
 }



template < class _InIt, class _FwdIt, class _Alloc >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _FwdIt > :: _Result, _FwdIt > :: _Result _Uninitialized_move ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al )
 {
 return ( _Uninit_move ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Al,
  _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _FwdElem, class _Alloc, size_t _Size >
inline
_FwdElem * _Uninitialized_move ( _InIt _First, _InIt _Last, _FwdElem ( & _Dest ) [ _Size ],
  _Alloc & _Al )
 {
 return ( _Uninitialized_move ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Al ) . base ( ) );
 }

template < class _InIt, class _FwdIt, class _Alloc >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _FwdIt > :: _Result, _FwdIt > :: _Result _Uninitialized_move ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc & _Al )
 {
 return ( _Uninit_move ( :: std :: _Checked_base ( _First ),
  :: std :: _Checked_base ( _Last ), _Dest, _Al,
  _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }
#line 281 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
template < class _FwdIt,
 class _Tval > inline
 void _Uninit_fill ( _FwdIt _First, _FwdIt _Last, const _Tval & _Val,
  _Nonscalar_ptr_iterator_tag )
 {
 ;
 _FwdIt _Next = _First;

 try {
 for (; _First != _Last; ++ _First )
  _Construct ( & * _First, _Val );
 } catch ( ... ) {
 for (; _Next != _First; ++ _Next )
  _Destroy ( & * _Next );
 throw;
 }
 }

template < class _Ty,
 class _Tval > inline
 void _Uninit_fill ( _Ty * _First, _Ty * _Last, const _Tval & _Val,
  _Scalar_ptr_iterator_tag )
 {
 std :: fill ( _First, _Last, _Val );
 }

template < class _FwdIt,
 class _Tval > inline
 void uninitialized_fill ( _FwdIt _First, _FwdIt _Last, const _Tval & _Val )
 {
 _Uninit_fill ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Val, _Ptr_cat ( _First, _First ) );
 }


template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 void _Uninit_fill_n ( _FwdIt _First, _Diff _Count, const _Tval & _Val,
  _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {






 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; -- _Count, ++ _First )
  _Construct ( & * _First, _Val );
 } catch ( ... ) {
 for (; _Next != _First; ++ _Next )
  _Destroy ( & * _Next );
 throw;
 }
 }
#line 339 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 void _Uninit_fill_n ( _FwdIt _First, _Diff _Count, const _Tval & _Val,
  _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {
 :: stdext :: unchecked_fill_n ( & * _First, _Count, _Val );
 }



template < class _FwdIt,
 class _Diff,
 class _Tval > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _FwdIt > :: _Result, void > :: _Result uninitialized_fill_n ( _FwdIt _First, _Diff _Count, const _Tval & _Val )
 {
 _Uninit_fill_n ( _First, _Count, _Val, _Ptr_cat ( _First, _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdElem, class _Diff, class _Tval, size_t _Size >
inline
void uninitialized_fill_n ( _FwdElem ( & _First ) [ _Size ], _Diff _Count, const _Tval & _Val )
 {
 uninitialized_fill_n ( :: stdext :: make_checked_array_iterator ( _First, _Size ), _Count, _Val );
 }

template < class _FwdIt,
 class _Diff,
 class _Tval > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _FwdIt > :: _Result, void > :: _Result uninitialized_fill_n ( _FwdIt _First, _Diff _Count, const _Tval & _Val )
 {
 _Uninit_fill_n ( _First, _Count, _Val, _Ptr_cat ( _First, _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 387 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc > inline
 void _Uninit_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval & _Val, _Alloc & _Al, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {






 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; -- _Count, ++ _First )
  _Al . construct ( _First, _Val );
 } catch ( ... ) {
 for (; _Next != _First; ++ _Next )
  _Al . destroy ( _Next );
 throw;
 }
 }
#line 412 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc > inline
 void _Uninit_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval & _Val, _Alloc &, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag )
 {
  :: stdext :: unchecked_fill_n ( _First, _Count, _Val );
 }



template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _FwdIt > :: _Result, void > :: _Result _Uninitialized_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval & _Val, _Alloc & _Al )
 {
 _Uninit_fill_n ( _First, _Count, _Val, _Al,
  _Ptr_cat ( _First, _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdElem, class _Diff, class _Tval, class _Alloc, size_t _Size >
inline
void _Uninitialized_fill_n ( _FwdElem ( & _First ) [ _Size ], _Diff _Count,
  const _Tval & _Val, _Alloc & _Al )
 {
 _Uninitialized_fill_n ( :: stdext :: make_checked_array_iterator ( _First, _Size ), _Count, _Val, _Al );
 }

template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _FwdIt > :: _Result, void > :: _Result _Uninitialized_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval & _Val, _Alloc & _Al )
 {
 _Uninit_fill_n ( _First, _Count, _Val, _Al,
  _Ptr_cat ( _First, _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 471 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
template < class _FwdIt,
 class _Ty >
 class raw_storage_iterator
  : public _Outit
 {
public :
 typedef _FwdIt iterator_type;
 typedef _FwdIt iter_type;
 typedef _Ty element_type;

 explicit raw_storage_iterator ( _FwdIt _First )
  : _Next ( _First )
  {
  }

 raw_storage_iterator < _FwdIt, _Ty > & operator * ( )
  {
  return ( * this );
  }

 raw_storage_iterator < _FwdIt, _Ty > & operator = ( const _Ty & _Val )
  {
  _Construct ( & * _Next, _Val );
  return ( * this );
  }

 raw_storage_iterator < _FwdIt, _Ty > & operator ++ ( )
  {
  ++ _Next;
  return ( * this );
  }

 raw_storage_iterator < _FwdIt, _Ty > operator ++ ( int )
  {
  raw_storage_iterator < _FwdIt, _Ty > _Ans = * this;
  ++ _Next;
  return ( _Ans );
  }

private :
 _FwdIt _Next;
 };


template < class _Ty >
 class _Temp_iterator
  : public _Outit
 {
public :
 typedef _Ty * _Pty;


 typedef _Range_checked_iterator_tag _Checked_iterator_category;


 _Temp_iterator ( ptrdiff_t _Count = 0 )
  {
  _Buf . _Begin = 0;
  _Buf . _Current = 0;
  _Buf . _Hiwater = 0;
  _Buf . _Size = _Count;
  _Pbuf = & _Buf;
  }

 _Temp_iterator ( const _Temp_iterator < _Ty > & _Right )
  {
  _Buf . _Begin = 0;
  _Buf . _Current = 0;
  _Buf . _Hiwater = 0;
  _Buf . _Size = 0;
  * this = _Right;
  }

 ~ _Temp_iterator ( )
  {
  if ( _Buf . _Begin != 0 )
   {
   for ( _Pty _Next = _Buf . _Begin;
    _Next != _Buf . _Hiwater; ++ _Next )
    _Destroy ( & * _Next );
   std :: return_temporary_buffer ( _Buf . _Begin );
   }
  }

 _Temp_iterator < _Ty > & operator = ( const _Temp_iterator < _Ty > & _Right )
  {
  _Pbuf = _Right . _Pbuf;
  return ( * this );
  }

 _Temp_iterator < _Ty > & operator = ( const _Ty & _Val )
  {
  if ( _Pbuf -> _Current < _Pbuf -> _Hiwater )
   * _Pbuf -> _Current ++ = _Val;
  else
   {
   { if ( ! ( ( _Pbuf -> _Current - _Pbuf -> _Begin ) < _Pbuf -> _Size ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
   _Pty _Ptr = & * _Pbuf -> _Current;
   _Construct ( _Ptr, _Val );
   _Pbuf -> _Hiwater = ++ _Pbuf -> _Current;
   }
  return ( * this );
  }

 _Temp_iterator < _Ty > & operator * ( )
  {
  return ( * this );
  }

 _Temp_iterator < _Ty > & operator ++ ( )
  {
  return ( * this );
  }

 _Temp_iterator < _Ty > & operator ++ ( int )
  {
  return ( * this );
  }

 _Temp_iterator < _Ty > & _Init ( )
  {
  _Pbuf -> _Current = _Pbuf -> _Begin;
  return ( * this );
  }

 _Pty _First ( ) const
  {
  return ( _Pbuf -> _Begin );
  }

 _Pty _Last ( ) const
  {
  return ( _Pbuf -> _Current );
  }

 ptrdiff_t _Maxlen ( )
  {
  if ( _Pbuf -> _Begin == 0 && 0 < _Pbuf -> _Size )
   {
   pair < _Pty, ptrdiff_t > _Pair =
    std :: get_temporary_buffer < _Ty > ( _Pbuf -> _Size );

   _Pbuf -> _Begin = _Pair . first;
   _Pbuf -> _Current = _Pair . first;
   _Pbuf -> _Hiwater = _Pair . first;
   _Pbuf -> _Size = _Pair . second;
   }
  return ( _Pbuf -> _Size );
  }

 static void _Xinvarg ( )
  {
  throw invalid_argument ( "invalid _Temp_iterator<T> argument" );
  }

private :
 struct _Bufpar
  {
  _Pty _Begin;
  _Pty _Current;
  _Pty _Hiwater;
  ptrdiff_t _Size;
  };
 _Bufpar _Buf;
 _Bufpar * _Pbuf;
 };
#line 639 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
template < class _Ty >
 class auto_ptr;

template < class _Ty >
 struct auto_ptr_ref
  {
 explicit auto_ptr_ref ( _Ty * _Right )
  : _Ref ( _Right )
  {
  }

 _Ty * _Ref;
 };

template < class _Ty >
 class auto_ptr
  {
public :
 typedef _Ty element_type;

 explicit auto_ptr ( _Ty * _Ptr = 0 ) throw ( )
  : _Myptr ( _Ptr )
  {
  }

 auto_ptr ( auto_ptr < _Ty > & _Right ) throw ( )
  : _Myptr ( _Right . release ( ) )
  {
  }

 auto_ptr ( auto_ptr_ref < _Ty > _Right ) throw ( )
  {
  _Ty * _Ptr = _Right . _Ref;
  _Right . _Ref = 0;
  _Myptr = _Ptr;
  }

 template < class _Other >
  operator auto_ptr < _Other > ( ) throw ( )
  {
  return ( auto_ptr < _Other > ( * this ) );
  }

 template < class _Other >
  operator auto_ptr_ref < _Other > ( ) throw ( )
  {
  _Other * _Cvtptr = _Myptr;
  auto_ptr_ref < _Other > _Ans ( _Cvtptr );
  _Myptr = 0;
  return ( _Ans );
  }


 template < class _Other >
  auto_ptr < _Ty > & operator = ( auto_ptr < _Other > & _Right ) throw ( )
  {
  reset ( _Right . release ( ) );
  return ( * this );
  }

 template < class _Other >
  auto_ptr ( auto_ptr < _Other > & _Right ) throw ( )
  : _Myptr ( _Right . release ( ) )
  {
  }

 auto_ptr < _Ty > & operator = ( auto_ptr < _Ty > & _Right ) throw ( )
  {
  reset ( _Right . release ( ) );
  return ( * this );
  }

 auto_ptr < _Ty > & operator = ( auto_ptr_ref < _Ty > _Right ) throw ( )
  {
  _Ty * _Ptr = _Right . _Ref;
  _Right . _Ref = 0;
  reset ( _Ptr );
  return ( * this );
  }

 ~ auto_ptr ( )
  {
  delete _Myptr;
  }

 _Ty & operator * ( ) const throw ( )
  {






  ;

  return ( * get ( ) );
  }

 _Ty * operator -> ( ) const throw ( )
  {






  return ( get ( ) );
  }

 _Ty * get ( ) const throw ( )
  {
  return ( _Myptr );
  }

 _Ty * release ( ) throw ( )
  {
  _Ty * _Tmp = _Myptr;
  _Myptr = 0;
  return ( _Tmp );
  }

 void reset ( _Ty * _Ptr = 0 )
  {
  if ( _Ptr != _Myptr )
   delete _Myptr;
  _Myptr = _Ptr;
  }

private :
 _Ty * _Myptr;
 };
#line 770 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
}

namespace stdext { 

template < class _InIt,
 class _FwdIt > inline
 _FwdIt unchecked_uninitialized_copy ( _InIt _First, _InIt _Last,
  _FwdIt _Dest )
 {
  return ( :: std :: _Uninit_copy ( :: std :: _Checked_base ( _First ),
   :: std :: _Checked_base ( _Last ), _Dest,
   :: std :: _Ptr_cat ( _First, _Dest ),
   :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt,
 class _FwdIt > inline
 typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _FwdIt > :: _Result, _FwdIt > :: _Result checked_uninitialized_copy ( _InIt _First, _InIt _Last,
  _FwdIt _Dest )
 {
 return ( :: std :: _Uninit_copy ( :: std :: _Checked_base ( _First ),
   :: std :: _Checked_base ( _Last ), _Dest,
   :: std :: _Ptr_cat ( _First, _Dest ),
   :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _FwdElem, size_t _Size > inline
 _FwdElem * checked_uninitialized_copy ( _InIt _First, _InIt _Last,
  _FwdElem ( & _Dest ) [ _Size ] )
 {
 return ( checked_uninitialized_copy ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _InIt,
 class _FwdIt > inline
 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) ) typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _FwdIt > :: _Result, _FwdIt > :: _Result
  checked_uninitialized_copy ( _InIt _First, _InIt _Last, _FwdIt _Dest )
 {
 return ( :: std :: _Uninit_copy ( :: std :: _Checked_base ( _First ),
  :: std :: _Checked_base ( _Last ), _Dest,
  :: std :: _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt unchecked_uninitialized_copy ( _InIt _First, _InIt _Last,
  _FwdIt _Dest, _Alloc & _Al )
 {
 return ( :: std :: _Uninit_copy ( :: std :: _Checked_base ( _First ),
  :: std :: _Checked_base ( _Last ), _Dest, _Al,
  :: std :: _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _FwdIt > :: _Result, _FwdIt > :: _Result checked_uninitialized_copy ( _InIt _First, _InIt _Last,
  _FwdIt _Dest, _Alloc & _Al )
 {
 return ( :: std :: _Uninit_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ),
  _Dest, _Al,
  :: std :: _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _FwdElem, class _Alloc, size_t _Size > inline
 _FwdElem * checked_uninitialized_copy ( _InIt _First, _InIt _Last,
  _FwdElem ( & _Dest ) [ _Size ], _Alloc & _Al )
 {
 return ( checked_uninitialized_copy ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Al ) . base ( ) );
 }

template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) ) typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _FwdIt > :: _Result, _FwdIt > :: _Result
  checked_uninitialized_copy ( _InIt _First, _InIt _Last,
  _FwdIt _Dest, _Alloc & _Al )
 {
 return ( :: std :: _Uninit_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ),
  _Dest, _Al,
  :: std :: _Ptr_cat ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Unchecked_uninitialized_move ( _InIt _First, _InIt _Last,
  _FwdIt _Dest, _Alloc & _Al )
 {
 return ( :: std :: _Uninit_move ( :: std :: _Checked_base ( _First ),
  :: std :: _Checked_base ( _Last ), _Dest, _Al,
  :: std :: _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _FwdIt, class _Alloc > inline
 typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _FwdIt > :: _Result, _FwdIt > :: _Result _Checked_uninitialized_move ( _InIt _First, _InIt _Last,
  _FwdIt _Dest, _Alloc & _Al )
 {
 return ( :: std :: _Uninit_move ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ),
  _Dest, _Al,
  :: std :: _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _FwdElem, class _Alloc, size_t _Size > inline
 _FwdElem * _Checked_uninitialized_move ( _InIt _First, _InIt _Last,
  _FwdElem ( & _Dest ) [ _Size ], _Alloc & _Al )
 {
 return ( _Checked_uninitialized_move ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Al ) . base ( ) );
 }

template < class _InIt, class _FwdIt, class _Alloc > inline
 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) ) typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _FwdIt > :: _Result, _FwdIt > :: _Result
  _Checked_uninitialized_move ( _InIt _First, _InIt _Last,
   _FwdIt _Dest, _Alloc & _Al )
 {
 return ( :: std :: _Uninit_move ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ),
  _Dest, _Al,
  :: std :: _Move_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 void unchecked_uninitialized_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval & _Val )
 {
 :: std :: _Uninit_fill_n ( _First, _Count, _Val,
  :: std :: _Ptr_cat ( _First, _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _FwdIt > :: _Result, void > :: _Result
  checked_uninitialized_fill_n ( _FwdIt _First, _Diff _Count,
   const _Tval & _Val )
 {
 :: std :: _Uninit_fill_n ( _First, _Count, _Val,
  :: std :: _Ptr_cat ( _First, _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdElem, class _Diff, class _Tval, size_t _Size > inline
 void checked_uninitialized_fill_n ( _FwdElem ( & _First ) [ _Size ],
  _Diff _Count, const _Tval & _Val )
 {
 checked_uninitialized_fill_n (
  :: stdext :: make_checked_array_iterator ( _First, _Size ), _Count, _Val );
 }

template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) ) typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _FwdIt > :: _Result, void > :: _Result
  checked_uninitialized_fill_n ( _FwdIt _First, _Diff _Count,
   const _Tval & _Val )
 {
 :: std :: _Uninit_fill_n ( _First, _Count, _Val,
  :: std :: _Ptr_cat ( _First, _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc > inline
 void unchecked_uninitialized_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval & _Val, _Alloc & _Al )
 {
 :: std :: _Uninit_fill_n ( _First, _Count, _Val, _Al,
  :: std :: _Ptr_cat ( _First, _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc > inline
 typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _FwdIt > :: _Result, void > :: _Result
  checked_uninitialized_fill_n ( _FwdIt _First, _Diff _Count,
   const _Tval & _Val, _Alloc & _Al )
 {
 :: std :: _Uninit_fill_n ( _First, _Count, _Val, _Al,
  :: std :: _Ptr_cat ( _First, _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdElem,
 class _Diff,
 class _Tval,
 class _Alloc,
 size_t _Size > inline
 void checked_uninitialized_fill_n ( _FwdElem ( & _First ) [ _Size ],
  _Diff _Count, const _Tval & _Val, _Alloc & _Al )
 {
 checked_uninitialized_fill_n (
  :: stdext :: make_checked_array_iterator ( _First, _Size ),
  _Count, _Val, _Al );
 }

template < class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc > inline
 __declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) ) typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _FwdIt > :: _Result, void > :: _Result
  checked_uninitialized_fill_n ( _FwdIt _First, _Diff _Count,
   const _Tval & _Val, _Alloc & _Al )
 {
 :: std :: _Uninit_fill_n ( _First, _Count, _Val, _Al,
  :: std :: _Ptr_cat ( _First, _First ), :: std :: _Range_checked_iterator_tag ( ) );
 }

}
#line 993 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
extern "C" long __cdecl _InterlockedIncrement(volatile long *); 
extern "C" long __cdecl _InterlockedDecrement(volatile long *); 
extern "C" long __cdecl _InterlockedCompareExchange(volatile long *, long, long); 


#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedCompareExchange)
#line 1007 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
namespace std { 
namespace tr1 { 


class bad_weak_ptr : public exception { 



public: explicit bad_weak_ptr(const char * = 0) 
{ 
} 

virtual const char *what() const throw() 
{ 
return "tr1::bad_weak_ptr"; 
} 
}; 

extern __declspec( noreturn ) void __cdecl _Xweak(); 


class _Ref_count_base { 


virtual void _Destroy() = 0; 
virtual void _Delete_this() = 0; 

const volatile void *_Ptr; 
long _Uses; 
long _Weaks; 


protected: _Ref_count_base(const volatile void *_Px) : _Ptr(_Px), _Uses((0)), _Weaks((1)) 

{ 
} 


public: virtual ~_Ref_count_base() 
{ 
} 

bool _Incref_nz() 
{ 
for (; ;) 
{ 
auto long _Count = ((volatile long &)(this->_Uses)); 
if (_Count == (0)) { 
return false; }  
if (_InterlockedCompareExchange(&(this->_Uses), _Count + (1), _Count) == _Count) { 
return true; }  
}  
} 

void _Incref() 
{ 
_InterlockedIncrement(&(this->_Uses)); 
} 

void _Incwref() 
{ 
_InterlockedIncrement(&(this->_Weaks)); 
} 

void _Decref() 
{ 
if (_InterlockedDecrement(&(this->_Uses)) == (0)) 
{ 
this->_Destroy(); 
this->_Decwref(); 
}  
} 

void _Decwref() 
{ 
if (_InterlockedDecrement(&(this->_Weaks)) == (0)) { 
this->_Delete_this(); }  
} 

long _Use_count() const 
{ 
return this->_Uses; 
} 

bool _Expired() const 
{ 
return (this->_Uses) == (0); 
} 

virtual void *_Get_deleter(const type_info &) const 
{ 
return 0; 
} 

const volatile void *_Getptr() const 
{ 
return this->_Ptr; 
} 
}; 


template < class _Ty >
 class _Ref_count
 : public _Ref_count_base
 {
public :
 _Ref_count ( _Ty * _Px )
  : _Ref_count_base ( _Px )
  {
  }

private :
 virtual void _Destroy ( )
  {
  delete ( _Ty * ) _Getptr ( );
  }

 virtual void _Delete_this ( )
  {
  delete this;
  }
 };

template < class _Ty,
 class _Dx,
 class _Alloc = std :: allocator < int > >
 class _Ref_count_d
 : public _Ref_count_base
 {
public :
 typedef _Ref_count_d < _Ty, _Dx, _Alloc > _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Ref_count_d ( _Ty * _Px, _Dx _Dt, _Myalty _Al = _Myalty ( ) )
  : _Ref_count_base ( _Px ), _Dtor ( _Dt ), _Myal ( _Al )
  {
  }

 void * _Get_deleter ( const type_info & _Type ) const
  {
  return ( ( void * ) ( _Type == typeid ( _Dx ) ? & _Dtor : 0 ) );
  }

private :
 virtual void _Destroy ( )
  {
  _Dtor ( ( _Ty * ) _Getptr ( ) );
  }

 virtual void _Delete_this ( )
  {
  _Myalty _Al = _Myal;
  _Al . destroy ( this );
  _Al . deallocate ( this, 1 );
  }

 _Myalty _Myal;
 _Dx _Dtor;
 };


template < class _Ty >
 class weak_ptr;
template < class _Ty >
 class shared_ptr;
template < class _Ty >
 class enable_shared_from_this;
struct _Static_tag { }; 
struct _Const_tag { }; 
struct _Dynamic_tag { }; 

template < class _Ty1,
 class _Ty2 >
 void _Do_enable ( _Ty1 *, enable_shared_from_this < _Ty2 > *, _Ref_count_base * );

template < class _Ty >
 inline void _Enable_shared ( _Ty * _Ptr, _Ref_count_base * _Refptr,
  typename _Ty :: _EStype * = 0 )
 {
 if ( _Ptr )
  _Do_enable ( _Ptr,
   ( enable_shared_from_this < typename _Ty :: _EStype > * ) _Ptr, _Refptr );
 }

inline void _Enable_shared(const volatile void *, const volatile void *) 
{ 
} 


template < class _Ty >
 class _Ptr_base
 {
public :
 typedef _Ty _Elem;
 typedef _Elem element_type;

 _Ptr_base ( )
  : _Ptr ( 0 ), _Rep ( 0 )
  {
  }

 long use_count ( ) const
  {
  return ( _Rep ? _Rep -> _Use_count ( ) : 0 );
  }

 void _Swap ( _Ptr_base & _Other )
  {
  :: std :: swap ( _Rep, _Other . _Rep );
  :: std :: swap ( _Ptr, _Other . _Ptr );
  }

 template < class _Ty2 >
  bool _Cmp ( const _Ptr_base < _Ty2 > & _Right ) const
  {
  return ( _Rep < _Right . _Rep );
  }

 void * _Get_deleter ( const type_info & _Type ) const
  {
  return ( _Rep ? _Rep -> _Get_deleter ( _Type ) : 0 );
  }

 _Ty * _Get ( ) const
  {
  return ( _Ptr );
  }

 bool _Expired ( ) const
  {
  return ( ! _Rep || _Rep -> _Expired ( ) );
  }

 void _Decref ( )
  {
  if ( _Rep != 0 )
   _Rep -> _Decref ( );
  }

 void _Reset ( )
  {
  _Reset ( 0, 0 );
  }

 template < class _Ty2 >
  void _Reset ( const _Ptr_base < _Ty2 > & _Other )
  {
  _Reset ( _Other . _Ptr, _Other . _Rep );
  }

 template < class _Ty2 >
  void _Reset ( const _Ptr_base < _Ty2 > & _Other, bool _Throw )
  {
  _Reset ( _Other . _Ptr, _Other . _Rep, _Throw );
  }

 template < class _Ty2 >
  void _Reset ( const _Ptr_base < _Ty2 > & _Other, const _Static_tag & )
  {
  _Reset ( static_cast < _Elem * > ( _Other . _Ptr ), _Other . _Rep );
  }

 template < class _Ty2 >
  void _Reset ( const _Ptr_base < _Ty2 > & _Other, const _Const_tag & )
  {
  _Reset ( const_cast < _Elem * > ( _Other . _Ptr ), _Other . _Rep );
  }
 template < class _Ty2 >
  void _Reset ( const _Ptr_base < _Ty2 > & _Other, const _Dynamic_tag & )
  {
  _Elem * _Ptr = dynamic_cast < _Elem * > ( _Other . _Ptr );
  if ( _Ptr )
   _Reset ( _Ptr, _Other . _Rep );
  else
   _Reset ( );
  }

 template < class _Ty2 >
  void _Reset ( auto_ptr < _Ty2 > & _Other )
  {
  _Ty2 * _Px = _Other . get ( );
  _Reset ( _Px, new _Ref_count < _Elem > ( _Px ) );
  _Other . release ( );
  }

 void _Reset ( _Ty * _Other_ptr, _Ref_count_base * _Other_rep )
  {
  if ( _Other_rep )
   _Other_rep -> _Incref ( );
  if ( _Rep != 0 )
   _Rep -> _Decref ( );
  _Rep = _Other_rep;
  _Ptr = _Other_ptr;
  }

 void _Reset ( _Ty * _Other_ptr, _Ref_count_base * _Other_rep, bool _Throw )
  {


  if ( _Other_rep && _Other_rep -> _Incref_nz ( ) )
   {
   if ( _Rep != 0 )
    _Rep -> _Decref ( );
   _Rep = _Other_rep;
   _Ptr = _Other_ptr;
   }
  else if ( _Throw )
   _Xweak ( );
  }

 void _Decwref ( )
  {
  if ( _Rep != 0 )
   _Rep -> _Decwref ( );
  }

 void _Resetw ( )
  {
  _Resetw ( ( _Elem * ) 0, 0 );
  }

 template < class _Ty2 >
  void _Resetw ( const _Ptr_base < _Ty2 > & _Other )
  {
  _Resetw ( _Other . _Ptr, _Other . _Rep );
  }

 template < class _Ty2 >
  void _Resetw ( const _Ty2 * _Other_ptr, _Ref_count_base * _Other_rep )
  {
  _Resetw ( const_cast < _Ty2 * > ( _Other_ptr ), _Other_rep );
  }

 template < class _Ty2 >
  void _Resetw ( _Ty2 * _Other_ptr, _Ref_count_base * _Other_rep )
  {
  if ( _Other_rep )
   _Other_rep -> _Incwref ( );
  if ( _Rep != 0 )
   _Rep -> _Decwref ( );
  _Rep = _Other_rep;
  _Ptr = _Other_ptr;
  }

private :
 _Ty * _Ptr;
 _Ref_count_base * _Rep;
 template < class _Ty0 >
  friend class _Ptr_base;
 };


template<class _Ty> 
struct _Ref { 

typedef _Ty &_Type; 
}; 


template<> struct _Ref< void>  { 

typedef void _Type; 
}; 


template<> struct _Ref< const void>  { 

typedef void _Type; 
}; 


template<> struct _Ref< volatile void>  { 

typedef void _Type; 
}; 


template<> struct _Ref< const volatile void>  { 

typedef void _Type; 
}; 


template < class _Ty >
 class shared_ptr
  : public _Ptr_base < _Ty >
 {
public :
 shared_ptr ( )
  {
  this -> _Reset ( );
  }

 template < class _Ux >
  explicit shared_ptr ( _Ux * _Px )
  {
  _Resetp ( _Px );
  }

 template < class _Ux,
  class _Dx >
  shared_ptr ( _Ux * _Px, _Dx _Dt )
  {
  _Resetp ( _Px, _Dt );
  }

 template < class _Ux,
  class _Dx,
  class _Alloc >
  shared_ptr ( _Ux * _Px, _Dx _Dt, _Alloc _Ax )
  {
  _Resetp ( _Px, _Dt, _Ax );
  }

 shared_ptr ( const shared_ptr & _Other )
  {
  this -> _Reset ( _Other );
  }

 template < class _Ty2 >
  shared_ptr ( const shared_ptr < _Ty2 > & _Other )
  {
  this -> _Reset ( _Other );
  }

 template < class _Ty2 >
  explicit shared_ptr ( const weak_ptr < _Ty2 > & _Other,
   bool _Throw = true )
  {
  this -> _Reset ( _Other, _Throw );
  }

 template < class _Ty2 >
  explicit shared_ptr ( auto_ptr < _Ty2 > & _Other )
  {
  this -> _Reset ( _Other );
  }

 template < class _Ty2 >
  shared_ptr ( const shared_ptr < _Ty2 > & _Other, const _Static_tag & _Tag )
  {
  this -> _Reset ( _Other, _Tag );
  }

 template < class _Ty2 >
  shared_ptr ( const shared_ptr < _Ty2 > & _Other, const _Const_tag & _Tag )
  {
  this -> _Reset ( _Other, _Tag );
  }

 template < class _Ty2 >
  shared_ptr ( const shared_ptr < _Ty2 > & _Other, const _Dynamic_tag & _Tag )
  {
  this -> _Reset ( _Other, _Tag );
  }

 ~ shared_ptr ( )
  {
  this -> _Decref ( );
  }

 shared_ptr & operator = ( const shared_ptr & _Right )
  {
  this -> _Reset ( _Right );
  return ( * this );
  }

 template < class _Ty2 >
  shared_ptr & operator = ( const shared_ptr < _Ty2 > & _Right )
  {
  this -> _Reset ( _Right );
  return ( * this );
  }

 template < class _Ty2 >
  shared_ptr & operator = ( auto_ptr < _Ty2 > & _Right )
  {
  this -> _Reset ( _Right );
  return ( * this );
  }

 void reset ( )
  {
  this -> _Reset ( );
  }

 template < class _Ux >
  void reset ( _Ux * _Px )
  {
  _Resetp ( _Px );
  }

 template < class _Ux,
  class _Dx >
  void reset ( _Ux * _Px, _Dx _Dt )
  {
  _Resetp ( _Px, _Dt );
  }

 template < class _Ux,
  class _Dx,
  class _Alloc >
  void reset ( _Ux * _Px, _Dx _Dt, _Alloc _Ax )
  {
  _Resetp ( _Px, _Dt, _Ax );
  }

 void swap ( shared_ptr & _Other )
  {
  this -> _Swap ( _Other );
  }

 _Ty * get ( ) const
  {
  return ( this -> _Get ( ) );
  }

 typename _Ref < _Ty > :: _Type operator * ( ) const
  {
  return ( * this -> _Get ( ) );
  }

 _Ty * operator -> ( ) const
  {
  return ( this -> _Get ( ) );
  }

 bool unique ( ) const
  {
  return ( this -> use_count ( ) == 1 );
  }

 operator :: std :: _Bool_type ( ) const
  {
  return ( this -> _Get ( ) != 0 ? ( & :: std :: _Bool_struct :: _Member ) : 0 );
  }

private :
 template < class _Ux >
  void _Resetp ( _Ux * _Px )
  {
  try {
  _Resetp0 ( _Px, new _Ref_count < _Ux > ( _Px ) );
  } catch ( ... ) {
  delete _Px;
  throw;
  }
  }

 template < class _Ux,
  class _Dx >
  void _Resetp ( _Ux * _Px, _Dx _Dt )
  {
  typedef _Ref_count_d < _Ux, _Dx > _Refd;

  try {
  _Resetp0 ( _Px, new _Refd ( _Px, _Dt ) );
  } catch ( ... ) {
  _Dt ( _Px );
  throw;
  }
  }

 template < class _Ux,
  class _Dx,
  class _Alloc >
  void _Resetp ( _Ux * _Px, _Dx _Dt, _Alloc _Ax )
  {
  typedef _Ref_count_d < _Ux, _Dx, _Alloc > _Refd;
  typename _Alloc :: template rebind < _Refd > :: other _Al = _Ax;

  try {
  _Refd * _Ptr = _Al . allocate ( 1 );
  new ( _Ptr ) _Refd ( _Px, _Dt, _Al );
  _Resetp0 ( _Px, _Ptr );
  } catch ( ... ) {
  _Dt ( _Px );
  throw;
  }
  }

 template < class _Ux >
  void _Resetp0 ( _Ux * _Px, _Ref_count_base * _Rx )
  {
  this -> _Reset ( _Px, _Rx );
  _Enable_shared ( _Px, _Rx );
  }
 };

template < class _Ty1,
 class _Ty2 >
 bool operator == ( const shared_ptr < _Ty1 > & _S1,
  const shared_ptr < _Ty2 > & _S2 )
 {
 return ( _S1 . get ( ) == _S2 . get ( ) );
 }

template < class _Ty1,
 class _Ty2 >
 bool operator != ( const shared_ptr < _Ty1 > & _S1,
  const shared_ptr < _Ty2 > & _S2 )
 {
 return ( ! ( _S1 == _S2 ) );
 }

template < class _Ty1,
 class _Ty2 >
 bool operator < ( const shared_ptr < _Ty1 > & _S1,
  const shared_ptr < _Ty2 > & _S2 )
 {
 return ( _S1 . _Cmp ( _S2 ) );
 }

template < class _Elem,
 class _Traits,
 class _Ty >
 basic_ostream < _Elem, _Traits > &
 operator << ( basic_ostream < _Elem, _Traits > & _Out,
  const shared_ptr < _Ty > & _Px )
 {
 return ( _Out << _Px . get ( ) );
 }

template < class _Ty >
 void swap ( shared_ptr < _Ty > & _S1, shared_ptr < _Ty > & _S2 )
 {
 _S1 . swap ( _S2 );
 }

template < class _Ty1,
 class _Ty2 >
 shared_ptr < _Ty1 > static_pointer_cast ( const shared_ptr < _Ty2 > & _Other )
 {
 return ( shared_ptr < _Ty1 > ( _Other, _Static_tag ( ) ) );
 }

template < class _Ty1,
 class _Ty2 >
 shared_ptr < _Ty1 > const_pointer_cast ( const shared_ptr < _Ty2 > & _Other )
 {
 return ( shared_ptr < _Ty1 > ( _Other, _Const_tag ( ) ) );
 }

template < class _Ty1,
 class _Ty2 >
 shared_ptr < _Ty1 > dynamic_pointer_cast ( const shared_ptr < _Ty2 > & _Other )
 {
 return ( shared_ptr < _Ty1 > ( _Other, _Dynamic_tag ( ) ) );
 }

template < class _Dx,
 class _Ty >
 _Dx * get_deleter ( const shared_ptr < _Ty > & _Sx )
 {
 return ( ( _Dx * ) _Sx . _Get_deleter ( typeid ( _Dx ) ) );
 }


template < class _Ty >
 class weak_ptr
  : public _Ptr_base < _Ty >
 {
 typedef typename _Ptr_base < _Ty > :: _Elem _Elem;

public :
 weak_ptr ( )
  {
  this -> _Resetw ( );
  }

 template < class _Ty2 >
  weak_ptr ( const shared_ptr < _Ty2 > & _Other )
  {
  this -> _Resetw ( _Other );
  }

 weak_ptr ( const weak_ptr & _Other )
  {
  this -> _Resetw ( _Other );
  }

 template < class _Ty2 >
  weak_ptr ( const weak_ptr < _Ty2 > & _Other )
  {
  this -> _Resetw ( _Other );
  }

 ~ weak_ptr ( )
  {
  this -> _Decwref ( );
  }

 weak_ptr & operator = ( const weak_ptr & _Right )
  {
  this -> _Resetw ( _Right );
  return ( * this );
  }

 template < class _Ty2 >
  weak_ptr & operator = ( const weak_ptr < _Ty2 > & _Right )
  {
  this -> _Resetw ( _Right );
  return ( * this );
  }

 template < class _Ty2 >
  weak_ptr & operator = ( shared_ptr < _Ty2 > & _Right )
  {
  this -> _Resetw ( _Right );
  return ( * this );
  }

 void reset ( )
  {
  this -> _Resetw ( );
  }

 void swap ( weak_ptr & _Other )
  {
  this -> _Swap ( _Other );
  }

 bool expired ( ) const
  {
  return ( this -> _Expired ( ) );
  }

 shared_ptr < _Ty > lock ( ) const
  {
  return ( shared_ptr < _Elem > ( * this, false ) );
  }
 };

template < class _Ty1,
 class _Ty2 >
 bool operator < ( const weak_ptr < _Ty1 > & _W1,
  const weak_ptr < _Ty2 > & _W2 )
 {
 return ( _W1 . _Cmp ( _W2 ) );
 }

template < class _Ty >
 void swap ( weak_ptr < _Ty > & _W1, weak_ptr < _Ty > & _W2 )
 {
 _W1 . swap ( _W2 );
 }


template < class _Ty > class enable_shared_from_this
 {
public :
 typedef _Ty _EStype;

 shared_ptr < _Ty > shared_from_this ( )
  {
  return ( shared_ptr < _Ty > ( _Wptr ) );
  }

 shared_ptr < const _Ty > shared_from_this ( ) const
  {
  return ( shared_ptr < const _Ty > ( _Wptr ) );
  }

protected :
 enable_shared_from_this ( )
  {
  }

 enable_shared_from_this ( const enable_shared_from_this & )
  {
  }

 enable_shared_from_this & operator = ( const enable_shared_from_this & )
  {
  return ( * this );
  }

 ~ enable_shared_from_this ( )
  {
  }

private :
 template < class _Ty1,
  class _Ty2 >
  friend void _Do_enable (
   _Ty1 *,
   enable_shared_from_this < _Ty2 > *,
   _Ref_count_base * );

 mutable weak_ptr < _Ty > _Wptr;
 };

template < class _Ty1,
 class _Ty2 >
 inline void _Do_enable (
  _Ty1 * _Ptr,
  enable_shared_from_this < _Ty2 > * _Es,
  _Ref_count_base * _Refptr )
 {
 _Es -> _Wptr . _Resetw ( _Ptr, _Refptr );
 }
}

template<class _Ty> 
#pragma pack(8)
#line 1811 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
class _Move_operation_category< tr1::shared_ptr< _Ty> >  { 


public: typedef _Swap_move_tag _Move_cat; 
}; 
#pragma pack()
template<class _Ty> 
#pragma pack(8)
#line 1818 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
class _Move_operation_category< tr1::weak_ptr< _Ty> >  { 


public: typedef _Swap_move_tag _Move_cat; 
}; 
#pragma pack()
#line 1823 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
}
#line 1827 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
#pragma warning(pop)
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
#pragma warning(push,3)
#pragma warning(disable: 4244)
#line 1828 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\memory"
#pragma pack ( pop )
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
#pragma pack ( push, 8 )
#line 14 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
namespace std { 


static const int _ISORT_MAX = 32; 


template < class _InIt,
 class _Fn1 > inline
 _Fn1 for_each ( _InIt _First, _InIt _Last, _Fn1 _Func )
 {
 ;
 ;
 typename :: std :: _Checked_iterator_base_helper < _InIt > :: _Checked_iterator_base_type _ChkFirst ( :: std :: _Checked_base ( _First ) );
 typename :: std :: _Checked_iterator_base_helper < _InIt > :: _Checked_iterator_base_type _ChkLast ( :: std :: _Checked_base ( _Last ) );
 for (; _ChkFirst != _ChkLast; ++ _ChkFirst )
  _Func ( * _ChkFirst );
 return ( _Func );
 }


template < class _InIt, class _Ty >
inline
 _InIt _Find ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 ;
 for (; _First != _Last; ++ _First )
  if ( * _First == _Val )
   break;
 return ( _First );
 }

inline const char *_Find(const char *_First, const char *_Last, int _Val) 
{ 
; 
_First = (const char *)::memchr(_First, _Val, _Last - _First); 
return (_First == (0)) ? _Last : _First; 
} 

inline const signed char *_Find(const signed char *_First, const signed char *
_Last, int _Val) 
{ 
; 
_First = (const signed char *)::memchr(_First, _Val, _Last - _First); 

return (_First == (0)) ? _Last : _First; 
} 

inline const unsigned char *_Find(const unsigned char *_First, const unsigned char *
_Last, int _Val) 
{ 
; 
_First = (const unsigned char *)::memchr(_First, _Val, _Last - _First); 

return (_First == (0)) ? _Last : _First; 
} 

template < class _InIt, class _Ty >
inline
 _InIt find ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 :: std :: _Checked_assign_from_base ( _First, _Find ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Val ) );

 return ( _First );
 }
#line 80 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt,
 class _Pr > inline
 _InIt _Find_if ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 ;
 ;
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   break;
 return ( _First );
 }

template < class _InIt,
 class _Pr > inline
 _InIt find_if ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 :: std :: _Checked_assign_from_base ( _First, _Find_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred ) );

 return ( _First );
 }
#line 102 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt > inline
 _FwdIt _Adjacent_find ( _FwdIt _First, _FwdIt _Last )
 {
 ;
 for ( _FwdIt _Firstb; ( _Firstb = _First ) != _Last && ++ _First != _Last; )
  if ( * _Firstb == * _First )
   return ( _Firstb );
 return ( _Last );
 }

template < class _FwdIt > inline
 _FwdIt adjacent_find ( _FwdIt _First, _FwdIt _Last )
 {
 :: std :: _Checked_assign_from_base ( _First, _Adjacent_find ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ) ) );

 return ( _First );
 }
#line 121 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Adjacent_find ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 ;
 ;
 for ( _FwdIt _Firstb; ( _Firstb = _First ) != _Last && ++ _First != _Last; )
  if ( _Pred ( * _Firstb, * _First ) )
   return ( _Firstb );
 return ( _Last );
 }

template < class _FwdIt,
 class _Pr > inline
 _FwdIt adjacent_find ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 :: std :: _Checked_assign_from_base ( _First, _Adjacent_find ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred ) );

 return ( _First );
 }
#line 143 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt,
 class _Ty > inline
 typename iterator_traits < _InIt > :: difference_type
  _Count ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 ;
 typename iterator_traits < _InIt > :: difference_type _Cnt = 0;

 for (; _First != _Last; ++ _First )
  if ( * _First == _Val )
   ++ _Cnt;
 return ( _Cnt );
 }

template < class _InIt,
 class _Ty > inline
 typename iterator_traits < _InIt > :: difference_type
  count ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 return _Count ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Val );
 }


template < class _InIt,
 class _Pr > inline
 typename iterator_traits < _InIt > :: difference_type
  _Count_if ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 ;
 ;
 typename iterator_traits < _InIt > :: difference_type _Count = 0;

 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   ++ _Count;
 return ( _Count );
 }

template < class _InIt,
 class _Pr > inline
 typename iterator_traits < _InIt > :: difference_type
  count_if ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 return _Count_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred );
 }


template < class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2 > inline
 _FwdIt1 _Search ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 * )
 {
 ;
 ;
 _Diff1 _Count1 = 0;
 _Distance ( _First1, _Last1, _Count1 );
 _Diff2 _Count2 = 0;
 _Distance ( _First2, _Last2, _Count2 );

 for (; _Count2 <= _Count1; ++ _First1, -- _Count1 )
  {
  _FwdIt1 _Mid1 = _First1;
  for ( _FwdIt2 _Mid2 = _First2;; ++ _Mid1, ++ _Mid2 )
   if ( _Mid2 == _Last2 )
    return ( _First1 );
   else if ( ! ( * _Mid1 == * _Mid2 ) )
    break;
  }
 return ( _Last1 );
 }

template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt1 search ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 :: std :: _Checked_assign_from_base ( _First1, _Search ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dist_type ( _First1 ), _Dist_type ( _First2 ) ) );

 return _First1;
 }
#line 229 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2,
 class _Pr > inline
 _FwdIt1 _Search ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 * )
 {
 ;
 ;
 ;
 _Diff1 _Count1 = 0;
 _Distance ( _First1, _Last1, _Count1 );
 _Diff2 _Count2 = 0;
 _Distance ( _First2, _Last2, _Count2 );

 for (; _Count2 <= _Count1; ++ _First1, -- _Count1 )
  {
  _FwdIt1 _Mid1 = _First1;
  for ( _FwdIt2 _Mid2 = _First2;; ++ _Mid1, ++ _Mid2 )
   if ( _Mid2 == _Last2 )
    return ( _First1 );
   else if ( ! _Pred ( * _Mid1, * _Mid2 ) )
    break;
  }
 return ( _Last1 );
 }

template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 search ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {
 :: std :: _Checked_assign_from_base ( _First1, _Search ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Pred, _Dist_type ( _First1 ), _Dist_type ( _First2 ) ) );

 return _First1;
 }
#line 271 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt1,
 class _Diff2,
 class _Ty > inline
 _FwdIt1 _Search_n ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty & _Val, forward_iterator_tag )
 {
 ;

 if ( _Count <= 0 )
  return ( _First1 );

 for (; _First1 != _Last1; ++ _First1 )
  if ( * _First1 == _Val )
   {
   _FwdIt1 _Mid1 = _First1;

   for ( _Diff2 _Count1 = _Count;; )
    if ( -- _Count1 == 0 )
     return ( _First1 );
    else if ( ++ _Mid1 == _Last1 )
     return ( _Last1 );
    else if ( ! ( * _Mid1 == _Val ) )
     break;

   _First1 = _Mid1;
   }
 return ( _Last1 );
 }

template < class _FwdIt1,
 class _Diff2,
 class _Ty > inline
 _FwdIt1 _Search_n ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty & _Val, random_access_iterator_tag )
 {
 ;

 if ( _Count <= 0 )
  return ( _First1 );

 _FwdIt1 _Oldfirst1 = _First1;
 for ( _Diff2 _Inc = 0; _Count <= _Last1 - _Oldfirst1; )
  {
  _First1 = _Oldfirst1 + _Inc;
  if ( * _First1 == _Val )
   {
   _Diff2 _Count1 = _Count;
   _FwdIt1 _Mid1 = _First1;

   for (; _Oldfirst1 != _First1 && _First1 [ - 1 ] == _Val; -- _First1 )
    -- _Count1;

   if ( _Count1 <= _Last1 - _Mid1 )
    for (;; )
     if ( -- _Count1 == 0 )
      return ( _First1 );
     else if ( ! ( * ++ _Mid1 == _Val ) )
      break;

   _Oldfirst1 = ++ _Mid1;
   _Inc = 0;
   }
  else
   {
   _Oldfirst1 = _First1 + 1;
   _Inc = _Count - 1;
   }
  }
 return ( _Last1 );
 }

template < class _FwdIt1,
 class _Diff2,
 class _Ty > inline
 _FwdIt1 search_n ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty & _Val )
 {
 :: std :: _Checked_assign_from_base ( _First1, _Search_n ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _Count, _Val, _Iter_cat ( _First1 ) ) );

 return _First1;
 }
#line 355 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt1,
 class _Diff2,
 class _Ty,
 class _Pr > inline
 _FwdIt1 _Search_n ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty & _Val, _Pr _Pred, forward_iterator_tag )
 {
 ;
 ;

 if ( _Count <= 0 )
  return ( _First1 );

 for (; _First1 != _Last1; ++ _First1 )
  if ( _Pred ( * _First1, _Val ) )
   {
   _FwdIt1 _Mid1 = _First1;

   for ( _Diff2 _Count1 = _Count;; )
    if ( -- _Count1 == 0 )
     return ( _First1 );
    else if ( ++ _Mid1 == _Last1 )
     return ( _Last1 );
    else if ( ! _Pred ( * _Mid1, _Val ) )
     break;

   _First1 = _Mid1;
   }
 return ( _Last1 );
 }

template < class _FwdIt1,
 class _Diff2,
 class _Ty,
 class _Pr > inline
 _FwdIt1 _Search_n ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty & _Val, _Pr _Pred, random_access_iterator_tag )
 {
 ;
 ;

 if ( _Count <= 0 )
  return ( _First1 );

 _FwdIt1 _Oldfirst1 = _First1;
 for (; _Count <= _Last1 - _Oldfirst1; )
  {
  if ( _Pred ( * _First1, _Val ) )
   {
   _Diff2 _Count1 = _Count;
   _FwdIt1 _Mid1 = _First1;

   for (; _Oldfirst1 != _First1 && _Pred ( _First1 [ - 1 ], _Val );
    -- _First1 )
    -- _Count1;

   if ( _Count1 <= _Last1 - _Mid1 )
    for (;; )
     if ( -- _Count1 == 0 )
      return ( _First1 );
     else if ( ! _Pred ( * ++ _Mid1, _Val ) )
      break;

   _Oldfirst1 = ++ _Mid1;
   _First1 = _Oldfirst1;
   }
  else
   {
   _Oldfirst1 = _First1 + 1;
   _First1 += _Count;
   }
  }
 return ( _Last1 );
 }

template < class _FwdIt1,
 class _Diff2,
 class _Ty,
 class _Pr > inline
 _FwdIt1 search_n ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty & _Val, _Pr _Pred )
 {
 :: std :: _Checked_assign_from_base ( _First1, _Search_n ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _Count, _Val, _Pred, _Iter_cat ( _First1 ) ) );

 return _First1;
 }
#line 444 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2 > inline
 _FwdIt1 _Find_end ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 * )
 {
 ;
 ;
 _Diff1 _Count1 = 0;
 _Distance ( _First1, _Last1, _Count1 );
 _Diff2 _Count2 = 0;
 _Distance ( _First2, _Last2, _Count2 );
 _FwdIt1 _Ans = _Last1;

 if ( 0 < _Count2 )
  for (; _Count2 <= _Count1; ++ _First1, -- _Count1 )
   {
   _FwdIt1 _Mid1 = _First1;
   for ( _FwdIt2 _Mid2 = _First2;; ++ _Mid1 )
    if ( ! ( * _Mid1 == * _Mid2 ) )
     break;
    else if ( ++ _Mid2 == _Last2 )
     {
     _Ans = _First1;
     break;
     }
   }
 return ( _Ans );
 }

template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt1 find_end ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 :: std :: _Checked_assign_from_base ( _First1, _Find_end ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dist_type ( _First1 ), _Dist_type ( _First2 ) ) );

 return _First1;
 }
#line 488 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2,
 class _Pr > inline
 _FwdIt1 _Find_end ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 * )
 {
 ;
 ;
 ;
 _Diff1 _Count1 = 0;
 _Distance ( _First1, _Last1, _Count1 );
 _Diff2 _Count2 = 0;
 _Distance ( _First2, _Last2, _Count2 );
 _FwdIt1 _Ans = _Last1;

 if ( 0 < _Count2 )
  for (; _Count2 <= _Count1; ++ _First1, -- _Count1 )
   {
   _FwdIt1 _Mid1 = _First1;
   for ( _FwdIt2 _Mid2 = _First2;; ++ _Mid1 )
    if ( ! _Pred ( * _Mid1, * _Mid2 ) )
     break;
    else if ( ++ _Mid2 == _Last2 )
     {
     _Ans = _First1;
     break;
     }
   }
 return ( _Ans );
 }

template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 find_end ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {
 :: std :: _Checked_assign_from_base ( _First1, _Find_end ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Pred, _Dist_type ( _First1 ), _Dist_type ( _First2 ) ) );

 return _First1;
 }
#line 535 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt1 _Find_first_of ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 ;
 ;
 for (; _First1 != _Last1; ++ _First1 )
  for ( _FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++ _Mid2 )
   if ( * _First1 == * _Mid2 )
    return ( _First1 );
 return ( _First1 );
 }

template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt1 find_first_of ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 ;
 ;
 :: std :: _Checked_assign_from_base ( _First1, _Find_first_of ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ) ) );

 return _First1;
 }
#line 563 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 _Find_first_of ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {
 ;
 for (; _First1 != _Last1; ++ _First1 )
  for ( _FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++ _Mid2 )
   if ( _Pred ( * _First1, * _Mid2 ) )
    return ( _First1 );
 return ( _First1 );
 }

template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 find_first_of ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {
 :: std :: _Checked_assign_from_base ( _First1, _Find_first_of ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Pred ) );

 return ( _First1 );
 }
#line 590 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt1,
 class _FwdIt2 > inline
 void iter_swap ( _FwdIt1 _Left, _FwdIt2 _Right )
 {
 swap ( * _Left, * _Right );
 }


template < class _FwdIt1, class _FwdIt2, class _FwdItCats >
inline
 _FwdIt2 _Swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
  _FwdItCats, _Range_checked_iterator_tag )
 {
 ;
 for (; _First1 != _Last1; ++ _First1, ++ _First2 )
  std :: iter_swap ( _First1, _First2 );
 return ( _First2 );
 }


template < class _FwdIt1, class _FwdIt2 >
inline
 _FwdIt2 _Swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {

 _FwdIt2 _Result = _First2 + ( _Last1 - _First1 );
 _Swap_ranges ( _First1, _Last1, :: std :: _Checked_base ( _First2 ),
  forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 return ( _Result );
 }
#line 625 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt1, class _FwdIt2 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _FwdIt2 > :: _Result, _FwdIt2 > :: _Result swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2 )
 {
  return _Swap_ranges ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
   _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdIt1, class _FwdElem2, size_t _Size >
inline
_FwdElem2 * swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdElem2 ( & _First2 ) [ _Size ] )
 {
  return ( swap_ranges ( _First1, _Last1, :: stdext :: make_checked_array_iterator ( _First2, _Size ) ) . base ( ) );
 }

template < class _FwdIt1, class _FwdIt2 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _FwdIt2 > :: _Result, _FwdIt2 > :: _Result swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2 )
 {
  return _Swap_ranges ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
   _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 662 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt, class _OutIt, class _Fn1, class _InOutItCat >
inline
 _OutIt _Transform ( _InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func,
  _InOutItCat, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First != _Last; ++ _First, ++ _Dest )
  * _Dest = _Func ( * _First );
 return ( _Dest );
 }


template < class _InIt, class _OutIt, class _Fn1 >
inline
 _OutIt _Transform ( _InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {

 _OutIt _Result = _Dest + ( _Last - _First );
 _Transform ( _First, _Last, :: std :: _Checked_base ( _Dest ), _Func,
  forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 return ( _Result );
 }
#line 691 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt, class _OutIt, class _Fn1 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result transform ( _InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func )
 {
 return _Transform ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Func,
  _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutElem, class _Fn1, size_t _Size >
inline
_OutElem * transform ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ], _Fn1 _Func )
 {
 return ( transform ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Func ) . base ( ) );
 }

template < class _InIt, class _OutIt, class _Fn1 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result transform ( _InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func )
 {
 return _Transform ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Func,
  _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 729 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats, class _InOutItCat >
inline
 _OutIt _Transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutIt _Dest, _Fn2 _Func,
  _InItCats, _InOutItCat,
  _Range_checked_iterator_tag, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First1 != _Last1; ++ _First1, ++ _First2, ++ _Dest )
  * _Dest = _Func ( * _First1, * _First2 );
 return ( _Dest );
 }


template < class _InIt1, class _InIt2, class _OutIt, class _Fn2 >
inline
 _OutIt _Transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutIt _Dest, _Fn2 _Func,
  random_access_iterator_tag, random_access_iterator_tag,
  _Range_checked_iterator_tag, _Range_checked_iterator_tag )
 {

 _InIt2 _Last2 = _First2 + ( _Last1 - _First1 ); ( _Last2 );
 _OutIt _Result = _Dest + ( _Last1 - _First1 );
 _Transform ( _First1, _Last1, :: std :: _Checked_base ( _First2 ),
  :: std :: _Checked_base ( _Dest ), _Func,
  forward_iterator_tag ( ), forward_iterator_tag ( ),
  _Range_checked_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 return _Result;
 }

template < class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InOutItCat >
inline
 _OutIt _Transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutIt _Dest, _Fn2 _Func,
  random_access_iterator_tag, _InOutItCat,
  _Range_checked_iterator_tag, _Range_checked_iterator_tag )
 {

 _InIt2 _Last2 = _First2 + ( _Last1 - _First1 ); ( _Last2 );
 return _Transform ( _First1, _Last1, :: std :: _Checked_base ( _First2 ),
  _Dest, _Func,
  forward_iterator_tag ( ), forward_iterator_tag ( ),
  _Range_checked_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats >
inline
 _OutIt _Transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutIt _Dest, _Fn2 _Func,
  _InItCats, random_access_iterator_tag,
  _Range_checked_iterator_tag, _Range_checked_iterator_tag )
 {

 _OutIt _Result = _Dest + ( _Last1 - _First1 );
 _Transform ( _First1, _Last1, _First2,
  :: std :: _Checked_base ( _Dest ), _Func,
  forward_iterator_tag ( ), forward_iterator_tag ( ),
  _Range_checked_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 return _Result;
 }
#line 796 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt1, class _InIt2, class _OutIt, class _Fn2 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _InIt2 > :: _Result && :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutIt _Dest, _Fn2 _Func )
 {
 return _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Dest, _Func,
  _Iter_random ( _First1, _First2 ), _Iter_random ( _First1, _Dest ),
  :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InElem2, class _OutElem, class _Fn2, size_t _SizeFirst2, size_t _SizeDest >
inline
_OutElem * transform ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _SizeFirst2 ],
  _OutElem ( & _Dest ) [ _SizeDest ], _Fn2 _Func )
 {
 return ( transform ( _First1, _Last1,
  :: stdext :: make_checked_array_iterator ( _First2, _SizeFirst2 ),
  :: stdext :: make_checked_array_iterator ( _Dest, _SizeDest ),
  _Func ) . base ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Fn2, size_t _SizeDest >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _InIt2 > :: _Result, _OutElem * > :: _Result transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutElem ( & _Dest ) [ _SizeDest ], _Fn2 _Func )
 {
 return ( _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
  :: stdext :: make_checked_array_iterator ( _Dest, _SizeDest ), _Func,
  _Iter_random ( _First1, _First2 ), _Iter_cat ( _First1 ),
  :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) ) . base ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Fn2, size_t _SizeDest >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _InIt2 > :: _Result, _OutElem * > :: _Result transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutElem ( & _Dest ) [ _SizeDest ], _Fn2 _Func )
 {
 return ( _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
  :: stdext :: make_checked_array_iterator ( _Dest, _SizeDest ), _Func,
  _Iter_random ( _First1, _First2 ), _Iter_cat ( _First1 ),
  :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) ) . base ( ) );
 }

template < class _InIt1, class _InElem2, class _OutIt, class _Fn2, size_t _SizeFirst2 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result transform ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _SizeFirst2 ],
  _OutIt _Dest, _Fn2 _Func )
 {
 return ( _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: stdext :: make_checked_array_iterator ( _First2, _SizeFirst2 ),
  _Dest, _Func,
  _Iter_cat ( _First1 ), _Iter_random ( _First1, _Dest ),
  :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt1, class _InElem2, class _OutIt, class _Fn2, size_t _SizeFirst2 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result transform ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _SizeFirst2 ],
  _OutIt _Dest, _Fn2 _Func )
 {
 return ( _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: stdext :: make_checked_array_iterator ( _First2, _SizeFirst2 ),
  _Dest, _Func,
  _Iter_cat ( _First1 ), _Iter_random ( _First1, _Dest ),
  :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt1, class _InIt2, class _OutIt, class _Fn2 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _InIt2 > :: _Result || ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutIt _Dest, _Fn2 _Func )
 {
 return _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Dest, _Func,
  _Iter_random ( _First1, _First2 ), _Iter_random ( _First1, _Dest ),
  :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 891 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt,
 class _Ty > inline
 void _Replace ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Oldval, const _Ty & _Newval )
 {
 ;
 for (; _First != _Last; ++ _First )
  if ( * _First == _Oldval )
   * _First = _Newval;
 }

template < class _FwdIt,
 class _Ty > inline
 void replace ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Oldval, const _Ty & _Newval )
 {
 _Replace ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Oldval, _Newval );
 }


template < class _FwdIt,
 class _Pr,
 class _Ty > inline
 void _Replace_if ( _FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty & _Val )
 {
 ;
 ;
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   * _First = _Val;
 }

template < class _FwdIt,
 class _Pr,
 class _Ty > inline
 void replace_if ( _FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty & _Val )
 {
 _Replace_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred, _Val );
 }


template < class _InIt, class _OutIt, class _Ty, class _InOutItCat >
inline
 _OutIt _Replace_copy ( _InIt _First, _InIt _Last, _OutIt _Dest,
  const _Ty & _Oldval, const _Ty & _Newval,
  _InOutItCat, _Range_checked_iterator_tag )
 {
 ;
 ;
 for (; _First != _Last; ++ _First, ++ _Dest )
  * _Dest = * _First == _Oldval ? _Newval : * _First;
 return ( _Dest );
 }


template < class _InIt, class _OutIt, class _Ty >
inline
 _OutIt _Replace_copy ( _InIt _First, _InIt _Last, _OutIt _Dest,
  const _Ty & _Oldval, const _Ty & _Newval,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {

 _OutIt _Result = _Dest + ( _Last - _First );
 _Replace_copy ( _First, _Last, :: std :: _Checked_base ( _Dest ),
  _Oldval, _Newval,
  forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 return ( _Result );
 }
#line 963 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Ty > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result replace_copy ( _InIt _First, _InIt _Last, _OutIt _Dest,
  const _Ty & _Oldval, const _Ty & _Newval )
 {
 return _Replace_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Oldval, _Newval,
  _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutElem, class _Ty, size_t _Size >
inline
_OutElem * replace_copy ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ],
  const _Ty & _Oldval, const _Ty & _Newval )
 {
 return ( replace_copy ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ),
  _Oldval, _Newval ) . base ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Ty > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result replace_copy ( _InIt _First, _InIt _Last, _OutIt _Dest,
  const _Ty & _Oldval, const _Ty & _Newval )
 {
 return _Replace_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Oldval, _Newval,
  _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 1009 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt, class _OutIt, class _Pr, class _Ty, class _InOutItCat >
inline
 _OutIt _Replace_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred, const _Ty & _Val, _InOutItCat, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First != _Last; ++ _First, ++ _Dest )
  * _Dest = _Pred ( * _First ) ? _Val : * _First;
 return ( _Dest );
 }


template < class _InIt, class _OutIt, class _Pr, class _Ty >
inline
 _OutIt _Replace_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred, const _Ty & _Val,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {

 _OutIt _Result = _Dest + ( _Last - _First );
 _Replace_copy_if ( _First, _Last, :: std :: _Checked_base ( _Dest ),
  _Pred, _Val,
  forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 return ( _Result );
 }
#line 1040 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result replace_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred, const _Ty & _Val )
 {
 return _Replace_copy_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, _Val,
  _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutElem, class _Pr, class _Ty, size_t _Size >
inline
_OutElem * replace_copy_if ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ],
  _Pr _Pred, const _Ty & _Val )
 {
 return ( replace_copy_if ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ),
  _Pred, _Val ) . base ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result replace_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred, const _Ty & _Val )
 {
 return _Replace_copy_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, _Val,
  _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 1089 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt,
 class _Fn0 > inline
 void _Generate ( _FwdIt _First, _FwdIt _Last, _Fn0 _Func )
 {
 ;
 ;
 for (; _First != _Last; ++ _First )
  * _First = _Func ( );
 }

template < class _FwdIt,
 class _Fn0 > inline
 void generate ( _FwdIt _First, _FwdIt _Last, _Fn0 _Func )
 {
 _Generate ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Func );
 }


template < class _OutIt, class _Diff, class _Fn0, class _OutItCat >
inline
 void _Generate_n ( _OutIt _Dest, _Diff _Count, _Fn0 _Func,
  _OutItCat, _Range_checked_iterator_tag )
 {
 ;
 ;
 for (; 0 < _Count; -- _Count, ++ _Dest )
  * _Dest = _Func ( );
 }


template < class _OutIt, class _Diff, class _Fn0 >
inline
 void _Generate_n ( _OutIt _Dest, _Diff _Count, _Fn0 _Func,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {

 _OutIt _Result = _Dest + _Count;
 _Generate_n ( :: std :: _Checked_base ( _Dest ), _Count, _Func,
  forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 }
#line 1133 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _OutIt,
 class _Diff,
 class _Fn0 > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result generate_n ( _OutIt _Dest, _Diff _Count, _Fn0 _Func )
 {
 _Generate_n ( _Dest, _Count, _Func,
  _Iter_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _OutElem, class _Diff, class _Fn0, size_t _Size >
inline
void generate_n ( _OutElem ( & _Dest ) [ _Size ], _Diff _Count, _Fn0 _Func )
 {
 generate_n ( :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Count, _Func );
 }

template < class _OutIt,
 class _Diff,
 class _Fn0 > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result generate_n ( _OutIt _Dest, _Diff _Count, _Fn0 _Func )
 {
 _Generate_n ( _Dest, _Count, _Func,
  _Iter_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 1173 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt _Remove_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Val, _Range_checked_iterator_tag )
 {
 ;
 ;
 for (; _First != _Last; ++ _First )
  if ( ! ( * _First == _Val ) )
   * _Dest ++ = * _First;
 return ( _Dest );
 }



template < class _InIt,
 class _OutIt,
 class _Ty > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result remove_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Val )
 {
 return _Remove_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Val, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutElem, class _Ty, size_t _Size >
inline
_OutElem * remove_copy ( _InIt _First, _InIt _Last,
  _OutElem ( & _Dest ) [ _Size ], const _Ty & _Val )
 {
 return ( remove_copy ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ),
  _Val ) . base ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Ty > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result remove_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Val )
 {
 return _Remove_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Val, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 1232 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Remove_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First != _Last; ++ _First )
  if ( ! _Pred ( * _First ) )
   * _Dest ++ = * _First;
 return ( _Dest );
 }



template < class _InIt,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result remove_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred )
 {
 return _Remove_copy_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * remove_copy_if ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( remove_copy_if ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result remove_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred )
 {
 return _Remove_copy_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 1286 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt,
 class _Ty > inline
 _FwdIt remove ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _First = find ( _First, _Last, _Val );
 if ( _First == _Last )
  return ( _First );
 else
  {
  _FwdIt _First1 = _First;
  return ( :: stdext :: unchecked_remove_copy ( ++ _First1, _Last, _First, _Val ) );
  }
 }


template < class _FwdIt,
 class _Pr > inline
 _FwdIt remove_if ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _First = std :: find_if ( _First, _Last, _Pred );
 if ( _First == _Last )
  return ( _First );
 else
  {
  _FwdIt _First1 = _First;
  return ( :: stdext :: unchecked_remove_copy_if ( ++ _First1, _Last, _First, _Pred ) );
  }
 }


template < class _FwdIt > inline
 _FwdIt _Unique ( _FwdIt _First, _FwdIt _Last )
 {
 ;
 for ( _FwdIt _Firstb; ( _Firstb = _First ) != _Last && ++ _First != _Last; )
  if ( * _Firstb == * _First )
   {
   for (; ++ _First != _Last; )
    if ( ! ( * _Firstb == * _First ) )
     * ++ _Firstb = * _First;
   return ( ++ _Firstb );
   }
 return ( _Last );
 }

template < class _FwdIt > inline
 _FwdIt unique ( _FwdIt _First, _FwdIt _Last )
 {
 :: std :: _Checked_assign_from_base ( _Last, _Unique ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ) ) );

 return ( _Last );
 }
#line 1340 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Unique ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 ;
 ;
 for ( _FwdIt _Firstb; ( _Firstb = _First ) != _Last && ++ _First != _Last; )
  if ( _Pred ( * _Firstb, * _First ) )
   {
   for (; ++ _First != _Last; )
    if ( ! _Pred ( * _Firstb, * _First ) )
     * ++ _Firstb = * _First;
   return ( ++ _Firstb );
   }
 return ( _Last );
 }

template < class _FwdIt,
 class _Pr > inline
 _FwdIt unique ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 :: std :: _Checked_assign_from_base ( _Last, _Unique ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred ) );

 return ( _Last );
 }
#line 1367 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt _Unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest, _Ty *, _Range_checked_iterator_tag )
 {
 ;
 _Ty _Val = * _First;

 for ( * _Dest ++ = _Val; ++ _First != _Last; )
  if ( ! ( _Val == * _First ) )
   _Val = * _First, * _Dest ++ = _Val;
 return ( _Dest );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt _Unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest,
  input_iterator_tag, _Range_checked_iterator_tag )
 {
 return ( _Unique_copy ( _First, _Last, _Dest, _Val_type ( _First ), _Range_checked_iterator_tag ( ) ) );
 }

template < class _FwdIt,
 class _OutIt > inline
 _OutIt _Unique_copy ( _FwdIt _First, _FwdIt _Last, _OutIt _Dest,
  forward_iterator_tag, _Range_checked_iterator_tag )
 {
 ;
 ;
 _FwdIt _Firstb = _First;
 for ( * _Dest ++ = * _Firstb; ++ _First != _Last; )
  if ( ! ( * _Firstb == * _First ) )
   _Firstb = _First, * _Dest ++ = * _Firstb;
 return ( _Dest );
 }

template < class _BidIt,
 class _OutIt > inline
 _OutIt _Unique_copy ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  bidirectional_iterator_tag, _Range_checked_iterator_tag )
 {
 return ( _Unique_copy ( _First, _Last, _Dest, forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) ) );
 }

template < class _RanIt,
 class _OutIt > inline
 _OutIt _Unique_copy ( _RanIt _First, _RanIt _Last, _OutIt _Dest,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {
 return ( _Unique_copy ( _First, _Last, _Dest, forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) ) );
 }



template < class _InIt,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return ( _First == _Last ? _Dest :
  _Unique_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _OutElem, size_t _Size >
inline
_OutElem * unique_copy ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( _First == _Last ? _Dest :
  ( unique_copy ( _First, _Last, :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) ) );
 }

template < class _InIt,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return ( _First == _Last ? _Dest :
  _Unique_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }
#line 1459 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Ty,
 class _Pr > inline
 _OutIt _Unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred,
  _Ty *, _Range_checked_iterator_tag )
 {
 ;
 ;
 _Ty _Val = * _First;

 for ( * _Dest ++ = _Val; ++ _First != _Last; )
  if ( ! _Pred ( _Val, * _First ) )
   _Val = * _First, * _Dest ++ = _Val;
 return ( _Dest );
 }

template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred,
  input_iterator_tag, _Range_checked_iterator_tag )
 {
 return ( _Unique_copy ( _First, _Last, _Dest, _Pred, _Val_type ( _First ), _Range_checked_iterator_tag ( ) ) );
 }

template < class _FwdIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Unique_copy ( _FwdIt _First, _FwdIt _Last, _OutIt _Dest, _Pr _Pred,
  forward_iterator_tag, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 _FwdIt _Firstb = _First;

 for ( * _Dest ++ = * _Firstb; ++ _First != _Last; )
  if ( ! _Pred ( * _Firstb, * _First ) )
   _Firstb = _First, * _Dest ++ = * _Firstb;
 return ( _Dest );
 }

template < class _BidIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Unique_copy ( _BidIt _First, _BidIt _Last, _OutIt _Dest, _Pr _Pred,
  bidirectional_iterator_tag, _Range_checked_iterator_tag )
 {
 return ( _Unique_copy ( _First, _Last, _Dest, _Pred,
  forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) ) );
 }

template < class _RanIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Unique_copy ( _RanIt _First, _RanIt _Last, _OutIt _Dest, _Pr _Pred,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {
 return ( _Unique_copy ( _First, _Last, _Dest, _Pred,
  forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) ) );
 }



template < class _InIt,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred )
 {
 return ( _First == _Last ? _Dest
  : _Unique_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * unique_copy ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( _First == _Last ? _Dest
  : ( unique_copy ( _First, _Last, :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) ) );
 }

template < class _InIt,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred )
 {
 return ( _First == _Last ? _Dest
  : _Unique_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }
#line 1565 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _BidIt > inline
 void _Reverse ( _BidIt _First, _BidIt _Last, bidirectional_iterator_tag )
 {
 for (; _First != _Last && _First != -- _Last; ++ _First )
  std :: iter_swap ( _First, _Last );
 }

template < class _RanIt > inline
 void _Reverse ( _RanIt _First, _RanIt _Last, random_access_iterator_tag )
 {
 ;
 for (; _First < _Last; ++ _First )
  std :: iter_swap ( _First, -- _Last );
 }

template < class _BidIt > inline
 void reverse ( _BidIt _First, _BidIt _Last )
 {
 _Reverse ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Iter_cat ( _First ) );
 }


template < class _BidIt, class _OutIt, class _InOutItCat >
inline
 _OutIt _Reverse_copy ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _InOutItCat, _Range_checked_iterator_tag )
 {
 ;
 ;
 for (; _First != _Last; ++ _Dest )
  * _Dest = * -- _Last;
 return ( _Dest );
 }


template < class _BidIt, class _OutIt >
inline
 _OutIt _Reverse_copy ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {

 _OutIt _Result = _Dest + ( _Last - _First );
 _Reverse_copy ( _First, _Last, :: std :: _Checked_base ( _Dest ),
  forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 return ( _Result );
 }
#line 1615 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _BidIt,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result reverse_copy ( _BidIt _First, _BidIt _Last, _OutIt _Dest )
 {
 return _Reverse_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutElem, size_t _Size >
inline
_OutElem * reverse_copy ( _BidIt _First, _BidIt _Last, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( reverse_copy ( _First, _Last, :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _BidIt,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result reverse_copy ( _BidIt _First, _BidIt _Last, _OutIt _Dest )
 {
 return _Reverse_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 1649 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt > inline
 void _Rotate ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  forward_iterator_tag )
 {
 for ( _FwdIt _Next = _Mid;; )
  {
  std :: iter_swap ( _First, _Next );
  if ( ++ _First == _Mid )
   if ( ++ _Next == _Last )
    break;
   else
    _Mid = _Next;
  else if ( ++ _Next == _Last )
   _Next = _Mid;
  }
 }

template < class _BidIt > inline
 void _Rotate ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  bidirectional_iterator_tag )
 {
 std :: reverse ( _First, _Mid );
 std :: reverse ( _Mid, _Last );
 std :: reverse ( _First, _Last );
 }

template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Rotate ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty * )
 {
 ;
 ;
 _Diff _Shift = _Mid - _First;
 _Diff _Count = _Last - _First;

 for ( _Diff _Factor = _Shift; _Factor != 0; )
  {
  _Diff _Tmp = _Count % _Factor;
  _Count = _Factor, _Factor = _Tmp;
  }

 if ( _Count < _Last - _First )
  for (; 0 < _Count; -- _Count )
   {
   _RanIt _Hole = _First + _Count;
   _RanIt _Next = _Hole;
   _Ty _Holeval = * _Hole;
   _RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
   while ( _Next1 != _Hole )
    {
    * _Next = * _Next1;
    _Next = _Next1;
    _Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
     : _First + ( _Shift - ( _Last - _Next1 ) );
    }
   * _Next = _Holeval;
   }
 }

template < class _RanIt > inline
 void _Rotate ( _RanIt _First, _RanIt _Mid, _RanIt _Last,
   random_access_iterator_tag )
 {
 _Rotate ( _First, _Mid, _Last, _Dist_type ( _First ), _Val_type ( _First ) );
 }

template < class _FwdIt > inline
 void rotate ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last )
 {
 if ( _First != _Mid && _Mid != _Last )
  _Rotate ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Mid ), :: std :: _Checked_base ( _Last ), _Iter_cat ( _First ) );
 }


template < class _FwdIt,
 class _OutIt > inline
 _OutIt _Rotate_copy ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest, _Range_checked_iterator_tag )
 {
 _Dest = :: stdext :: unchecked_copy ( _Mid, _Last, _Dest );
 return ( :: stdext :: unchecked_copy ( _First, _Mid, _Dest ) );
 }



template < class _FwdIt, class _OutIt >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result rotate_copy ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest )
 {
  return _Rotate_copy ( _First, _Mid, _Last, _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdIt, class _OutElem, size_t _Size >
inline
_OutElem * rotate_copy ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutElem ( & _Dest ) [ _Size ] )
 {
  return ( rotate_copy ( _First, _Mid, _Last, :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _FwdIt, class _OutIt >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result rotate_copy ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest )
 {
  return _Rotate_copy ( _First, _Mid, _Last, _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 1768 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _RanIt,
 class _Diff > inline
 void _Random_shuffle ( _RanIt _First, _RanIt _Last, _Diff * )
 {
 ;
 const int _RANDOM_BITS = 15;
 const int _RANDOM_MAX = ( 1U << _RANDOM_BITS ) - 1;

 _RanIt _Next = _First;
 for ( unsigned long _Index = 2; ++ _Next != _Last; ++ _Index )
  {
  unsigned long _Rm = _RANDOM_MAX;
  unsigned long _Rn = :: rand ( ) & _RANDOM_MAX;
  for (; _Rm < _Index && _Rm != ~ 0UL;
   _Rm = _Rm << _RANDOM_BITS | _RANDOM_MAX )
   _Rn = _Rn << _RANDOM_BITS
    | ( :: rand ( ) & _RANDOM_MAX );

  std :: iter_swap ( _Next, _First + _Diff ( _Rn % _Index ) );
  }
 }

template < class _RanIt > inline
 void random_shuffle ( _RanIt _First, _RanIt _Last )
 {
 if ( _First != _Last )
  _Random_shuffle ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dist_type ( _First ) );
 }


template < class _RanIt,
 class _Fn1,
 class _Diff > inline
 void _Random_shuffle ( _RanIt _First, _RanIt _Last, _Fn1 & _Func, _Diff * )
 {
 ;
 ;
 _RanIt _Next = _First;

 for ( _Diff _Index = 2; ++ _Next != _Last; ++ _Index )
  std :: iter_swap ( _Next, _First + _Diff ( _Func ( _Index ) % _Index ) );
 }

template < class _RanIt,
 class _Fn1 > inline
 void random_shuffle ( _RanIt _First, _RanIt _Last, _Fn1 & _Func )
 {
 if ( _First != _Last )
  _Random_shuffle ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Func, _Dist_type ( _First ) );
 }


template < class _BidIt,
 class _Pr > inline
 _BidIt _Partition ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 ;
 ;
 for (;; ++ _First )
  {
  for (; _First != _Last && _Pred ( * _First ); ++ _First )
   ;
  if ( _First == _Last )
   break;

  for (; _First != -- _Last && ! _Pred ( * _Last ); )
   ;
  if ( _First == _Last )
   break;

  std :: iter_swap ( _First, _Last );
  }
 return ( _First );
 }

template < class _BidIt,
 class _Pr > inline
 _BidIt partition ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 :: std :: _Checked_assign_from_base ( _First, _Partition ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred ) );

 return ( _First );
 }
#line 1853 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _BidIt,
 class _Pr,
 class _Diff,
 class _Ty > inline
 _BidIt _Stable_partition ( _BidIt _First, _BidIt _Last, _Pr _Pred,
  _Diff _Count, _Temp_iterator < _Ty > & _Tempbuf )
 {
 if ( _Count == 0 )
  return ( _First );
 else if ( _Count == 1 )
  return ( _Pred ( * _First ) ? _Last : _First );
 else if ( _Count <= _Tempbuf . _Maxlen ( ) )
  {
  _BidIt _Next = _First;
  for ( _Tempbuf . _Init ( ); _First != _Last; ++ _First )
   if ( _Pred ( * _First ) )
    * _Next ++ = * _First;
   else
    * _Tempbuf ++ = * _First;

  :: stdext :: unchecked_copy ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _Next );
  return ( _Next );
  }
 else
  {
  _BidIt _Mid = _First;
  std :: advance ( _Mid, _Count / 2 );

  _BidIt _Left = _Stable_partition ( _First, _Mid, _Pred,
   _Count / 2, _Tempbuf );
  _BidIt _Right = _Stable_partition ( _Mid, _Last, _Pred,
   _Count - _Count / 2, _Tempbuf );

  _Diff _Count1 = 0;
  _Distance ( _Left, _Mid, _Count1 );
  _Diff _Count2 = 0;
  _Distance ( _Mid, _Right, _Count2 );

  return ( _Buffered_rotate ( _Left, _Mid, _Right,
   _Count1, _Count2, _Tempbuf ) );
  }
 }

template < class _BidIt,
 class _Pr,
 class _Diff,
 class _Ty > inline
 _BidIt _Stable_partition ( _BidIt _First, _BidIt _Last, _Pr _Pred,
  _Diff *, _Ty * )
 {
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );
 _Temp_iterator < _Ty > _Tempbuf ( _Count );
 return ( _Stable_partition ( _First, _Last, _Pred, _Count, _Tempbuf ) );
 }

template < class _BidIt,
 class _Pr > inline
 _BidIt stable_partition ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 if ( _First != _Last )
  {
  :: std :: _Checked_assign_from_base ( _First, _Stable_partition ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred, _Dist_type ( _First ), _Val_type ( _First ) ) );

  }
 return _First;
 }
#line 1967 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Push_heap ( _RanIt _First, _Diff _Hole,
  _Diff _Top, _Ty _Val )
 {
 for ( _Diff _Idx = ( _Hole - 1 ) / 2;
  _Top < _Hole && ( ( * ( _First + _Idx ) ) < ( _Val ) );
  _Idx = ( _Hole - 1 ) / 2 )
  {
  * ( _First + _Hole ) = * ( _First + _Idx );
  _Hole = _Idx;
  }

 * ( _First + _Hole ) = _Val;
 }

template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Push_heap_0 ( _RanIt _First, _RanIt _Last, _Diff *, _Ty * )
 {
 _Diff _Count = _Last - _First;
 if ( 0 < _Count )
  std :: _Push_heap ( _First, _Count, _Diff ( 0 ), _Ty ( * _Last ) );
 }

template < class _RanIt > inline
 void push_heap ( _RanIt _First, _RanIt _Last )
 {
 ;
 if ( _First != _Last )
  {
  ;
  std :: _Push_heap_0 ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( -- _Last ),
   _Dist_type ( _First ), _Val_type ( _First ) );
  }
 }


template < class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Push_heap ( _RanIt _First, _Diff _Hole,
  _Diff _Top, _Ty _Val, _Pr _Pred )
 {
 for ( _Diff _Idx = ( _Hole - 1 ) / 2;
  _Top < _Hole && _Pred ( * ( _First + _Idx ), _Val );
  _Idx = ( _Hole - 1 ) / 2 )
  {
  * ( _First + _Hole ) = * ( _First + _Idx );
  _Hole = _Idx;
  }

 * ( _First + _Hole ) = _Val;
 }

template < class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Push_heap_0 ( _RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty * )
 {
 _Diff _Count = _Last - _First;
 if ( 0 < _Count )
  std :: _Push_heap ( _First, _Count, _Diff ( 0 ), _Ty ( * _Last ), _Pred );
 }

template < class _RanIt,
 class _Pr > inline
 void push_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 if ( _First != _Last )
  {
  ;
  std :: _Push_heap_0 ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( -- _Last ), _Pred,
   _Dist_type ( _First ), _Val_type ( _First ) );
  }
 }


template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Adjust_heap ( _RanIt _First, _Diff _Hole, _Diff _Bottom, _Ty _Val )
 {
 _Diff _Top = _Hole;
 _Diff _Idx = 2 * _Hole + 2;

 for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2 )
  {
  if ( ( ( * ( _First + _Idx ) ) < ( * ( _First + ( _Idx - 1 ) ) ) ) )
   -- _Idx;
  * ( _First + _Hole ) = * ( _First + _Idx ), _Hole = _Idx;
  }

 if ( _Idx == _Bottom )
  {
  * ( _First + _Hole ) = * ( _First + ( _Bottom - 1 ) );
  _Hole = _Bottom - 1;
  }
 std :: _Push_heap ( _First, _Hole, _Top, _Val );
 }

template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Pop_heap ( _RanIt _First, _RanIt _Last, _RanIt _Dest,
  _Ty _Val, _Diff * )
 {
 * _Dest = * _First;
 std :: _Adjust_heap ( _First, _Diff ( 0 ), _Diff ( _Last - _First ), _Val );
 }

template < class _RanIt,
 class _Ty > inline
 void _Pop_heap_0 ( _RanIt _First, _RanIt _Last, _Ty * )
 {
 _Pop_heap ( _First, _Last - 1, _Last - 1,
  _Ty ( * ( _Last - 1 ) ), _Dist_type ( _First ) );
 }

template < class _RanIt > inline
 void pop_heap ( _RanIt _First, _RanIt _Last )
 {
 ;
 ;
 if ( 1 < _Last - _First )
  _Pop_heap_0 ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Val_type ( _First ) );
 }


template < class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Adjust_heap ( _RanIt _First, _Diff _Hole, _Diff _Bottom,
  _Ty _Val, _Pr _Pred )
 {
 _Diff _Top = _Hole;
 _Diff _Idx = 2 * _Hole + 2;

 for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2 )
  {
  if ( _Pred ( * ( _First + _Idx ), * ( _First + ( _Idx - 1 ) ) ) )
   -- _Idx;
  * ( _First + _Hole ) = * ( _First + _Idx ), _Hole = _Idx;
  }

 if ( _Idx == _Bottom )
  {
  * ( _First + _Hole ) = * ( _First + ( _Bottom - 1 ) );
  _Hole = _Bottom - 1;
  }
 std :: _Push_heap ( _First, _Hole, _Top, _Val, _Pred );
 }

template < class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Pop_heap ( _RanIt _First, _RanIt _Last, _RanIt _Dest,
  _Ty _Val, _Pr _Pred, _Diff * )
 {
 * _Dest = * _First;
 std :: _Adjust_heap ( _First, _Diff ( 0 ), _Diff ( _Last - _First ),
  _Val, _Pred );
 }

template < class _RanIt,
 class _Ty,
 class _Pr > inline
 void _Pop_heap_0 ( _RanIt _First, _RanIt _Last, _Pr _Pred, _Ty * )
 {
 _Pop_heap ( _First, _Last - 1, _Last - 1,
  _Ty ( * ( _Last - 1 ) ), _Pred, _Dist_type ( _First ) );
 }

template < class _RanIt,
 class _Pr > inline
 void pop_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 ;
 if ( 1 < _Last - _First )
  _Pop_heap_0 ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred, _Val_type ( _First ) );
 }


template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Make_heap ( _RanIt _First, _RanIt _Last, _Diff *, _Ty * )
 {
 _Diff _Bottom = _Last - _First;

 for ( _Diff _Hole = _Bottom / 2; 0 < _Hole; )
  {
  -- _Hole;
  std :: _Adjust_heap ( _First, _Hole, _Bottom,
   _Ty ( * ( _First + _Hole ) ) );
  }
 }

template < class _RanIt > inline
 void make_heap ( _RanIt _First, _RanIt _Last )
 {
 ;
 if ( 1 < _Last - _First )
  _Make_heap ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ),
   _Dist_type ( _First ), _Val_type ( _First ) );
 }


template < class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Make_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty * )
 {
 _Diff _Bottom = _Last - _First;
 for ( _Diff _Hole = _Bottom / 2; 0 < _Hole; )
  {
  -- _Hole;
  std :: _Adjust_heap ( _First, _Hole, _Bottom,
   _Ty ( * ( _First + _Hole ) ), _Pred );
  }
 }

template < class _RanIt,
 class _Pr > inline
 void make_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 if ( 1 < _Last - _First )
  _Make_heap ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred,
   _Dist_type ( _First ), _Val_type ( _First ) );
 }


template < class _RanIt > inline
 void _Sort_heap ( _RanIt _First, _RanIt _Last )
 {
 ;
 ;
 for (; 1 < _Last - _First; -- _Last )
  std :: pop_heap ( _First, _Last );
 }

template < class _RanIt > inline
 void sort_heap ( _RanIt _First, _RanIt _Last )
 {
 ;
 _Sort_heap ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ) );
 }


template < class _RanIt,
 class _Pr > inline
 void _Sort_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 for (; 1 < _Last - _First; -- _Last )
  std :: pop_heap ( _First, _Last, _Pred );
 }

template < class _RanIt,
 class _Pr > inline
 void sort_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 ;
 _Sort_heap ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred );
 }


template < class _FwdIt,
 class _Ty,
 class _Diff > inline
 _FwdIt _Lower_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val, _Diff * )
 {
 ;
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );

 for (; 0 < _Count; )
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  std :: advance ( _Mid, _Count2 );
  ;

  if ( ( ( * _Mid ) < ( _Val ) ) )
   _First = ++ _Mid, _Count -= _Count2 + 1;
  else
   _Count = _Count2;
  }
 return ( _First );
 }

template < class _FwdIt,
 class _Ty > inline
 _FwdIt lower_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 :: std :: _Checked_assign_from_base ( _First, _Lower_bound ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Val, _Dist_type ( _First ) ) );

 return _First;
 }
#line 2282 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr > inline
 _FwdIt _Lower_bound ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred, _Diff * )
 {
 ;
 ;
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );
 for (; 0 < _Count; )
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  std :: advance ( _Mid, _Count2 );
  ;

  if ( _Pred ( * _Mid, _Val ) )
   _First = ++ _Mid, _Count -= _Count2 + 1;
  else
   _Count = _Count2;
  }
 return ( _First );
 }

template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 _FwdIt lower_bound ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred )
 {
 :: std :: _Checked_assign_from_base ( _First, _Lower_bound ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Val, _Pred, _Dist_type ( _First ) ) );

 return _First;
 }
#line 2320 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt,
 class _Ty,
 class _Diff > inline
 _FwdIt _Upper_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val, _Diff * )
 {
 ;
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );
 for (; 0 < _Count; )
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  std :: advance ( _Mid, _Count2 );
  ;

  if ( ! ( ( _Val ) < ( * _Mid ) ) )
   _First = ++ _Mid, _Count -= _Count2 + 1;
  else
   _Count = _Count2;
  }
 return ( _First );
 }

template < class _FwdIt,
 class _Ty > inline
 _FwdIt upper_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 :: std :: _Checked_assign_from_base ( _First, _Upper_bound ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Val, _Dist_type ( _First ) ) );

 return _First;
 }
#line 2353 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr > inline
 _FwdIt _Upper_bound ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred, _Diff * )
 {
 ;
 ;
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );
 for (; 0 < _Count; )
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  std :: advance ( _Mid, _Count2 );
  ;

  if ( ! _Pred ( _Val, * _Mid ) )
   _First = ++ _Mid, _Count -= _Count2 + 1;
  else
   _Count = _Count2;
  }
 return ( _First );
 }

template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 _FwdIt upper_bound ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred )
 {
 :: std :: _Checked_assign_from_base ( _First, _Upper_bound ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Val, _Pred, _Dist_type ( _First ) ) );

 return _First;
 }
#line 2391 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt,
 class _Ty,
 class _Diff > inline
 pair < _FwdIt, _FwdIt > _Equal_range ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Diff * )
 {
 ;
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );

 for (; 0 < _Count; )
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  std :: advance ( _Mid, _Count2 );
  ;

  if ( ( ( * _Mid ) < ( _Val ) ) )
   {
   _First = ++ _Mid;
   _Count -= _Count2 + 1;
   }
  else if ( _Val < * _Mid )
   _Count = _Count2;
  else
   {
   _FwdIt _First2 = lower_bound ( _First, _Mid, _Val );
   std :: advance ( _First, _Count );
   _FwdIt _Last2 = upper_bound ( ++ _Mid, _First, _Val );
   return ( pair < _FwdIt, _FwdIt > ( _First2, _Last2 ) );
   }
  }

 return ( pair < _FwdIt, _FwdIt > ( _First, _First ) );
 }

template < class _FwdIt,
 class _Ty > inline
 pair < _FwdIt, _FwdIt > equal_range ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val )
 {
 return ( _Equal_range ( _First, _Last, _Val, _Dist_type ( _First ) ) );
 }


template < class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr > inline
 pair < _FwdIt, _FwdIt > _Equal_range ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred, _Diff * )
 {
 ;
 ;
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );

 for (; 0 < _Count; )
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  std :: advance ( _Mid, _Count2 );
  ;

  if ( _Pred ( * _Mid, _Val ) )
   {
   _First = ++ _Mid;
   _Count -= _Count2 + 1;
   }
  else if ( _Pred ( _Val, * _Mid ) )
   _Count = _Count2;
  else
   {
   _FwdIt _First2 = lower_bound ( _First, _Mid, _Val, _Pred );
   std :: advance ( _First, _Count );
   _FwdIt _Last2 = upper_bound ( ++ _Mid, _First, _Val, _Pred );
   return ( pair < _FwdIt, _FwdIt > ( _First2, _Last2 ) );
   }
  }

 return ( pair < _FwdIt, _FwdIt > ( _First, _First ) );
 }

template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 pair < _FwdIt, _FwdIt > equal_range ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred )
 {
 return ( _Equal_range ( _First, _Last, _Val, _Pred, _Dist_type ( _First ) ) );
 }


template < class _FwdIt,
 class _Ty > inline
 bool binary_search ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _First = std :: lower_bound ( _First, _Last, _Val );
 return ( _First != _Last && ! ( _Val < * _First ) );
 }


template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 bool binary_search ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred )
 {
 _First = std :: lower_bound ( _First, _Last, _Val, _Pred );
 return ( _First != _Last && ! _Pred ( _Val, * _First ) );
 }


template < class _InIt1, class _InIt2, class _OutIt, class _InOutItCat >
inline
 _OutIt _Merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest,
  _InOutItCat, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _Dest )
  if ( ( ( * _First2 ) < ( * _First1 ) ) )
   * _Dest = * _First2, ++ _First2;
  else
   * _Dest = * _First1, ++ _First1;

 _Dest = :: stdext :: unchecked_copy ( _First1, _Last1, _Dest );
 return ( :: stdext :: unchecked_copy ( _First2, _Last2, _Dest ) );
 }


template < class _InIt1, class _InIt2, class _OutIt >
inline
 _OutIt _Merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {

 _OutIt _Result = _Dest + ( _Last1 - _First1 ) + ( _Last2 - _First2 );
 _Merge ( _First1, _Last1, _First2, _Last2, :: std :: _Checked_base ( _Dest ),
  forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 return _Result;
 }
#line 2540 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return _Merge ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest,
  _Iter_random ( _First1, _First2, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, size_t _Size >
inline
_OutElem * merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( merge ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return _Merge ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest,
  _Iter_random ( _First1, _First2, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 2588 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt1, class _InIt2, class _OutIt, class _Pr, class _InOutItCat >
inline
 _OutIt _Merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred,
  _InOutItCat, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _Dest )
  if ( _Pred ( * _First2, * _First1 ) )
   * _Dest = * _First2, ++ _First2;
  else
   * _Dest = * _First1, ++ _First1;

 _Dest = :: stdext :: unchecked_copy ( _First1, _Last1, _Dest );
 return ( :: stdext :: unchecked_copy ( _First2, _Last2, _Dest ) );
 }


template < class _InIt1, class _InIt2, class _OutIt, class _Pr >
inline
 _OutIt _Merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred,
  random_access_iterator_tag, _Range_checked_iterator_tag )
 {

 _OutIt _Result = _Dest + ( _Last1 - _First1 ) + ( _Last2 - _First2 );
 _Merge ( _First1, _Last1, _First2, _Last2, :: std :: _Checked_base ( _Dest ), _Pred,
  forward_iterator_tag ( ), _Range_checked_iterator_tag ( ) );
 return _Result;
 }
#line 2624 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return _Merge ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred,
  _Iter_random ( _First1, _First2, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( merge ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return _Merge ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred,
  _Iter_random ( _First1, _First2, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 2678 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _BidIt,
 class _Diff,
 class _Ty > inline
 _BidIt _Buffered_rotate ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff _Count1, _Diff _Count2, _Temp_iterator < _Ty > & _Tempbuf )
 {
 if ( _Count1 <= _Count2 && _Count1 <= _Tempbuf . _Maxlen ( ) )
  {
  :: stdext :: unchecked_copy ( _First, _Mid, _Tempbuf . _Init ( ) );
  :: stdext :: unchecked_copy ( _Mid, _Last, _First );
  return ( :: stdext :: unchecked_copy_backward ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ),
   _Last ) );
  }
 else if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
  {
  :: stdext :: unchecked_copy ( _Mid, _Last, _Tempbuf . _Init ( ) );
  :: stdext :: unchecked_copy_backward ( _First, _Mid, _Last );
  return ( :: stdext :: unchecked_copy ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _First ) );
  }
 else
  {
  std :: rotate ( _First, _Mid, _Last );
  std :: advance ( _First, _Count2 );
  return ( _First );
  }
 }

template < class _BidIt1,
 class _BidIt2,
 class _BidIt3 > inline
 _BidIt3 _Merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Range_checked_iterator_tag )
 {
 for (;; )
  if ( _First1 == _Last1 )
   return ( :: stdext :: unchecked_copy_backward ( _First2, _Last2, _Dest ) );
  else if ( _First2 == _Last2 )
   return ( :: stdext :: unchecked_copy_backward ( _First1, _Last1, _Dest ) );
  else if ( ( ( * -- _Last2 ) < ( * -- _Last1 ) ) )
   * -- _Dest = * _Last1, ++ _Last2;
  else
   * -- _Dest = * _Last2, ++ _Last1;
 }



template < class _BidIt1, class _BidIt2, class _BidIt3 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _BidIt3 > :: _Result, _BidIt3 > :: _Result _Merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest )
 {
  return _Merge_backward ( _First1, _Last1, _First2, _Last2, _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1, class _BidIt2, class _BidIt3 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _BidIt3 > :: _Result, _BidIt3 > :: _Result _Merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest )
 {
  return _Merge_backward ( _First1, _Last1, _First2, _Last2, _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 2753 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _BidIt,
 class _Diff,
 class _Ty > inline
 void _Buffered_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff _Count1, _Diff _Count2,
   _Temp_iterator < _Ty > & _Tempbuf )
 {
 if ( _Count1 + _Count2 == 2 )
  {
  if ( ( ( * _Mid ) < ( * _First ) ) )
   std :: iter_swap ( _First, _Mid );
  }
 else if ( _Count1 <= _Count2 && _Count1 <= _Tempbuf . _Maxlen ( ) )
  {
  :: stdext :: unchecked_copy ( _First, _Mid, _Tempbuf . _Init ( ) );
  :: stdext :: unchecked_merge ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _Mid, _Last, _First );
  }
 else if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
  {
  :: stdext :: unchecked_copy ( _Mid, _Last, _Tempbuf . _Init ( ) );
  :: stdext :: _Unchecked_merge_backward ( _First, _Mid,
   _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _Last );
  }
 else
  {
  _BidIt _Firstn, _Lastn;
  _Diff _Count1n, _Count2n;

  if ( _Count2 < _Count1 )
   {
   _Count1n = _Count1 / 2, _Count2n = 0;
   _Firstn = _First;
   std :: advance ( _Firstn, _Count1n );
   _Lastn = std :: lower_bound ( _Mid, _Last, * _Firstn );
   _Distance ( _Mid, _Lastn, _Count2n );
   }
  else
   {
   _Count1n = 0, _Count2n = _Count2 / 2;
   _Lastn = _Mid;
   std :: advance ( _Lastn, _Count2n );
   _Firstn = std :: upper_bound ( _First, _Mid, * _Lastn );
   _Distance ( _First, _Firstn, _Count1n );
   }

  _BidIt _Midn = _Buffered_rotate ( _Firstn, _Mid, _Lastn,
   _Count1 - _Count1n, _Count2n, _Tempbuf );
  _Buffered_merge ( _First, _Firstn, _Midn,
   _Count1n, _Count2n, _Tempbuf );
  _Buffered_merge ( _Midn, _Lastn, _Last,
   _Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf );
  }
 }

template < class _BidIt,
 class _Diff,
 class _Ty > inline
 void _Inplace_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff *, _Ty * )
 {
 ;
 ;
 _Diff _Count1 = 0;
 _Distance ( _First, _Mid, _Count1 );
 _Diff _Count2 = 0;
 _Distance ( _Mid, _Last, _Count2 );
 _Temp_iterator < _Ty > _Tempbuf ( _Count1 < _Count2 ? _Count1 : _Count2 );
 _Buffered_merge ( _First, _Mid, _Last,
  _Count1, _Count2, _Tempbuf );
 }

template < class _BidIt > inline
 void inplace_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last )
 {
 if ( _First != _Mid && _Mid != _Last )
  _Inplace_merge ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Mid ), :: std :: _Checked_base ( _Last ),
   _Dist_type ( _First ), _Val_type ( _First ) );
 }


template < class _BidIt1,
 class _BidIt2,
 class _BidIt3,
 class _Pr > inline
 _BidIt3 _Merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred, _Range_checked_iterator_tag )
 {
 for (;; )
  if ( _First1 == _Last1 )
   return ( :: stdext :: unchecked_copy_backward ( _First2, _Last2, _Dest ) );
  else if ( _First2 == _Last2 )
   return ( :: stdext :: unchecked_copy_backward ( _First1, _Last1, _Dest ) );
  else if ( _Pred ( * -- _Last2, * -- _Last1 ) )
   * -- _Dest = * _Last1, ++ _Last2;
  else
   * -- _Dest = * _Last2, ++ _Last1;
 }



template < class _BidIt1, class _BidIt2, class _BidIt3, class _Pr >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _BidIt3 > :: _Result, _BidIt3 > :: _Result _Merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred )
 {
  return _Merge_backward ( _First1, _Last1, _First2, _Last2, _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1, class _BidIt2, class _BidIt3, class _Pr >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _BidIt3 > :: _Result, _BidIt3 > :: _Result _Merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred )
 {
  return _Merge_backward ( _First1, _Last1, _First2, _Last2, _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 2882 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Buffered_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff _Count1, _Diff _Count2,
   _Temp_iterator < _Ty > & _Tempbuf, _Pr _Pred )
 {
 if ( _Count1 + _Count2 == 2 )
  {
  if ( _Pred ( * _Mid, * _First ) )
   std :: iter_swap ( _First, _Mid );
  }
 else if ( _Count1 <= _Count2 && _Count1 <= _Tempbuf . _Maxlen ( ) )
  {
  :: stdext :: unchecked_copy ( _First, _Mid, _Tempbuf . _Init ( ) );
  :: stdext :: unchecked_merge ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ),
   _Mid, _Last, _First, _Pred );
  }
 else if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
  {
  :: stdext :: unchecked_copy ( _Mid, _Last, _Tempbuf . _Init ( ) );
  :: stdext :: _Unchecked_merge_backward ( _First, _Mid, _Tempbuf . _First ( ), _Tempbuf . _Last ( ),
   _Last, _Pred );
  }
 else
  {
  _BidIt _Firstn, _Lastn;
  _Diff _Count1n, _Count2n;
  if ( _Count2 < _Count1 )
   {
   _Count1n = _Count1 / 2, _Count2n = 0;
   _Firstn = _First;
   std :: advance ( _Firstn, _Count1n );
   _Lastn = lower_bound ( _Mid, _Last, * _Firstn, _Pred );
   _Distance ( _Mid, _Lastn, _Count2n );
   }
  else
   {
   _Count1n = 0, _Count2n = _Count2 / 2;
   _Lastn = _Mid;
   std :: advance ( _Lastn, _Count2n );
   _Firstn = upper_bound ( _First, _Mid, * _Lastn, _Pred );
   _Distance ( _First, _Firstn, _Count1n );
   }
  _BidIt _Midn = _Buffered_rotate ( _Firstn, _Mid, _Lastn,
   _Count1 - _Count1n, _Count2n, _Tempbuf );
  _Buffered_merge ( _First, _Firstn, _Midn,
   _Count1n, _Count2n, _Tempbuf, _Pred );
  _Buffered_merge ( _Midn, _Lastn, _Last,
   _Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred );
  }
 }

template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Inplace_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
  _Diff *, _Ty * )
 {
 ;
 ;
 _Diff _Count1 = 0;
 _Distance ( _First, _Mid, _Count1 );
 _Diff _Count2 = 0;
 _Distance ( _Mid, _Last, _Count2 );
 _Temp_iterator < _Ty > _Tempbuf ( _Count1 < _Count2 ? _Count1 : _Count2 );
 _Buffered_merge ( _First, _Mid, _Last,
  _Count1, _Count2, _Tempbuf, _Pred );
 }

template < class _BidIt,
 class _Pr > inline
 void inplace_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred )
 {
 if ( _First != _Mid && _Mid != _Last )
  _Inplace_merge ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Mid ), :: std :: _Checked_base ( _Last ), _Pred,
   _Dist_type ( _First ), _Val_type ( _First ) );
 }


template < class _BidIt,
 class _Ty > inline
 void _Insertion_sort1 ( _BidIt _First, _BidIt _Last, _Ty * )
 {
 if ( _First != _Last )
  for ( _BidIt _Next = _First; ++ _Next != _Last; )
   {
   _BidIt _Next1 = _Next;
   _Ty _Val = * _Next;

   if ( ( ( _Val ) < ( * _First ) ) )
    {
    :: stdext :: unchecked_copy_backward ( _First, _Next, ++ _Next1 );
    * _First = _Val;
    }
   else
    {
    for ( _BidIt _First1 = _Next1;
     ( ( _Val ) < ( * -- _First1 ) );
     _Next1 = _First1 )
     * _Next1 = * _First1;
    * _Next1 = _Val;
    }
   }
 }

template < class _BidIt > inline
 void _Insertion_sort ( _BidIt _First, _BidIt _Last )
 {
 std :: _Insertion_sort1 ( _First, _Last, _Val_type ( _First ) );
 }

template < class _RanIt > inline
 void _Med3 ( _RanIt _First, _RanIt _Mid, _RanIt _Last )
 {
 if ( ( ( * _Mid ) < ( * _First ) ) )
  std :: iter_swap ( _Mid, _First );
 if ( ( ( * _Last ) < ( * _Mid ) ) )
  std :: iter_swap ( _Last, _Mid );
 if ( ( ( * _Mid ) < ( * _First ) ) )
  std :: iter_swap ( _Mid, _First );
 }

template < class _RanIt > inline
 void _Median ( _RanIt _First, _RanIt _Mid, _RanIt _Last )
 {
 if ( 40 < _Last - _First )
  {
  size_t _Step = ( _Last - _First + 1 ) / 8;
  std :: _Med3 ( _First, _First + _Step, _First + 2 * _Step );
  std :: _Med3 ( _Mid - _Step, _Mid, _Mid + _Step );
  std :: _Med3 ( _Last - 2 * _Step, _Last - _Step, _Last );
  std :: _Med3 ( _First + _Step, _Mid, _Last - _Step );
  }
 else
  std :: _Med3 ( _First, _Mid, _Last );
 }

template < class _RanIt > inline
 pair < _RanIt, _RanIt > _Unguarded_partition ( _RanIt _First, _RanIt _Last )
 {
 _RanIt _Mid = _First + ( _Last - _First ) / 2;
 std :: _Median ( _First, _Mid, _Last - 1 );
 _RanIt _Pfirst = _Mid;
 _RanIt _Plast = _Pfirst + 1;

 while ( _First < _Pfirst
  && ! ( ( * ( _Pfirst - 1 ) ) < ( * _Pfirst ) )
  && ! ( * _Pfirst < * ( _Pfirst - 1 ) ) )
  -- _Pfirst;
 while ( _Plast < _Last
  && ! ( ( * _Plast ) < ( * _Pfirst ) )
  && ! ( * _Pfirst < * _Plast ) )
  ++ _Plast;

 _RanIt _Gfirst = _Plast;
 _RanIt _Glast = _Pfirst;

 for (;; )
  {
  for (; _Gfirst < _Last; ++ _Gfirst )
   if ( ( ( * _Pfirst ) < ( * _Gfirst ) ) )
    ;
   else if ( * _Gfirst < * _Pfirst )
    break;
   else
    std :: iter_swap ( _Plast ++, _Gfirst );
  for (; _First < _Glast; -- _Glast )
   if ( ( ( * ( _Glast - 1 ) ) < ( * _Pfirst ) ) )
    ;
   else if ( * _Pfirst < * ( _Glast - 1 ) )
    break;
   else
    std :: iter_swap ( -- _Pfirst, _Glast - 1 );
  if ( _Glast == _First && _Gfirst == _Last )
   return ( pair < _RanIt, _RanIt > ( _Pfirst, _Plast ) );

  if ( _Glast == _First )
   {
   if ( _Plast != _Gfirst )
    std :: iter_swap ( _Pfirst, _Plast );
   ++ _Plast;
   std :: iter_swap ( _Pfirst ++, _Gfirst ++ );
   }
  else if ( _Gfirst == _Last )
   {
   if ( -- _Glast != -- _Pfirst )
    std :: iter_swap ( _Glast, _Pfirst );
   std :: iter_swap ( _Pfirst, -- _Plast );
   }
  else
   std :: iter_swap ( _Gfirst ++, -- _Glast );
  }
 }

template < class _RanIt,
 class _Diff > inline
 void _Sort ( _RanIt _First, _RanIt _Last, _Diff _Ideal )
 {
 _Diff _Count;
 for (; _ISORT_MAX < ( _Count = _Last - _First ) && 0 < _Ideal; )
  {
  pair < _RanIt, _RanIt > _Mid =
   std :: _Unguarded_partition ( _First, _Last );
  _Ideal /= 2, _Ideal += _Ideal / 2;

  if ( _Mid . first - _First < _Last - _Mid . second )
   {
   std :: _Sort ( _First, _Mid . first, _Ideal );
   _First = _Mid . second;
   }
  else
   {
   std :: _Sort ( _Mid . second, _Last, _Ideal );
   _Last = _Mid . first;
   }
  }

 if ( _ISORT_MAX < _Count )
  {
  std :: make_heap ( _First, _Last );
  std :: sort_heap ( _First, _Last );
  }
 else if ( 1 < _Count )
  std :: _Insertion_sort ( _First, _Last );
 }

template < class _RanIt > inline
 void sort ( _RanIt _First, _RanIt _Last )
 {
 ;
 std :: _Sort ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Last - _First );
 }


template < class _BidIt,
 class _Pr,
 class _Ty > inline
 void _Insertion_sort1 ( _BidIt _First, _BidIt _Last, _Pr _Pred, _Ty * )
 {
 if ( _First != _Last )
  for ( _BidIt _Next = _First; ++ _Next != _Last; )
   {
   _BidIt _Next1 = _Next;
   _Ty _Val = * _Next;

   if ( _Pred ( _Val, * _First ) )
    {
    :: stdext :: unchecked_copy_backward ( _First, _Next, ++ _Next1 );
    * _First = _Val;
    }
   else
    {
    for ( _BidIt _First1 = _Next1;
     _Pred ( _Val, * -- _First1 );
     _Next1 = _First1 )
     * _Next1 = * _First1;
    * _Next1 = _Val;
    }
   }
 }

template < class _BidIt,
 class _Pr > inline
 void _Insertion_sort ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 std :: _Insertion_sort1 ( _First, _Last, _Pred, _Val_type ( _First ) );
 }

template < class _RanIt,
 class _Pr > inline
 void _Med3 ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred )
 {
 if ( _Pred ( * _Mid, * _First ) )
  std :: iter_swap ( _Mid, _First );
 if ( _Pred ( * _Last, * _Mid ) )
  std :: iter_swap ( _Last, _Mid );
 if ( _Pred ( * _Mid, * _First ) )
  std :: iter_swap ( _Mid, _First );
 }

template < class _RanIt,
 class _Pr > inline
 void _Median ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred )
 {
 if ( 40 < _Last - _First )
  {
  size_t _Step = ( _Last - _First + 1 ) / 8;
  std :: _Med3 ( _First, _First + _Step, _First + 2 * _Step, _Pred );
  std :: _Med3 ( _Mid - _Step, _Mid, _Mid + _Step, _Pred );
  std :: _Med3 ( _Last - 2 * _Step, _Last - _Step, _Last, _Pred );
  std :: _Med3 ( _First + _Step, _Mid, _Last - _Step, _Pred );
  }
 else
  std :: _Med3 ( _First, _Mid, _Last, _Pred );
 }

template < class _RanIt,
 class _Pr > inline
 pair < _RanIt, _RanIt > _Unguarded_partition ( _RanIt _First, _RanIt _Last,
  _Pr _Pred )
 {
 _RanIt _Mid = _First + ( _Last - _First ) / 2;
 std :: _Median ( _First, _Mid, _Last - 1, _Pred );
 _RanIt _Pfirst = _Mid;
 _RanIt _Plast = _Pfirst + 1;

 while ( _First < _Pfirst
  && ! _Pred ( * ( _Pfirst - 1 ), * _Pfirst )
  && ! _Pred ( * _Pfirst, * ( _Pfirst - 1 ) ) )
  -- _Pfirst;
 while ( _Plast < _Last
  && ! _Pred ( * _Plast, * _Pfirst )
  && ! _Pred ( * _Pfirst, * _Plast ) )
  ++ _Plast;

 _RanIt _Gfirst = _Plast;
 _RanIt _Glast = _Pfirst;

 for (;; )
  {
  for (; _Gfirst < _Last; ++ _Gfirst )
   if ( _Pred ( * _Pfirst, * _Gfirst ) )
    ;
   else if ( _Pred ( * _Gfirst, * _Pfirst ) )
    break;
   else
    std :: iter_swap ( _Plast ++, _Gfirst );
  for (; _First < _Glast; -- _Glast )
   if ( _Pred ( * ( _Glast - 1 ), * _Pfirst ) )
    ;
   else if ( _Pred ( * _Pfirst, * ( _Glast - 1 ) ) )
    break;
   else
    std :: iter_swap ( -- _Pfirst, _Glast - 1 );
  if ( _Glast == _First && _Gfirst == _Last )
   return ( pair < _RanIt, _RanIt > ( _Pfirst, _Plast ) );

  if ( _Glast == _First )
   {
   if ( _Plast != _Gfirst )
    std :: iter_swap ( _Pfirst, _Plast );
   ++ _Plast;
   std :: iter_swap ( _Pfirst ++, _Gfirst ++ );
   }
  else if ( _Gfirst == _Last )
   {
   if ( -- _Glast != -- _Pfirst )
    std :: iter_swap ( _Glast, _Pfirst );
   std :: iter_swap ( _Pfirst, -- _Plast );
   }
  else
   std :: iter_swap ( _Gfirst ++, -- _Glast );
  }
 }

template < class _RanIt,
 class _Diff,
 class _Pr > inline
 void _Sort ( _RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr _Pred )
 {
 _Diff _Count;
 for (; _ISORT_MAX < ( _Count = _Last - _First ) && 0 < _Ideal; )
  {
  pair < _RanIt, _RanIt > _Mid =
   std :: _Unguarded_partition ( _First, _Last, _Pred );
  _Ideal /= 2, _Ideal += _Ideal / 2;

  if ( _Mid . first - _First < _Last - _Mid . second )
   {
   std :: _Sort ( _First, _Mid . first, _Ideal, _Pred );
   _First = _Mid . second;
   }
  else
   {
   std :: _Sort ( _Mid . second, _Last, _Ideal, _Pred );
   _Last = _Mid . first;
   }
  }

 if ( _ISORT_MAX < _Count )
  {
  std :: make_heap ( _First, _Last, _Pred );
  std :: sort_heap ( _First, _Last, _Pred );
  }
 else if ( 1 < _Count )
  std :: _Insertion_sort ( _First, _Last, _Pred );
 }

template < class _RanIt,
 class _Pr > inline
 void sort ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 std :: _Sort ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Last - _First, _Pred );
 }


template < class _BidIt,
 class _OutIt,
 class _Diff > inline
 void _Chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count, _Range_checked_iterator_tag )
 {
 for ( _Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2 )
  {
  _BidIt _Mid1 = _First;
  std :: advance ( _Mid1, _Chunk );
  _BidIt _Mid2 = _Mid1;
  std :: advance ( _Mid2, _Chunk );

  _Dest = :: stdext :: unchecked_merge ( _First, _Mid1, _Mid1, _Mid2, _Dest );
  _First = _Mid2;
  }

 if ( _Count <= _Chunk )
  :: stdext :: unchecked_copy ( _First, _Last, _Dest );
 else
  {
  _BidIt _Mid = _First;
  std :: advance ( _Mid, _Chunk );

  :: stdext :: unchecked_merge ( _First, _Mid, _Mid, _Last, _Dest );
  }
 }



template < class _BidIt, class _OutIt, class _Diff >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result _Chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count )
 {
  _Chunked_merge ( _First, _Last, _Dest, _Chunk, _Count, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutElem, class _Diff, size_t _Size >
inline
void _Chunked_merge ( _BidIt _First, _BidIt _Last, _OutElem ( & _Dest ) [ _Size ],
  _Diff _Chunk, _Diff _Count )
 {
  _Chunked_merge ( _First, _Last, :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Chunk, _Count, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutIt, class _Diff >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result _Chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count )
 {
  _Chunked_merge ( _First, _Last, _Dest, _Chunk, _Count, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 3350 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _BidIt,
 class _Diff,
 class _Ty > inline
 void _Buffered_merge_sort ( _BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator < _Ty > & _Tempbuf )
 {
 _BidIt _Mid = _First;
 for ( _Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX )
  {
  _BidIt _Midend = _Mid;
  std :: advance ( _Midend, ( int ) _ISORT_MAX );

  std :: _Insertion_sort ( _Mid, _Midend );
  _Mid = _Midend;
  }
 std :: _Insertion_sort ( _Mid, _Last );

 for ( _Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2 )
  {
  :: stdext :: _Unchecked_chunked_merge ( _First, _Last, _Tempbuf . _Init ( ),
   _Chunk, _Count );
  :: stdext :: _Unchecked_chunked_merge ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _First,
   _Chunk *= 2, _Count );
  }
 }

template < class _BidIt,
 class _Diff,
 class _Ty > inline
 void _Stable_sort ( _BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator < _Ty > & _Tempbuf )
 {
 if ( _Count <= _ISORT_MAX )
  std :: _Insertion_sort ( _First, _Last );
 else
  {
  _Diff _Count2 = ( _Count + 1 ) / 2;
  _BidIt _Mid = _First;
  std :: advance ( _Mid, _Count2 );

  if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
   {
   _Buffered_merge_sort ( _First, _Mid, _Count2, _Tempbuf );
   _Buffered_merge_sort ( _Mid, _Last, _Count - _Count2, _Tempbuf );
   }
  else
   {
   _Stable_sort ( _First, _Mid, _Count2, _Tempbuf );
   _Stable_sort ( _Mid, _Last, _Count - _Count2, _Tempbuf );
   }

  _Buffered_merge ( _First, _Mid, _Last,
   _Count2, _Count - _Count2, _Tempbuf );
  }
 }

template < class _BidIt,
 class _Diff,
 class _Ty > inline
 void _Stable_sort ( _BidIt _First, _BidIt _Last, _Diff *, _Ty * )
 {
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );
 _Temp_iterator < _Ty > _Tempbuf ( ( _Count + 1 ) / 2 );
 _Stable_sort ( _First, _Last, _Count, _Tempbuf );
 }

template < class _BidIt > inline
 void stable_sort ( _BidIt _First, _BidIt _Last )
 {
 ;
 if ( _First != _Last )
  {
  _Stable_sort ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dist_type ( _First ), _Val_type ( _First ) );
  }
 }


template < class _BidIt,
 class _OutIt,
 class _Diff,
 class _Pr > inline
 void _Chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count, _Pr _Pred, _Range_checked_iterator_tag )
 {
 for ( _Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2 )
  {
  _BidIt _Mid1 = _First;
  std :: advance ( _Mid1, _Chunk );
  _BidIt _Mid2 = _Mid1;
  std :: advance ( _Mid2, _Chunk );

  _Dest = :: stdext :: unchecked_merge ( _First, _Mid1, _Mid1, _Mid2, _Dest, _Pred );
  _First = _Mid2;
  }

 if ( _Count <= _Chunk )
  :: stdext :: unchecked_copy ( _First, _Last, _Dest );
 else
  {
  _BidIt _Mid1 = _First;
  std :: advance ( _Mid1, _Chunk );

  :: stdext :: unchecked_merge ( _First, _Mid1, _Mid1, _Last, _Dest, _Pred );
  }
 }



template < class _BidIt, class _OutIt, class _Diff, class _Pr >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result _Chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count, _Pr _Pred )
 {
  _Chunked_merge ( _First, _Last, _Dest, _Chunk, _Count, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutElem, class _Diff, class _Pr, size_t _Size >
inline
void _Chunked_merge ( _BidIt _First, _BidIt _Last, _OutElem ( & _Dest ) [ _Size ],
  _Diff _Chunk, _Diff _Count, _Pr _Pred )
 {
  _Chunked_merge ( _First, _Last, :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Chunk, _Count, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutIt, class _Diff, class _Pr >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result _Chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count, _Pr _Pred )
 {
  _Chunked_merge ( _First, _Last, _Dest, _Chunk, _Count, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 3496 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Buffered_merge_sort ( _BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator < _Ty > & _Tempbuf, _Pr _Pred )
 {
 _BidIt _Mid = _First;
 for ( _Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX )
  {
  _BidIt _Midn = _Mid;
  std :: advance ( _Midn, ( int ) _ISORT_MAX );

  std :: _Insertion_sort ( _Mid, _Midn, _Pred );
  _Mid = _Midn;
  }
 std :: _Insertion_sort ( _Mid, _Last, _Pred );

 for ( _Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2 )
  {
  :: stdext :: _Unchecked_chunked_merge ( _First, _Last, _Tempbuf . _Init ( ),
   _Chunk, _Count, _Pred );
  :: stdext :: _Unchecked_chunked_merge ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _First,
   _Chunk *= 2, _Count, _Pred );
  }
 }

template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Stable_sort ( _BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator < _Ty > & _Tempbuf, _Pr _Pred )
 {
 if ( _Count <= _ISORT_MAX )
  std :: _Insertion_sort ( _First, _Last, _Pred );
 else
  {
  _Diff _Count2 = ( _Count + 1 ) / 2;
  _BidIt _Mid = _First;
  std :: advance ( _Mid, _Count2 );

  if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
   {
   _Buffered_merge_sort ( _First, _Mid, _Count2, _Tempbuf, _Pred );
   _Buffered_merge_sort ( _Mid, _Last, _Count - _Count2,
    _Tempbuf, _Pred );
   }
  else
   {
   _Stable_sort ( _First, _Mid, _Count2, _Tempbuf, _Pred );
   _Stable_sort ( _Mid, _Last, _Count - _Count2, _Tempbuf, _Pred );
   }

  _Buffered_merge ( _First, _Mid, _Last,
   _Count2, _Count - _Count2, _Tempbuf, _Pred );
  }
 }

template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Stable_sort ( _BidIt _First, _BidIt _Last, _Diff *, _Ty *, _Pr _Pred )
 {
 _Diff _Count = 0;
 _Distance ( _First, _Last, _Count );
 _Temp_iterator < _Ty > _Tempbuf ( ( _Count + 1 ) / 2 );
 _Stable_sort ( _First, _Last, _Count, _Tempbuf, _Pred );
 }

template < class _BidIt,
 class _Pr > inline
 void stable_sort ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 ;
 ;
 if ( _First != _Last )
  {
  _Stable_sort ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ),
   _Dist_type ( _First ), _Val_type ( _First ), _Pred );
  }
 }


template < class _RanIt,
 class _Ty > inline
 void _Partial_sort ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Ty * )
 {
 ;
 ;
 std :: make_heap ( _First, _Mid );

 for ( _RanIt _Next = _Mid; _Next < _Last; ++ _Next )
  if ( ( ( * _Next ) < ( * _First ) ) )
   _Pop_heap ( _First, _Mid, _Next, _Ty ( * _Next ),
    _Dist_type ( _First ) );
 std :: sort_heap ( _First, _Mid );
 }

template < class _RanIt > inline
 void partial_sort ( _RanIt _First, _RanIt _Mid, _RanIt _Last )
 {
 _Partial_sort ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Mid ), :: std :: _Checked_base ( _Last ), _Val_type ( _First ) );
 }


template < class _RanIt,
 class _Ty,
 class _Pr > inline
 void _Partial_sort ( _RanIt _First, _RanIt _Mid, _RanIt _Last,
  _Pr _Pred, _Ty * )
 {
 ;
 ;
 ;
 std :: make_heap ( _First, _Mid, _Pred );

 for ( _RanIt _Next = _Mid; _Next < _Last; ++ _Next )
  if ( _Pred ( * _Next, * _First ) )
   _Pop_heap ( _First, _Mid, _Next, _Ty ( * _Next ), _Pred,
    _Dist_type ( _First ) );
 std :: sort_heap ( _First, _Mid, _Pred );
 }

template < class _RanIt,
 class _Pr > inline
 void partial_sort ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred )
 {
 _Partial_sort ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Mid ), :: std :: _Checked_base ( _Last ), _Pred, _Val_type ( _First ) );
 }


template < class _InIt,
 class _RanIt,
 class _Diff,
 class _Ty > inline
 _RanIt _Partial_sort_copy ( _InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2, _Diff *, _Ty * )
 {
 ;
 ;
 _RanIt _Mid2 = _First2;
 for (; _First1 != _Last1 && _Mid2 != _Last2; ++ _First1, ++ _Mid2 )
  * _Mid2 = * _First1;
 std :: make_heap ( _First2, _Mid2 );

 for (; _First1 != _Last1; ++ _First1 )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   std :: _Adjust_heap ( _First2, _Diff ( 0 ), _Diff ( _Mid2 - _First2 ),
    _Ty ( * _First1 ) );

 std :: sort_heap ( _First2, _Mid2 );
 return ( _Mid2 );
 }

template < class _InIt,
 class _RanIt > inline
 _RanIt partial_sort_copy ( _InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2 )
 {
 if ( _First1 != _Last1 && _First2 != _Last2 )
         :: std :: _Checked_assign_from_base ( _First2, _Partial_sort_copy ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dist_type ( _First2 ), _Val_type ( _First1 ) ) );

 return ( _First2 );
 }
#line 3665 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt,
 class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 _RanIt _Partial_sort_copy ( _InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2, _Pr _Pred, _Diff *, _Ty * )
 {
 ;
 ;
 ;
 _RanIt _Mid2 = _First2;
 for (; _First1 != _Last1 && _Mid2 != _Last2; ++ _First1, ++ _Mid2 )
  * _Mid2 = * _First1;
 std :: make_heap ( _First2, _Mid2, _Pred );

 for (; _First1 != _Last1; ++ _First1 )
  if ( _Pred ( * _First1, * _First2 ) )
   std :: _Adjust_heap ( _First2, _Diff ( 0 ), _Diff ( _Mid2 - _First2 ),
    _Ty ( * _First1 ), _Pred );

 std :: sort_heap ( _First2, _Mid2, _Pred );
 return ( _Mid2 );
 }

template < class _InIt,
 class _RanIt,
 class _Pr > inline
 _RanIt partial_sort_copy ( _InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2, _Pr _Pred )
 {
 if ( _First1 != _Last1 && _First2 != _Last2 )
  :: std :: _Checked_assign_from_base ( _First2, _Partial_sort_copy ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Pred, _Dist_type ( _First2 ), _Val_type ( _First1 ) ) );

 return ( _First2 );
 }
#line 3704 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _RanIt > inline
 void _Nth_element ( _RanIt _First, _RanIt _Nth, _RanIt _Last )
 {
 ;
 for (; _ISORT_MAX < _Last - _First; )
  {
  pair < _RanIt, _RanIt > _Mid =
   std :: _Unguarded_partition ( _First, _Last );

  if ( _Mid . second <= _Nth )
   _First = _Mid . second;
  else if ( _Mid . first <= _Nth )
   return;
  else
   _Last = _Mid . first;
  }

 std :: _Insertion_sort ( _First, _Last );
 }

template < class _RanIt > inline
 void nth_element ( _RanIt _First, _RanIt _Nth, _RanIt _Last )
 {
 _Nth_element ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Nth ), :: std :: _Checked_base ( _Last ) );
 }


template < class _RanIt,
 class _Pr > inline
 void _Nth_element ( _RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred )
 {
 ;
 ;
 for (; _ISORT_MAX < _Last - _First; )
  {
  pair < _RanIt, _RanIt > _Mid =
   std :: _Unguarded_partition ( _First, _Last, _Pred );

  if ( _Mid . second <= _Nth )
   _First = _Mid . second;
  else if ( _Mid . first <= _Nth )
   return;
  else
   _Last = _Mid . first;
  }

 std :: _Insertion_sort ( _First, _Last, _Pred );
 }

template < class _RanIt,
 class _Pr > inline
 void nth_element ( _RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred )
 {
 _Nth_element ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Nth ), :: std :: _Checked_base ( _Last ), _Pred );
 }


template < class _InIt1,
 class _InIt2 > inline
 bool _Includes ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( ( ( * _First2 ) < ( * _First1 ) ) )
   return ( false );
  else if ( * _First1 < * _First2 )
   ++ _First1;
  else
   ++ _First1, ++ _First2;
 return ( _First2 == _Last2 );
 }

template < class _InIt1,
 class _InIt2 > inline
 bool includes ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 return _Includes ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ) );
 }


template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Includes ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Pred ( * _First2, * _First1 ) )
   return ( false );
  else if ( _Pred ( * _First1, * _First2 ) )
   ++ _First1;
  else
   ++ _First1, ++ _First2;
 return ( _First2 == _Last2 );
 }

template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool includes ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 return _Includes ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Pred );
 }


template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt _Set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   * _Dest ++ = * _First1, ++ _First1;
  else if ( * _First2 < * _First1 )
   * _Dest ++ = * _First2, ++ _First2;
  else
   * _Dest ++ = * _First1, ++ _First1, ++ _First2;
 _Dest = :: stdext :: unchecked_copy ( _First1, _Last1, _Dest );
 return ( :: stdext :: unchecked_copy ( _First2, _Last2, _Dest ) );
 }



template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return _Set_union ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, size_t _Size >
inline
_OutElem * set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( set_union ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return _Set_union ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 3887 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Pred ( * _First1, * _First2 ) )
   * _Dest ++ = * _First1, ++ _First1;
  else if ( _Pred ( * _First2, * _First1 ) )
   * _Dest ++ = * _First2, ++ _First2;
  else
   * _Dest ++ = * _First1, ++ _First1, ++ _First2;
 _Dest = :: stdext :: unchecked_copy ( _First1, _Last1, _Dest );
 return ( :: stdext :: unchecked_copy ( _First2, _Last2, _Dest ) );
 }



template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return _Set_union ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( set_union ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return _Set_union ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 3961 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt _Set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   ++ _First1;
  else if ( * _First2 < * _First1 )
   ++ _First2;
  else
   * _Dest ++ = * _First1 ++, ++ _First2;
 return ( _Dest );
 }



template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return _Set_intersection ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, size_t _Size >
inline
_OutElem * set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( set_intersection ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return _Set_intersection ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 4030 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Pred ( * _First1, * _First2 ) )
   ++ _First1;
  else if ( _Pred ( * _First2, * _First1 ) )
   ++ _First2;
  else
   * _Dest ++ = * _First1 ++, ++ _First2;
 return ( _Dest );
 }



template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return _Set_intersection ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( set_intersection ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return _Set_intersection ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 4103 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt _Set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   * _Dest ++ = * _First1, ++ _First1;
  else if ( * _First2 < * _First1 )
   ++ _First2;
  else
   ++ _First1, ++ _First2;
 return ( :: stdext :: unchecked_copy ( _First1, _Last1, _Dest ) );
 }



template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return _Set_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, size_t _Size >
inline
_OutElem * set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( set_difference ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return _Set_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 4172 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Pred ( * _First1, * _First2 ) )
   * _Dest ++ = * _First1, ++ _First1;
  else if ( _Pred ( * _First2, * _First1 ) )
   ++ _First2;
  else
   ++ _First1, ++ _First2;
 return ( :: stdext :: unchecked_copy ( _First1, _Last1, _Dest ) );
 }



template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return _Set_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( set_difference ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return _Set_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 4245 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt _Set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   * _Dest ++ = * _First1, ++ _First1;
  else if ( * _First2 < * _First1 )
   * _Dest ++ = * _First2, ++ _First2;
  else
   ++ _First1, ++ _First2;
 _Dest = :: stdext :: unchecked_copy ( _First1, _Last1, _Dest );
 return ( :: stdext :: unchecked_copy ( _First2, _Last2, _Dest ) );
 }



template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return _Set_symmetric_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, size_t _Size >
inline
_OutElem * set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( set_symmetric_difference ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return _Set_symmetric_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 4315 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag )
 {
 ;
 ;
 ;
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Pred ( * _First1, * _First2 ) )
   * _Dest ++ = * _First1, ++ _First1;
  else if ( _Pred ( * _First2, * _First1 ) )
   * _Dest ++ = * _First2, ++ _First2;
  else
   ++ _First1, ++ _First2;
 _Dest = :: stdext :: unchecked_copy ( _First1, _Last1, _Dest );
 return ( :: stdext :: unchecked_copy ( _First2, _Last2, _Dest ) );
 }



template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return _Set_symmetric_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( set_symmetric_difference ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return _Set_symmetric_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 4389 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt > inline
 _FwdIt _Max_element ( _FwdIt _First, _FwdIt _Last )
 {
 ;
 _FwdIt _Found = _First;
 if ( _First != _Last )
  for (; ++ _First != _Last; )
   if ( ( ( * _Found ) < ( * _First ) ) )
    _Found = _First;
 return ( _Found );
 }

template < class _FwdIt > inline
 _FwdIt max_element ( _FwdIt _First, _FwdIt _Last )
 {
 :: std :: _Checked_assign_from_base ( _First, _Max_element ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ) ) );

 return ( _First );
 }
#line 4410 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Max_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 ;
 ;
 _FwdIt _Found = _First;
 if ( _First != _Last )
  for (; ++ _First != _Last; )
   if ( _Pred ( * _Found, * _First ) )
    _Found = _First;
 return ( _Found );
 }

template < class _FwdIt,
 class _Pr > inline
 _FwdIt max_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 :: std :: _Checked_assign_from_base ( _First, _Max_element ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred ) );

 return ( _First );
 }
#line 4434 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt > inline
 _FwdIt _Min_element ( _FwdIt _First, _FwdIt _Last )
 {
 ;
 _FwdIt _Found = _First;
 if ( _First != _Last )
  for (; ++ _First != _Last; )
   if ( ( ( * _First ) < ( * _Found ) ) )
    _Found = _First;
 return ( _Found );
 }

template < class _FwdIt > inline
 _FwdIt min_element ( _FwdIt _First, _FwdIt _Last )
 {
 :: std :: _Checked_assign_from_base ( _First, _Min_element ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ) ) );

 return ( _First );
 }
#line 4455 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Min_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 ;
 ;
 _FwdIt _Found = _First;
 if ( _First != _Last )
  for (; ++ _First != _Last; )
   if ( _Pred ( * _First, * _Found ) )
    _Found = _First;
 return ( _Found );
 }

template < class _FwdIt,
 class _Pr > inline
 _FwdIt min_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 :: std :: _Checked_assign_from_base ( _First, _Min_element ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred ) );

 return ( _First );
 }
#line 4479 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
template < class _BidIt > inline
 bool _Next_permutation ( _BidIt _First, _BidIt _Last )
 {
 ;
 _BidIt _Next = _Last;
 if ( _First == _Last || _First == -- _Next )
  return ( false );

 for (;; )
  {
  _BidIt _Next1 = _Next;
  if ( ( ( * -- _Next ) < ( * _Next1 ) ) )
   {
   _BidIt _Mid = _Last;
   for (; ! ( ( * _Next ) < ( * -- _Mid ) ); )
    ;
   std :: iter_swap ( _Next, _Mid );
   std :: reverse ( _Next1, _Last );
   return ( true );
   }

  if ( _Next == _First )
   {
   std :: reverse ( _First, _Last );
   return ( false );
   }
  }
 }

template < class _BidIt > inline
 bool next_permutation ( _BidIt _First, _BidIt _Last )
 {
 return _Next_permutation ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ) );
 }


template < class _BidIt,
 class _Pr > inline
 bool _Next_permutation ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 ;
 ;
 _BidIt _Next = _Last;
 if ( _First == _Last || _First == -- _Next )
  return ( false );

 for (;; )
  {
  _BidIt _Next1 = _Next;
  if ( _Pred ( * -- _Next, * _Next1 ) )
   {
   _BidIt _Mid = _Last;
   for (; ! _Pred ( * _Next, * -- _Mid ); )
    ;
   std :: iter_swap ( _Next, _Mid );
   std :: reverse ( _Next1, _Last );
   return ( true );
   }

  if ( _Next == _First )
   {
   std :: reverse ( _First, _Last );
   return ( false );
   }
  }
 }

template < class _BidIt,
 class _Pr > inline
 bool next_permutation ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 return _Next_permutation ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred );
 }


template < class _BidIt > inline
 bool _Prev_permutation ( _BidIt _First, _BidIt _Last )
 {
 ;
 _BidIt _Next = _Last;
 if ( _First == _Last || _First == -- _Next )
  return ( false );
 for (;; )
  {
  _BidIt _Next1 = _Next;
  if ( ( ( * _Next1 ) < ( * -- _Next ) ) )
   {
   _BidIt _Mid = _Last;
   for (; ! ( ( * -- _Mid ) < ( * _Next ) ); )
    ;
   std :: iter_swap ( _Next, _Mid );
   std :: reverse ( _Next1, _Last );
   return ( true );
   }

  if ( _Next == _First )
   {
   std :: reverse ( _First, _Last );
   return ( false );
   }
  }
 }

template < class _BidIt > inline
 bool prev_permutation ( _BidIt _First, _BidIt _Last )
 {
 return _Prev_permutation ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ) );
 }


template < class _BidIt,
 class _Pr > inline
 bool _Prev_permutation ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 ;
 ;
 _BidIt _Next = _Last;
 if ( _First == _Last || _First == -- _Next )
  return ( false );

 for (;; )
  {
  _BidIt _Next1 = _Next;
  if ( _Pred ( * _Next1, * -- _Next ) )
   {
   _BidIt _Mid = _Last;
   for (; ! _Pred ( * -- _Mid, * _Next ); )
    ;
   std :: iter_swap ( _Next, _Mid );
   std :: reverse ( _Next1, _Last );
   return ( true );
   }

  if ( _Next == _First )
   {
   std :: reverse ( _First, _Last );
   return ( false );
   }
  }
 }

template < class _BidIt,
 class _Pr > inline
 bool prev_permutation ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 return _Prev_permutation ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Pred );
 }

}

namespace stdext { 

template < class _InIt, class _OutIt, class _Fn1 >
inline
 _OutIt unchecked_transform ( _InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func )
 {
  return :: std :: _Transform ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Func,
   :: std :: _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutIt, class _Fn1 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_transform ( _InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func )
 {
 return :: std :: _Transform ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Func,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutElem, class _Fn1, size_t _Size >
inline
_OutElem * checked_transform ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ], _Fn1 _Func )
 {
 return ( checked_transform ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Func ) . base ( ) );
 }

template < class _InIt, class _OutIt, class _Fn1 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_transform ( _InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func )
 {
 return :: std :: _Transform ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Func,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutIt, class _Fn2 >
inline
 _OutIt unchecked_transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutIt _Dest, _Fn2 _Func )
 {
  return :: std :: _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Dest, _Func,
   :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Iter_random ( _First1, _Dest ),
   :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutIt, class _Fn2 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _InIt2 > :: _Result && :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutIt _Dest, _Fn2 _Func )
 {
 return :: std :: _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Dest, _Func,
  :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Iter_random ( _First1, _Dest ),
  :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InElem2, class _OutElem, class _Fn2, size_t _SizeFirst2, size_t _SizeDest >
inline
_OutElem * checked_transform ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _SizeFirst2 ],
  _OutElem ( & _Dest ) [ _SizeDest ], _Fn2 _Func )
 {
 return ( checked_transform ( _First1, _Last1,
  :: stdext :: make_checked_array_iterator ( _First2, _SizeFirst2 ),
  :: stdext :: make_checked_array_iterator ( _Dest, _SizeDest ),
  _Func ) . base ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Fn2, size_t _SizeDest >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _InIt2 > :: _Result, _OutElem * > :: _Result checked_transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutElem ( & _Dest ) [ _SizeDest ], _Fn2 _Func )
 {
 return ( :: std :: _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
  :: stdext :: make_checked_array_iterator ( _Dest, _SizeDest ), _Func,
  :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Iter_cat ( _First1 ),
  :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) ) . base ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Fn2, size_t _SizeDest >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _InIt2 > :: _Result, _OutElem * > :: _Result checked_transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutElem ( & _Dest ) [ _SizeDest ], _Fn2 _Func )
 {
 return ( :: std :: _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
  :: stdext :: make_checked_array_iterator ( _Dest, _SizeDest ), _Func,
  :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Iter_cat ( _First1 ),
  :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) ) . base ( ) );
 }

template < class _InIt1, class _InElem2, class _OutIt, class _Fn2, size_t _SizeFirst2 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_transform ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _SizeFirst2 ],
  _OutIt _Dest, _Fn2 _Func )
 {
 return ( :: std :: _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: stdext :: make_checked_array_iterator ( _First2, _SizeFirst2 ),
  _Dest, _Func,
  :: std :: _Iter_cat ( _First1 ), :: std :: _Iter_random ( _First1, _Dest ),
  :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt1, class _InElem2, class _OutIt, class _Fn2, size_t _SizeFirst2 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_transform ( _InIt1 _First1, _InIt1 _Last1, _InElem2 ( & _First2 ) [ _SizeFirst2 ],
  _OutIt _Dest, _Fn2 _Func )
 {
 return ( :: std :: _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: stdext :: make_checked_array_iterator ( _First2, _SizeFirst2 ),
  _Dest, _Func,
  :: std :: _Iter_cat ( _First1 ), :: std :: _Iter_random ( _First1, _Dest ),
  :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt1, class _InIt2, class _OutIt, class _Fn2 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _InIt2 > :: _Result || ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_transform ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
  _OutIt _Dest, _Fn2 _Func )
 {
 return :: std :: _Transform ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2, _Dest, _Func,
  :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Iter_random ( _First1, _Dest ),
  :: std :: _Range_checked_iterator_tag ( ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdIt1, class _FwdIt2 >
inline
 _FwdIt2 unchecked_swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2 )
 {
  return :: std :: _Swap_ranges ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
   :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdIt1, class _FwdIt2 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _FwdIt2 > :: _Result, _FwdIt2 > :: _Result checked_swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2 )
 {
  return :: std :: _Swap_ranges ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
   :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdIt1, class _FwdElem2, size_t _Size >
inline
_FwdElem2 * checked_swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdElem2 ( & _First2 ) [ _Size ] )
 {
  return ( checked_swap_ranges ( _First1, _Last1, :: stdext :: make_checked_array_iterator ( _First2, _Size ) ) . base ( ) );
 }

template < class _FwdIt1, class _FwdIt2 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _FwdIt2 > :: _Result, _FwdIt2 > :: _Result checked_swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2 )
 {
  return :: std :: _Swap_ranges ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), _First2,
   :: std :: _Iter_random ( _First1, _First2 ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt unchecked_replace_copy ( _InIt _First, _InIt _Last, _OutIt _Dest,
  const _Ty & _Oldval, const _Ty & _Newval )
 {
  return :: std :: _Replace_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Oldval, _Newval,
   :: std :: _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Ty > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_replace_copy ( _InIt _First, _InIt _Last, _OutIt _Dest,
  const _Ty & _Oldval, const _Ty & _Newval )
 {
 return :: std :: _Replace_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Oldval, _Newval,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutElem, class _Ty, size_t _Size >
inline
_OutElem * checked_replace_copy ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ],
  const _Ty & _Oldval, const _Ty & _Newval )
 {
 return ( checked_replace_copy ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ),
  _Oldval, _Newval ) . base ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Ty > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_replace_copy ( _InIt _First, _InIt _Last, _OutIt _Dest,
  const _Ty & _Oldval, const _Ty & _Newval )
 {
 return :: std :: _Replace_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Oldval, _Newval,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty > inline
 _OutIt unchecked_replace_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred, const _Ty & _Val )
 {
  return :: std :: _Replace_copy_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, _Val,
   :: std :: _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_replace_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred, const _Ty & _Val )
 {
 return :: std :: _Replace_copy_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, _Val,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutElem, class _Pr, class _Ty, size_t _Size >
inline
_OutElem * checked_replace_copy_if ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ],
  _Pr _Pred, const _Ty & _Val )
 {
 return ( checked_replace_copy_if ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ),
  _Pred, _Val ) . base ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_replace_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred, const _Ty & _Val )
 {
 return :: std :: _Replace_copy_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, _Val,
  :: std :: _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _OutIt,
 class _Diff,
 class _Fn0 > inline
 void unchecked_generate_n ( _OutIt _Dest, _Diff _Count, _Fn0 _Func )
 {
  :: std :: _Generate_n ( _Dest, _Count, _Func,
   :: std :: _Iter_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _OutIt,
 class _Diff,
 class _Fn0 > inline
void checked_generate_n ( _OutIt _Dest, _Diff _Count, _Fn0 _Func, typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _Diff > :: _Result = 0 )
 {
 :: std :: _Generate_n ( _Dest, _Count, _Func,
  :: std :: _Iter_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _OutElem, class _Diff, class _Fn0, size_t _Size >
inline
void checked_generate_n ( _OutElem ( & _Dest ) [ _Size ], _Diff _Count, _Fn0 _Func )
 {
 checked_generate_n ( :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Count, _Func );
 }

template < class _OutIt,
 class _Diff,
 class _Fn0 > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
void checked_generate_n ( _OutIt _Dest, _Diff _Count, _Fn0 _Func, typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _Diff > :: _Result = 0 )
 {
 :: std :: _Generate_n ( _Dest, _Count, _Func,
  :: std :: _Iter_cat ( _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt unchecked_remove_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Val )
 {
  return :: std :: _Remove_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Val,
   :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Ty > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_remove_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Val )
 {
 return :: std :: _Remove_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Val, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutElem, class _Ty, size_t _Size >
inline
_OutElem * checked_remove_copy ( _InIt _First, _InIt _Last,
  _OutElem ( & _Dest ) [ _Size ], const _Ty & _Val )
 {
 return ( checked_remove_copy ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ),
  _Val ) . base ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Ty > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_remove_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Val )
 {
 return :: std :: _Remove_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Val, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt unchecked_remove_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred )
 {
  return :: std :: _Remove_copy_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred,
   :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_remove_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred )
 {
 return :: std :: _Remove_copy_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * checked_remove_copy_if ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( checked_remove_copy_if ( _First, _Last,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) );
 }

template < class _InIt,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_remove_copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred )
 {
 return :: std :: _Remove_copy_if ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt,
 class _OutIt > inline
 _OutIt unchecked_unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return ( _First == _Last ? _Dest :
  :: std :: _Unique_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
   :: std :: _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return ( _First == _Last ? _Dest :
  :: std :: _Unique_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, :: std :: _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _OutElem, size_t _Size >
inline
_OutElem * checked_unique_copy ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( _First == _Last ? _Dest :
  ( checked_unique_copy ( _First, _Last, :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) ) );
 }

template < class _InIt,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return ( _First == _Last ? _Dest :
  :: std :: _Unique_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, :: std :: _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt unchecked_unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred )
 {
 return ( _First == _Last ? _Dest
  : :: std :: _Unique_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred,
   :: std :: _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred )
 {
 return ( _First == _Last ? _Dest
  : :: std :: _Unique_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, :: std :: _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _InIt, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * checked_unique_copy ( _InIt _First, _InIt _Last, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( _First == _Last ? _Dest
  : ( checked_unique_copy ( _First, _Last, :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) ) );
 }

template < class _InIt,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred )
 {
 return ( _First == _Last ? _Dest
  : :: std :: _Unique_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, _Pred, :: std :: _Iter_cat ( _First ), :: std :: _Range_checked_iterator_tag ( ) ) );
 }

template < class _BidIt,
 class _OutIt > inline
 _OutIt unchecked_reverse_copy ( _BidIt _First, _BidIt _Last, _OutIt _Dest )
 {
  return :: std :: _Reverse_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest,
   :: std :: _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_reverse_copy ( _BidIt _First, _BidIt _Last, _OutIt _Dest )
 {
 return :: std :: _Reverse_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, :: std :: _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutElem, size_t _Size >
inline
_OutElem * checked_reverse_copy ( _BidIt _First, _BidIt _Last, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( checked_reverse_copy ( _First, _Last, :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _BidIt,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_reverse_copy ( _BidIt _First, _BidIt _Last, _OutIt _Dest )
 {
 return :: std :: _Reverse_copy ( :: std :: _Checked_base ( _First ), :: std :: _Checked_base ( _Last ), _Dest, :: std :: _Iter_random ( _First, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdIt,
 class _OutIt > inline
 _OutIt unchecked_rotate_copy ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest )
 {
  return :: std :: _Rotate_copy ( _First, _Mid, _Last, _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdIt, class _OutIt >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_rotate_copy ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest )
 {
  return :: std :: _Rotate_copy ( _First, _Mid, _Last, _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _FwdIt, class _OutElem, size_t _Size >
inline
_OutElem * checked_rotate_copy ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutElem ( & _Dest ) [ _Size ] )
 {
  return ( checked_rotate_copy ( _First, _Mid, _Last, :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _FwdIt, class _OutIt >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_rotate_copy ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest )
 {
  return :: std :: _Rotate_copy ( _First, _Mid, _Last, _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt unchecked_merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
  return :: std :: _Merge ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest,
   :: std :: _Iter_random ( _First1, _First2, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return :: std :: _Merge ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest,
  :: std :: _Iter_random ( _First1, _First2, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, size_t _Size >
inline
_OutElem * checked_merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( checked_merge ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return :: std :: _Merge ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest,
  :: std :: _Iter_random ( _First1, _First2, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt unchecked_merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
  return :: std :: _Merge ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest, _Pred,
   :: std :: _Iter_random ( _First1, _First2, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return :: std :: _Merge ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred,
  :: std :: _Iter_random ( _First1, _First2, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * checked_merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( checked_merge ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return :: std :: _Merge ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred,
  :: std :: _Iter_random ( _First1, _First2, _Dest ), :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1, class _BidIt2, class _BidIt3 >
inline
 _BidIt3 _Unchecked_merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest )
 {
  return :: std :: _Merge_backward ( _First1, _Last1, _First2, _Last2, _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1, class _BidIt2, class _BidIt3 >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _BidIt3 > :: _Result, _BidIt3 > :: _Result _Checked_merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest )
 {
  return :: std :: _Merge_backward ( _First1, _Last1, _First2, _Last2, _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1, class _BidIt2, class _BidIt3 >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _BidIt3 > :: _Result, _BidIt3 > :: _Result _Checked_merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest )
 {
  return :: std :: _Merge_backward ( _First1, _Last1, _First2, _Last2, _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1, class _BidIt2, class _BidIt3, class _Pr >
inline
 _BidIt3 _Unchecked_merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred )
 {
  return :: std :: _Merge_backward ( _First1, _Last1, _First2, _Last2, _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1, class _BidIt2, class _BidIt3, class _Pr >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _BidIt3 > :: _Result, _BidIt3 > :: _Result _Checked_merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred )
 {
  return :: std :: _Merge_backward ( _First1, _Last1, _First2, _Last2, _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt1, class _BidIt2, class _BidIt3, class _Pr >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _BidIt3 > :: _Result, _BidIt3 > :: _Result _Checked_merge_backward ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred )
 {
  return :: std :: _Merge_backward ( _First1, _Last1, _First2, _Last2, _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutIt, class _Diff >
inline
 void _Unchecked_chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count )
 {
  :: std :: _Chunked_merge ( _First, _Last, _Dest, _Chunk, _Count, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutIt, class _Diff >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result _Checked_chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count )
 {
  :: std :: _Chunked_merge ( _First, _Last, _Dest, _Chunk, _Count, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutElem, class _Diff, size_t _Size >
inline
void _Checked_chunked_merge ( _BidIt _First, _BidIt _Last, _OutElem ( & _Dest ) [ _Size ],
  _Diff _Chunk, _Diff _Count )
 {
  :: std :: _Chunked_merge ( _First, _Last, :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Chunk, _Count, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutIt, class _Diff >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result _Checked_chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count )
 {
  :: std :: _Chunked_merge ( _First, _Last, _Dest, _Chunk, _Count, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutIt, class _Diff, class _Pr >
inline
 void _Unchecked_chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count, _Pr _Pred )
 {
  :: std :: _Chunked_merge ( _First, _Last, _Dest, _Chunk, _Count, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutIt, class _Diff, class _Pr >
inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result _Checked_chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count, _Pr _Pred )
 {
  :: std :: _Chunked_merge ( _First, _Last, _Dest, _Chunk, _Count, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutElem, class _Diff, class _Pr, size_t _Size >
inline
void _Checked_chunked_merge ( _BidIt _First, _BidIt _Last, _OutElem ( & _Dest ) [ _Size ],
  _Diff _Chunk, _Diff _Count, _Pr _Pred )
 {
  :: std :: _Chunked_merge ( _First, _Last, :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Chunk, _Count, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _BidIt, class _OutIt, class _Diff, class _Pr >
inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, void > :: _Result _Checked_chunked_merge ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count, _Pr _Pred )
 {
  :: std :: _Chunked_merge ( _First, _Last, _Dest, _Chunk, _Count, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt unchecked_set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
  return :: std :: _Set_union ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest,
   :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return :: std :: _Set_union ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, size_t _Size >
inline
_OutElem * checked_set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( checked_set_union ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return :: std :: _Set_union ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt unchecked_set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
  return :: std :: _Set_union ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest, _Pred,
   :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return :: std :: _Set_union ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * checked_set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( checked_set_union ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return :: std :: _Set_union ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt unchecked_set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
  return :: std :: _Set_intersection ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest,
   :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return :: std :: _Set_intersection ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, size_t _Size >
inline
_OutElem * checked_set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( checked_set_intersection ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return :: std :: _Set_intersection ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt unchecked_set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
  return :: std :: _Set_intersection ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest, _Pred,
   :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return :: std :: _Set_intersection ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * checked_set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( checked_set_intersection ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return :: std :: _Set_intersection ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt unchecked_set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
  return :: std :: _Set_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest,
   :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return :: std :: _Set_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, size_t _Size >
inline
_OutElem * checked_set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( checked_set_difference ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return :: std :: _Set_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt unchecked_set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
  return :: std :: _Set_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest, _Pred,
   :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return :: std :: _Set_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * checked_set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( checked_set_difference ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return :: std :: _Set_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt unchecked_set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
  return :: std :: _Set_symmetric_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest,
   :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return :: std :: _Set_symmetric_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, size_t _Size >
inline
_OutElem * checked_set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ] )
 {
 return ( checked_set_symmetric_difference ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ) ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return :: std :: _Set_symmetric_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt unchecked_set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
  return :: std :: _Set_symmetric_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ), :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ), _Dest, _Pred,
   :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
typename :: std :: _Enable_if < :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return :: std :: _Set_symmetric_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }

template < class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size >
inline
_OutElem * checked_set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutElem ( & _Dest ) [ _Size ], _Pr _Pred )
 {
 return ( checked_set_symmetric_difference ( _First1, _Last1, _First2, _Last2,
  :: stdext :: make_checked_array_iterator ( _Dest, _Size ), _Pred ) . base ( ) );
 }

template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
__declspec ( deprecated ( "Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. T" "o disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) )
typename :: std :: _Enable_if < ! :: std :: _Is_checked_iterator < _OutIt > :: _Result, _OutIt > :: _Result checked_set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 return :: std :: _Set_symmetric_difference ( :: std :: _Checked_base ( _First1 ), :: std :: _Checked_base ( _Last1 ),
  :: std :: _Checked_base ( _First2 ), :: std :: _Checked_base ( _Last2 ),
  _Dest, _Pred, :: std :: _Range_checked_iterator_tag ( ) );
 }
#line 5765 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\algorithm"
}

#pragma warning(default: 4244)


#pragma warning(pop)
#pragma pack ( pop )
#line 52 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\trimesh2\\include\\Vec.h"
using std::min;
using std::max;
using std::swap;
#line 71 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\trimesh2\\include\\Vec.h"
template<bool X> struct VEC_STATIC_ASSERTION_FAILURE; 
template<> struct VEC_STATIC_ASSERTION_FAILURE< true>  { 
void operator()() { } }; 



template<int D, class T> 
class Vec { 

T v[D]; 



public: Vec() { for (int i = 0; i < D; i++) { ((this->v)[i]) = ((T)(0)); }  } 


Vec(T x, T y) 
{ VEC_STATIC_ASSERTION_FAILURE< (D == 2)> (); ((this->v)[0]) = x; ((this->v)[1]) = y; } 
Vec(T x, T y, T z) 
{ VEC_STATIC_ASSERTION_FAILURE< (D == 3)> (); ((this->v)[0]) = x; ((this->v)[1]) = y; ((this->v)[2]) = z; } 
Vec(T x, T y, T z, T w) 
{ VEC_STATIC_ASSERTION_FAILURE< (D == 4)> (); ((this->v)[0]) = x; ((this->v)[1]) = y; ((this->v)[2]) = z; ((this->v)[3]) = w; } 



template<class S> explicit Vec(const S &x) 
{ for (int i = 0; i < D; i++) { ((this->v)[i]) = ((T)(x[i])); }  } 




const T &operator[](int i) const 
{ return (this->v)[i]; } 
T &operator[](int i) 
{ return (this->v)[i]; } 
operator const T *() const 
{ return this->v; } 
operator const T *() 
{ return this->v; } 
operator T *() 
{ return this->v; } 


::Vec< D, T>  &operator+=(const ::Vec< D, T>  &x) 
{ for (int i = 0; i < D; i++) { ((this->v)[i]) += x[i]; }  return *this; } 
::Vec< D, T>  &operator-=(const ::Vec< D, T>  &x) 
{ for (int i = 0; i < D; i++) { ((this->v)[i]) -= x[i]; }  return *this; } 
::Vec< D, T>  &operator*=(const ::Vec< D, T>  &x) 
{ for (int i = 0; i < D; i++) { ((this->v)[i]) *= x[i]; }  return *this; } 
::Vec< D, T>  &operator*=(const T &x) 
{ for (int i = 0; i < D; i++) { ((this->v)[i]) *= x; }  return *this; } 
::Vec< D, T>  &operator/=(const ::Vec< D, T>  &x) 
{ for (int i = 0; i < D; i++) { ((this->v)[i]) /= x[i]; }  return *this; } 
::Vec< D, T>  &operator/=(const T &x) 
{ for (int i = 0; i < D; i++) { ((this->v)[i]) /= x; }  return *this; } 




typedef T value_type; 
size_t size() const 
{ return D; } 
T sum() const 
{ auto T total = ((this->v)[0]); 
for (int i = 1; i < D; i++) { total += (this->v)[i]; }  
return total; } 
T avg() const 
{ return this->sum() / D; } 
T product() const 
{ auto T total = ((this->v)[0]); 
for (int i = 1; i < D; i++) { total *= (this->v)[i]; }  
return total; } 
T min() const 
{ auto T m = ((this->v)[0]); 
for (int i = 0; i < D; i++) { 
if ((this->v)[i] < m) { m = (this->v)[i]; }  }  
return m; } 
T max() const 
{ auto T m = ((this->v)[0]); 
for (int i = 1; i < D; i++) { 
if ((this->v)[i] > m) { m = (this->v)[i]; }  }  
return m; } 
T *begin() { return &((this->v)[0]); } 
const T *begin() const { return &((this->v)[0]); } 
T *end() { return this->begin() + D; } 
const T *end() const { return this->begin() + D; } 
void clear() { for (int i = 0; i < D; i++) { ((this->v)[i]) = ((T)(0)); }  } 
bool empty() const 
{ for (int i = 0; i < D; i++) { 
if ((this->v)[i]) { return false; }  }  
return true; } 
}; 

typedef Vec< 3, float>  vec; 
typedef Vec< 3, float>  point; 
typedef Vec< 2, float>  vec2; 
typedef Vec< 3, float>  vec3; 
typedef Vec< 4, float>  vec4; 
typedef Vec< 2, int>  ivec2; 
typedef Vec< 3, int>  ivec3; 
typedef Vec< 4, int>  ivec4; 



template<int D, class T> static inline const Vec< D, T>  
operator+(const Vec< D, T>  &v1, const Vec< D, T>  &v2) 
{ 
return ((Vec< D, T> )(v1)) += v2; 
} 

template<int D, class T> static inline const Vec< D, T>  
operator-(const Vec< D, T>  &v1, const Vec< D, T>  &v2) 
{ 
return ((Vec< D, T> )(v1)) -= v2; 
} 

template<int D, class T> static inline const Vec< D, T>  
operator*(const Vec< D, T>  &v1, const Vec< D, T>  &v2) 
{ 
return ((Vec< D, T> )(v1)) *= v2; 
} 

template<int D, class T> static inline const Vec< D, T>  
operator/(const Vec< D, T>  &v1, const Vec< D, T>  &v2) 
{ 
return ((Vec< D, T> )(v1)) /= v2; 
} 

template<int D, class T> static inline const T 
operator^(const Vec< D, T>  &v1, const Vec< D, T>  &v2) 
{ 
auto T sum = (v1[0] * v2[0]); 
for (int i = 1; i < D; i++) { 
sum += v1[i] * v2[i]; }  
return sum; 
} 


template<class T> static inline const Vec< 3, T>  
operator%(const Vec< 3, T>  &v1, const Vec< 3, T>  &v2) 
{ 
return Vec< 3, T> (v1[1] * v2[2] - v1[2] * v2[1], v1[2] * v2[0] - v1[0] * v2[2], v1[0] * v2[1] - v1[1] * v2[0]); 


} 
#line 221 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\trimesh2\\include\\Vec.h"
template<int D, class T> static inline bool 
operator==(const Vec< D, T>  &v1, const Vec< D, T>  &v2) 
{ 
for (int i = 0; i < D; i++) { 
if (v1[i] != v2[i]) { 
return false; }  }  
return true; 
} 

template<int D, class T> static inline bool 
operator!=(const Vec< D, T>  &v1, const Vec< D, T>  &v2) 
{ 
for (int i = 0; i < D; i++) { 
if (v1[i] != v2[i]) { 
return true; }  }  
return false; 
} 



template<int D, class T> static inline const Vec< D, T>  &
operator+(const Vec< D, T>  &v) 
{ 
return v; 
} 

template<int D, class T> static inline const Vec< D, T>  
operator-(const Vec< D, T>  &v) 
{ 
auto Vec< D, T>  result(v); 
for (int i = 0; i < D; i++) { 
(result[i]) = -result[i]; }  
return result; 
} 

template<int D, class T> static inline bool 
operator!(const Vec< D, T>  &v) 
{ 
return (v.empty()); 
} 



template<int D, class T> static inline const Vec< D, T>  
operator*(const T &x, const Vec< D, T>  &v) 
{ 
auto Vec< D, T>  result(v); 
for (int i = 0; i < D; i++) { 
(result[i]) = x * result[i]; }  
return result; 
} 

template<int D, class T> static inline const Vec< D, T>  
operator*(const Vec< D, T>  &v, const T &x) 
{ 
return ((Vec< D, T> )(v)) *= x; 
} 

template<int D, class T> static inline const Vec< D, T>  
operator/(const T &x, const Vec< D, T>  &v) 
{ 
auto Vec< D, T>  result(v); 
for (int i = 0; i < D; i++) { 
(result[i]) = x / result[i]; }  
return result; 
} 

template<int D, class T> static inline const Vec< D, T>  
operator/(const Vec< D, T>  &v, const T &x) 
{ 
return ((Vec< D, T> )(v)) /= x; 
} 



template<int D, class T> static inline std::ostream &
operator<<(std::ostream &os, const Vec< D, T>  &v) 

{ 
(os << ("(")); 
for (int i = 0; i < (D - 1); i++) { 
(os << (v[i])) << ", "; }  
return (os << (v[D - 1])) << ")"; 
} 

template<int D, class T> static inline std::istream &
operator>>(std::istream &is, Vec< D, T>  &v) 
{ 
auto char c1 = (0); auto char c2 = (0); 

(is >> c1); 
if ((c1 == ('(')) || (c1 == ('['))) { 
((is >> (v[0])) >> (&std::ws)) >> c2; 
for (int i = 1; i < D; i++) { 
if (c2 == (',')) { 
((is >> (v[i])) >> (&std::ws)) >> c2; } else { 

is.setstate((std::_Iosb< int> ::_Iostate)2); }  
}  
}  

if ((c1 == ('(')) && (c2 != (')'))) { 
is.setstate((std::_Iosb< int> ::_Iostate)2); } else { 
if ((c1 == ('[')) && (c2 != (']'))) { 
is.setstate((std::_Iosb< int> ::_Iostate)2); }  }  

return is; 
} 



template<class T> static inline T 
sqr(const T &x) 
{ 
return x * x; 
} 

template<class T> static inline T 
cube(const T &x) 
{ 
return (x * x) * x; 
} 



template<class T> static inline T 
fract(const T &x) 
{ 
return x - floor(x); 
} 

template<class T> static inline T 
clamp(const T &x, const T &a, const T &b) 
{ 
return (x > a) ? ((x < b) ? x : b) : a; 
} 

template<class T, class S> static inline T 
mix(const T &x, const T &y, const S &a) 
{ 
return (((S)(1)) - a) * x + a * y; 
} 

template<class T> static inline T 
step(const T &x, const T &a) 
{ 
return (x < a) ? ((T)(0)) : ((T)(1)); 
} 

template<class T> static inline T 
smoothstep(const T &x, const T &a, const T &b) 
{ 
if (b <= a) { return step(x, a); }  
auto T t = ((x - a) / (b - a)); 
return (t <= ((T)(0))) ? ((T)(0)) : ((t >= ((T)(1))) ? ((T)(1)) : ((t * t) * (((T)(3)) - ((T)(2)) * t))); 
} 


template<class T> static inline T 
trinorm(const T &v0, const T &v1, const T &v2) 
{ 
return ((typename T::value_type)(0.5)) * ((v1 - v0) % (v2 - v0)); 
} 


template<class T> static inline T 
sgn(const T &x) 
{ 
return (x < ((T)(0))) ? ((T)(-1)) : ((T)(1)); 
} 



template<int D, class T> static inline const T 
len2(const Vec< D, T>  &v) 
{ 
auto T l2 = (v[0] * v[0]); 
for (int i = 1; i < D; i++) { 
l2 += v[i] * v[i]; }  
return l2; 
} 

template<int D, class T> static inline const T 
len(const Vec< D, T>  &v) 
{ 
return sqrt(len2(v)); 
} 

template<int D, class T> static inline const T 
dist2(const Vec< D, T>  &v1, const Vec< D, T>  &v2) 
{ 
auto T d2 = (sqr(v2[0] - v1[0])); 
for (int i = 1; i < D; i++) { 
d2 += sqr(v2[i] - v1[i]); }  
return d2; 
} 

template<int D, class T> static inline const T 
dist(const Vec< D, T>  &v1, const Vec< D, T>  &v2) 
{ 
return sqrt(dist2(v1, v2)); 
} 

template<int D, class T> static inline Vec< D, T>  
normalize(Vec< D, T>  &v) 
{ 
auto T l = (len(v)); 
if (l <= ((T)(0))) { 
(v[0]) = ((T)(1)); 
for (int i = 1; i < D; i++) { 
(v[i]) = ((T)(0)); }  
return v; 
}  

l = ((T)(1)) / l; 
for (int i = 0; i < D; i++) { 
(v[i]) *= l; }  

return v; 
} 

template<int D, class T> static inline void 
swap(const Vec< D, T>  &v1, const Vec< D, T>  &v2) 
{ 
for (int i = 0; i < D; i++) { 
swap(v1[i], v2[i]); }  
} 

template<int D, class T> static inline Vec< D, T>  
fabs(const Vec< D, T>  &v) 
{ 
auto Vec< D, T>  result(v); 
for (int i = 0; i < D; i++) { 
if (result[i] < ((T)(0))) { 
(result[i]) = -result[i]; }  }  
return result; 
} 
#line 23 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\trimesh2\\include\\Color.h"
class Color : public Vec< 3, float>  { 

public: Color() 
{ } 
Color(const ::Vec< 3, float>  &v_) : ::Vec< 3, float> ((v_)) 
{ } 
Color(const ::Vec< 3, double>  &v_) : ::Vec< 3, float> ((float)(v_[0]), (float)(v_[1]), (float)(v_[2])) 
{ } 
Color(float r, float g, float b) : ::Vec< 3, float> (r, g, b) 
{ } 
Color(double r, double g, double b) : ::Vec< 3, float> ((float)r, (float)g, (float)b) 
{ } 
explicit Color(const float *rgb) : ::Vec< 3, float> (rgb[0], rgb[1], rgb[2]) 
{ } 
explicit Color(const double *rgb) : ::Vec< 3, float> ((float)(rgb[0]), (float)(rgb[1]), (float)(rgb[2])) 
{ } 



explicit Color(float c) : ::Vec< 3, float> (c, c, c) 
{ } 
explicit Color(double c) : ::Vec< 3, float> ((float)c, (float)c, (float)c) 
{ } 
Color &operator=(float c) 
{ return (*this) = ((Color)(c)); } 
Color &operator=(double c) 
{ return (*this) = ((Color)(c)); } 


Color(int r, int g, int b) 
{ 
auto const float mult = ((1.0F) / (255.0F)); 
(*this) = Color(mult * r, mult * g, mult * b); 
} 
explicit Color(const int *rgb) 
{ (*this) = Color(rgb[0], rgb[1], rgb[2]); } 
explicit Color(const unsigned char *rgb) 
{ (*this) = Color(rgb[0], rgb[1], rgb[2]); } 
explicit Color(int c) 
{ (*this) = Color(c, c, c); } 
Color &operator=(int c) 
{ return (*this) = ((Color)(c)); } 

static Color black() 
{ return Color((0.0F), (0.0F), (0.0F)); } 
static Color white() 
{ return Color((1.0F), (1.0F), (1.0F)); } 
static Color red() 
{ return Color((1.0F), (0.0F), (0.0F)); } 
static Color green() 
{ return Color((0.0F), (1.0F), (0.0F)); } 
static Color blue() 
{ return Color((0.0F), (0.0F), (1.0F)); } 
static Color yellow() 
{ return Color((1.0F), (1.0F), (0.0F)); } 
static Color cyan() 
{ return Color((0.0F), (1.0F), (1.0F)); } 
static Color magenta() 
{ return Color((1.0F), (0.0F), (1.0F)); } 
static Color hsv(float h, float s, float v) 
{ 

if (s <= (0.0F)) { 
return Color(v, v, v); }  
h = fmod(h, (float)(((2.0F)) * (3.1415926535897931))); 
if (h < (0.0)) { 
h += ((float)((2.0) * (3.1415926535897931))); }  
h /= ((float)((3.1415926535897931) / (3.0))); 
auto int i = ((int)floor(h)); 
auto float f = (h - i); 
auto float p = (v * ((1.0F) - s)); 
auto float q = (v * ((1.0F) - s * f)); 
auto float t = (v * ((1.0F) - s * ((1.0F) - f))); 
switch (i) { 
case 0: return Color(v, t, p); 
case 1: return Color(q, v, p); 
case 2: return Color(p, v, t); 
case 3: return Color(p, q, v); 
case 4: return Color(t, p, v); 
default: return Color(v, p, q); 
}  
} 
}; 
#line 11 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
#pragma warning(push,3)
#pragma warning(disable: 4244)
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
#pragma pack ( push, 8 )
#line 15 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
namespace std { 
template < class _Ty,
 class _Ax = allocator < _Ty > >
 class vector;


template < class _Ty,
 class _Alloc >
 class _Vector_const_iterator
  : public _Ranit < _Ty, typename _Alloc :: difference_type,
   typename _Alloc :: const_pointer, typename _Alloc :: const_reference >
 {
public :
 typedef _Vector_const_iterator < _Ty, _Alloc > _Myt;
 typedef vector < _Ty, _Alloc > _Myvec;
 typedef typename _Alloc :: pointer _Tptr;

 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef typename _Alloc :: difference_type difference_type;
 typedef typename _Alloc :: const_pointer pointer;
 typedef typename _Alloc :: const_reference reference;


 typedef _Range_checked_iterator_tag _Checked_iterator_category;



 typedef pointer _Checked_iterator_base_type;

 _Checked_iterator_base_type _Checked_iterator_base ( ) const
 {
  return _Myptr;
 }

 void _Checked_iterator_assign_from_base ( _Checked_iterator_base_type _Base )
 {
  this -> _Myptr = const_cast < _Tptr > ( _Base );
 }






 typedef _Tptr _Inner_type;

 _Vector_const_iterator ( )
  {
  _Myptr = 0;
  }










 _Vector_const_iterator ( _Tptr _Ptr, const _Container_base * _Pvector )
  {
  { if ( ! ( _Pvector != 0 && ( ( _Myvec * ) _Pvector ) -> _Myfirst <= _Ptr && _Ptr <= ( ( _Myvec * ) _Pvector ) -> _Mylast ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  this -> _Set_container ( _Pvector );
  _Myptr = _Ptr;
  }








 reference operator * ( ) const
  {










   { if ( ! ( this -> _Has_container ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  { if ( ! ( _Myptr < ( ( _Myvec * ) ( this -> _Getmycont ( ) ) ) -> _Mylast ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };


  return ( * _Myptr );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myt & operator ++ ( )
  {
  { if ( ! ( this -> _Has_container ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  { if ( ! ( _Myptr < ( ( _Myvec * ) ( this -> _Getmycont ( ) ) ) -> _Mylast ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };







  ++ _Myptr;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  { if ( ! ( this -> _Has_container ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  { if ( ! ( _Myptr > ( ( _Myvec * ) ( this -> _Getmycont ( ) ) ) -> _Myfirst ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };







  -- _Myptr;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myt & operator += ( difference_type _Off )
  {
  { if ( ! ( this -> _Has_container ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  { if ( ! ( _Myptr + _Off <= ( ( _Myvec * ) ( this -> _Getmycont ( ) ) ) -> _Mylast && _Myptr + _Off >= ( ( _Myvec * ) ( this -> _Getmycont ( ) ) ) -> _Myfirst ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };

  _Myptr += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myt & _Right ) const
  {




  { if ( ! ( this -> _Has_container ( ) && this -> _Same_container ( _Right ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };


  return ( _Myptr - _Right . _Myptr );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myt & _Right ) const
  {




  { if ( ! ( this -> _Has_container ( ) && this -> _Same_container ( _Right ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };


  return ( _Myptr == _Right . _Myptr );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myt & _Right ) const
  {




  { if ( ! ( this -> _Has_container ( ) && this -> _Same_container ( _Right ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };


  return ( _Myptr < _Right . _Myptr );
  }

 bool operator > ( const _Myt & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myt & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myt & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }












 static void _Xlen ( )
  {
  throw length_error ( "vector<T> too long" );
  }

 static void _Xran ( )
  {
  throw out_of_range ( "invalid vector<T> subscript" );
  }

 static void _Xinvarg ( )
  {
  throw invalid_argument ( "invalid vector<T> argument" );
  }

 _Tptr _Myptr;
 };
#line 275 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
template < class _Ty,
 class _Alloc > inline
 _Vector_const_iterator < _Ty, _Alloc > operator + (
  typename _Vector_const_iterator < _Ty, _Alloc > :: difference_type _Off,
  _Vector_const_iterator < _Ty, _Alloc > _Next )
 {
 return ( _Next += _Off );
 }


template < class _Ty,
 class _Alloc >
 class _Vector_iterator
  : public _Vector_const_iterator < _Ty, _Alloc >
 {
public :
 typedef _Vector_iterator < _Ty, _Alloc > _Myt;
 typedef _Vector_const_iterator < _Ty, _Alloc > _Mybase;

 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef typename _Alloc :: difference_type difference_type;
 typedef typename _Alloc :: pointer pointer;
 typedef typename _Alloc :: reference reference;


 typedef pointer _Checked_iterator_base_type;

 _Checked_iterator_base_type _Checked_iterator_base ( ) const
  {
  return ( this -> _Myptr );
  }

 void _Checked_iterator_assign_from_base ( _Checked_iterator_base_type _Base )
  {
  this -> _Myptr = _Base;
  }


 _Vector_iterator ( )
  {
  }








 _Vector_iterator ( pointer _Ptr, const _Container_base * _Pvector )
  : _Mybase ( _Ptr, _Pvector )
  {
  }








 reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

 pointer operator -> ( ) const
  {
  return ( & * * this );
  }

 _Myt & operator ++ ( )
  {
  ++ ( * ( _Mybase * ) this );
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  -- ( * ( _Mybase * ) this );
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myt & operator += ( difference_type _Off )
  {
  ( * ( _Mybase * ) this ) += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 407 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
template < class _Ty,
 class _Alloc > inline
 _Vector_iterator < _Ty, _Alloc > operator + (
  typename _Vector_iterator < _Ty, _Alloc > :: difference_type _Off,
  _Vector_iterator < _Ty, _Alloc > _Next )
 {
 return ( _Next += _Off );
 }


template < class _Ty,
 class _Alloc >
 class _Vector_val
  : public _Container_base_aux_alloc_real < _Alloc >
 {
protected :
 _Vector_val ( _Alloc _Al = _Alloc ( ) )
  : _Container_base_aux_alloc_real < _Alloc > ( _Al ), _Alval ( _Al )
  {
  }

 typedef typename _Alloc :: template
  rebind < _Ty > :: other _Alty;

 _Alty _Alval;
 };


template < class _Ty,
 class _Ax >
 class vector
  : public _Vector_val < _Ty, _Ax >
 {
public :
 typedef vector < _Ty, _Ax > _Myt;
 typedef _Vector_val < _Ty, _Ax > _Mybase;
 typedef typename _Mybase :: _Alty _Alloc;
 typedef _Alloc allocator_type;
 typedef typename _Alloc :: size_type size_type;
 typedef typename _Alloc :: difference_type _Dift;
 typedef _Dift difference_type;
 typedef typename _Alloc :: pointer _Tptr;
 typedef typename _Alloc :: const_pointer _Ctptr;
 typedef _Tptr pointer;
 typedef _Ctptr const_pointer;
 typedef typename _Alloc :: reference _Reft;
 typedef _Reft reference;
 typedef typename _Alloc :: const_reference const_reference;
 typedef typename _Alloc :: value_type value_type;



 typedef _Vector_iterator < _Ty, _Alloc > iterator;
 typedef _Vector_const_iterator < _Ty, _Alloc > const_iterator;


 friend class _Vector_const_iterator < _Ty, _Alloc >;

 typedef std :: reverse_iterator < iterator > reverse_iterator;
 typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;

 vector ( )
  : _Mybase ( )
  {
  _Buy ( 0 );
  }

 explicit vector ( const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Buy ( 0 );
  }

 explicit vector ( size_type _Count )
  : _Mybase ( )
  {
  _Construct_n ( _Count, _Ty ( ) );
  }

 vector ( size_type _Count, const _Ty & _Val )
  : _Mybase ( )
  {
  _Construct_n ( _Count, _Val );
  }

 vector ( size_type _Count, const _Ty & _Val, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Construct_n ( _Count, _Val );
  }

 vector ( const _Myt & _Right )
  : _Mybase ( _Right . _Alval )
  {
  if ( _Buy ( _Right . size ( ) ) )
   try {
   _Mylast = _Ucopy ( _Right . begin ( ), _Right . end ( ), _Myfirst );
   } catch ( ... ) {
   _Tidy ( );
   throw;
   }
  }

 template < class _Iter >
  vector ( _Iter _First, _Iter _Last )
  : _Mybase ( )
  {
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  vector ( _Iter _First, _Iter _Last, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Construct ( _Iter _Count, _Iter _Val, _Int_iterator_tag )
  {
  size_type _Size = ( size_type ) _Count;
  _Construct_n ( _Size, ( _Ty ) _Val );
  }

 template < class _Iter >
  void _Construct ( _Iter _First,
   _Iter _Last, input_iterator_tag )
  {
  _Buy ( 0 );
  try {
  insert ( begin ( ), _First, _Last );
  } catch ( ... ) {
  _Tidy ( );
  throw;
  }
  }

 void _Construct_n ( size_type _Count, const _Ty & _Val )
  {
  if ( _Buy ( _Count ) )
   {
   try {
   _Mylast = _Ufill ( _Myfirst, _Count, _Val );
   } catch ( ... ) {
   _Tidy ( );
   throw;
   }
   }
  }

 ~ vector ( )
  {
  _Tidy ( );
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  if ( this != & _Right )
   {





   if ( _Right . size ( ) == 0 )
    clear ( );
   else if ( _Right . size ( ) <= size ( ) )
    {
    pointer _Ptr = :: stdext :: unchecked_copy ( _Right . _Myfirst, _Right . _Mylast,
     _Myfirst );
    _Destroy ( _Ptr, _Mylast );
    _Mylast = _Myfirst + _Right . size ( );
    }
   else if ( _Right . size ( ) <= capacity ( ) )
    {
    pointer _Ptr = _Right . _Myfirst + size ( );
    :: stdext :: unchecked_copy ( _Right . _Myfirst, _Ptr, _Myfirst );
    _Mylast = _Ucopy ( _Ptr, _Right . _Mylast, _Mylast );
    }
   else
    {
    if ( _Myfirst != 0 )
     {
     _Destroy ( _Myfirst, _Mylast );
     this -> _Alval . deallocate ( _Myfirst, _Myend - _Myfirst );
     }
    if ( _Buy ( _Right . size ( ) ) )
     _Mylast = _Ucopy ( _Right . _Myfirst, _Right . _Mylast,
      _Myfirst );
    }
   }
  return ( * this );
  }

 void reserve ( size_type _Count )
  {
  if ( max_size ( ) < _Count )
   _Xlen ( );
  else if ( capacity ( ) < _Count )
   {
   pointer _Ptr = this -> _Alval . allocate ( _Count );

   try {
   _Umove ( begin ( ), end ( ), _Ptr );
   } catch ( ... ) {
   this -> _Alval . deallocate ( _Ptr, _Count );
   throw;
   }

   size_type _Size = size ( );
   if ( _Myfirst != 0 )
    {
    _Destroy ( _Myfirst, _Mylast );
    this -> _Alval . deallocate ( _Myfirst, _Myend - _Myfirst );
    }





   _Myend = _Ptr + _Count;
   _Mylast = _Ptr + _Size;
   _Myfirst = _Ptr;
   }
  }

 size_type capacity ( ) const
  {
  return ( _Myfirst == 0 ? 0 : _Myend - _Myfirst );
  }


 iterator begin ( )
  {
  return ( iterator ( _Myfirst, this ) );
  }

 const_iterator begin ( ) const
  {
  return ( const_iterator ( _Myfirst, this ) );
  }

 iterator end ( )
  {
  return ( iterator ( _Mylast, this ) );
  }

 const_iterator end ( ) const
  {
  return ( const_iterator ( _Mylast, this ) );
  }

 iterator _Make_iter ( const_iterator _Where ) const
  {
  return ( iterator ( _Where . _Myptr, this ) );
  }




























 reverse_iterator rbegin ( )
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( )
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }

 void resize ( size_type _Newsize )
  {
  resize ( _Newsize, _Ty ( ) );
  }

 void resize ( size_type _Newsize, _Ty _Val )
  {
  if ( size ( ) < _Newsize )
   _Insert_n ( end ( ), _Newsize - size ( ), _Val );
  else if ( _Newsize < size ( ) )
   erase ( begin ( ) + _Newsize, end ( ) );
  }

 size_type size ( ) const
  {
  return ( _Mylast - _Myfirst );
  }

 size_type max_size ( ) const
  {
  return ( this -> _Alval . max_size ( ) );
  }

 bool empty ( ) const
  {
  return ( size ( ) == 0 );
  }

 _Alloc get_allocator ( ) const
  {
  return ( this -> _Alval );
  }

 const_reference at ( size_type _Pos ) const
  {
  if ( size ( ) <= _Pos )
   _Xran ( );
  return ( * ( begin ( ) + _Pos ) );
  }

 reference at ( size_type _Pos )
  {
  if ( size ( ) <= _Pos )
   _Xran ( );
  return ( * ( begin ( ) + _Pos ) );
  }

 const_reference operator [ ] ( size_type _Pos ) const
  {








  { if ( ! ( _Pos < size ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };

  return ( * ( _Myfirst + _Pos ) );
  }

 reference operator [ ] ( size_type _Pos )
  {








  { if ( ! ( _Pos < size ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };

  return ( * ( _Myfirst + _Pos ) );
  }

 reference front ( )
  {
  return ( * begin ( ) );
  }

 const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

 reference back ( )
  {
  return ( * ( end ( ) - 1 ) );
  }

 const_reference back ( ) const
  {
  return ( * ( end ( ) - 1 ) );
  }

 void push_back ( const _Ty & _Val )
  {
  if ( size ( ) < capacity ( ) )








   _Mylast = _Ufill ( _Mylast, 1, _Val );


  else
   insert ( end ( ), _Val );
  }















 void pop_back ( )
  {
  if ( ! empty ( ) )
   {
   _Destroy ( _Mylast - 1, _Mylast );
   -- _Mylast;
   }
  }


 template < class _Iter >
  void assign ( _Iter _First, _Iter _Last )
  {
  _Assign ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Assign ( _Iter _Count, _Iter _Val, _Int_iterator_tag )
  {
  _Assign_n ( ( size_type ) _Count, ( _Ty ) _Val );
  }

 template < class _Iter >
  void _Assign ( _Iter _First, _Iter _Last, input_iterator_tag )
  {
  erase ( begin ( ), end ( ) );
  insert ( begin ( ), _First, _Last );
  }

 void assign ( size_type _Count, const _Ty & _Val )
  {
  _Assign_n ( _Count, _Val );
  }

 iterator insert ( const_iterator _Where, const _Ty & _Val )
  {
  size_type _Off = size ( ) == 0 ? 0 : _Where - begin ( );
  _Insert_n ( _Where, ( size_type ) 1, _Val );
  return ( begin ( ) + _Off );
  }

 void insert ( const_iterator _Where, size_type _Count, const _Ty & _Val )
  {
  _Insert_n ( _Where, _Count, _Val );
  }

 template < class _Iter >
  void insert ( const_iterator _Where, _Iter _First, _Iter _Last )
  {
  _Insert ( _Where, _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where, _Iter _First, _Iter _Last,
   _Int_iterator_tag )
  {
  _Insert_n ( _Where, ( size_type ) _First, ( _Ty ) _Last );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where, _Iter _First, _Iter _Last,
   input_iterator_tag )
  {







  if ( _First != _Last )
   {
   size_type _Oldsize = size ( );
   size_type _Whereoff = _Where . _Myptr - _Myfirst;

   for (; _First != _Last; ++ _First )
    _Insert_n ( end ( ), ( size_type ) 1, ( value_type ) * _First );

   _Reverse ( _Myfirst + _Whereoff, _Myfirst + _Oldsize );
   _Reverse ( _Myfirst + _Oldsize, _Mylast );
   _Reverse ( _Myfirst + _Whereoff, _Mylast );
   }
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where,
   _Iter _First, _Iter _Last, forward_iterator_tag )
  {








  size_type _Count = 0;
  _Distance ( _First, _Last, _Count );
  size_type _Capacity = capacity ( );

  if ( _Count == 0 )
   ;
  else if ( max_size ( ) - size ( ) < _Count )
   _Xlen ( );
  else if ( _Capacity < size ( ) + _Count )
   {
   _Capacity = max_size ( ) - _Capacity / 2 < _Capacity
    ? 0 : _Capacity + _Capacity / 2;
   if ( _Capacity < size ( ) + _Count )
    _Capacity = size ( ) + _Count;
   pointer _Newvec = this -> _Alval . allocate ( _Capacity );
   pointer _Ptr = _Newvec;

   try {
   _Ptr = _Umove ( _Myfirst, ( _Where ) . _Myptr,
    _Newvec );
   _Ptr = _Ucopy ( _First, _Last, _Ptr );
   _Umove ( ( _Where ) . _Myptr, _Mylast, _Ptr );
   } catch ( ... ) {
   _Destroy ( _Newvec, _Ptr );
   this -> _Alval . deallocate ( _Newvec, _Capacity );
   throw;
   }

   _Count += size ( );
   if ( _Myfirst != 0 )
    {
    _Destroy ( _Myfirst, _Mylast );
    this -> _Alval . deallocate ( _Myfirst, _Myend - _Myfirst );
    }





   _Myend = _Newvec + _Capacity;
   _Mylast = _Newvec + _Count;
   _Myfirst = _Newvec;
   }
  else
   {
   _Ucopy ( _First, _Last, _Mylast );

   _Reverse ( _Where . _Myptr, _Mylast );
   _Reverse ( _Mylast, _Mylast + _Count );
   _Reverse ( _Where . _Myptr, _Mylast + _Count );

   _Mylast += _Count;





   }
  }

  void _Reverse ( pointer _First, pointer _Last )
  {
  for (; _First != _Last && _First != -- _Last; ++ _First )
   :: std :: _Swap_adl ( * _First, * _Last );
  }















 iterator erase ( const_iterator _Where )
  {
  :: stdext :: unchecked_copy ( ( _Where ) . _Myptr + 1, _Mylast,
   ( _Where ) . _Myptr );
  _Destroy ( _Mylast - 1, _Mylast );
  -- _Mylast;
  return ( _Make_iter ( _Where ) );
  }


 iterator erase ( const_iterator _First_arg,
  const_iterator _Last_arg )
  {
  iterator _First = _Make_iter ( _First_arg );
  iterator _Last = _Make_iter ( _Last_arg );

  if ( _First != _Last )
   {










   pointer _Ptr = :: stdext :: unchecked_copy ( ( _Last ) . _Myptr, _Mylast,
    ( _First ) . _Myptr );


   _Destroy ( _Ptr, _Mylast );
   _Mylast = _Ptr;
   }



  return ( _First );

  }

 void clear ( )
  {
  erase ( begin ( ), end ( ) );
  }

 void swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( this -> _Alval == _Right . _Alval )
   {





   this -> _Swap_aux ( _Right );

   :: std :: swap ( _Myfirst, _Right . _Myfirst );
   :: std :: swap ( _Mylast, _Right . _Mylast );
   :: std :: swap ( _Myend, _Right . _Myend );
   }
  else
   {
   this -> _Swap_aux ( _Right );

   _Myt _Ts = * this;

   * this = _Right;
   _Right = _Ts;
   }
  }



protected :
 void _Assign_n ( size_type _Count, const _Ty & _Val )
  {
  _Ty _Tmp = _Val;
  erase ( begin ( ), end ( ) );
  insert ( begin ( ), _Count, _Tmp );
  }

 bool _Buy ( size_type _Capacity )
  {
  _Myfirst = 0, _Mylast = 0, _Myend = 0;
  if ( _Capacity == 0 )
   return ( false );
  else if ( max_size ( ) < _Capacity )
   _Xlen ( );
  else
   {
   _Myfirst = this -> _Alval . allocate ( _Capacity );
   _Mylast = _Myfirst;
   _Myend = _Myfirst + _Capacity;
   }
  return ( true );
  }

 void _Destroy ( pointer _First, pointer _Last )
  {
  _Destroy_range ( _First, _Last, this -> _Alval );
  }

 void _Tidy ( )
  {
  if ( _Myfirst != 0 )
   {





   _Destroy ( _Myfirst, _Mylast );
   this -> _Alval . deallocate ( _Myfirst, _Myend - _Myfirst );
   }
  _Myfirst = 0, _Mylast = 0, _Myend = 0;
  }

 template < class _Iter >
  pointer _Ucopy ( _Iter _First, _Iter _Last, pointer _Ptr )
  {
  return ( :: stdext :: unchecked_uninitialized_copy ( _First, _Last,
   _Ptr, this -> _Alval ) );
  }

 template < class _Iter >
  pointer _Umove ( _Iter _First, _Iter _Last, pointer _Ptr )
  {
  return ( :: stdext :: _Unchecked_uninitialized_move ( _First, _Last,
   _Ptr, this -> _Alval ) );
  }

 void _Insert_n ( const_iterator _Where,
  size_type _Count, const _Ty & _Val )
  {







  size_type _Capacity = capacity ( );

  if ( _Count == 0 )
   ;
  else if ( max_size ( ) - size ( ) < _Count )
   _Xlen ( );
  else if ( _Capacity < size ( ) + _Count )
   {
   _Capacity = max_size ( ) - _Capacity / 2 < _Capacity
    ? 0 : _Capacity + _Capacity / 2;
   if ( _Capacity < size ( ) + _Count )
    _Capacity = size ( ) + _Count;
   pointer _Newvec = this -> _Alval . allocate ( _Capacity );
   size_type _Whereoff = ( _Where ) . _Myptr - _Myfirst;
   int _Ncopied = 0;

   try {
   _Ufill ( _Newvec + _Whereoff, _Count, _Val );
   ++ _Ncopied;
   _Umove ( this -> _Myfirst, ( _Where ) . _Myptr,
    _Newvec );
   ++ _Ncopied;
   _Umove ( ( _Where ) . _Myptr, this -> _Mylast,
    _Newvec + ( _Whereoff + _Count ) );
   } catch ( ... ) {
   if ( 1 < _Ncopied )
    _Destroy ( _Newvec, _Newvec + _Whereoff );
   if ( 0 < _Ncopied )
    _Destroy ( _Newvec + _Whereoff, _Newvec + _Whereoff + _Count );
   this -> _Alval . deallocate ( _Newvec, _Capacity );
   throw;
   }

   _Count += size ( );
   if ( _Myfirst != 0 )
    {
    _Destroy ( _Myfirst, _Mylast );
    this -> _Alval . deallocate ( _Myfirst, _Myend - _Myfirst );
    }





   _Myend = _Newvec + _Capacity;
   _Mylast = _Newvec + _Count;
   _Myfirst = _Newvec;
   }
  else if ( ( size_type ) ( _Mylast - ( _Where ) . _Myptr ) < _Count )
   {
   _Ty _Tmp = _Val;

   _Umove ( ( _Where ) . _Myptr, _Mylast,
    ( _Where ) . _Myptr + _Count );

   try {
   _Ufill ( _Mylast, _Count - ( _Mylast - ( _Where ) . _Myptr ),
    _Tmp );
   } catch ( ... ) {
   _Destroy ( ( _Where ) . _Myptr + _Count, _Mylast + _Count );
   throw;
   }

   _Mylast += _Count;





   std :: fill ( ( _Where ) . _Myptr, _Mylast - _Count,
    _Tmp );
   }
  else
   {
   _Ty _Tmp = _Val;

   pointer _Oldend = _Mylast;
   _Mylast = _Umove ( _Oldend - _Count, _Oldend,
    _Mylast );





   :: stdext :: _Unchecked_move_backward ( ( _Where ) . _Myptr, _Oldend - _Count,
    _Oldend );
   std :: fill ( ( _Where ) . _Myptr, ( _Where ) . _Myptr + _Count,
    _Tmp );
   }
  }

 pointer _Ufill ( pointer _Ptr, size_type _Count, const _Ty & _Val )
  {
  :: stdext :: unchecked_uninitialized_fill_n ( _Ptr, _Count, _Val, this -> _Alval );
  return ( _Ptr + _Count );
  }

 static void _Xlen ( )
  {
  throw length_error ( "vector<T> too long" );
  }

 static void _Xran ( )
  {
  throw out_of_range ( "invalid vector<T> subscript" );
  }

 static void _Xinvarg ( )
  {
  throw invalid_argument ( "invalid vector<T> argument" );
  }

















 pointer _Myfirst;
 pointer _Mylast;
 pointer _Myend;
 };
#line 1295 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
template<class _Ty, class _Ax> 
#pragma pack(8)
#line 1296 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
class _Move_operation_category< vector< _Ty, _Ax> >  { 


public: typedef _Swap_move_tag _Move_cat; 
}; 
#pragma pack()

template < class _Ty,
 class _Alloc > inline
 bool operator == ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( _Left . size ( ) == _Right . size ( )
  && equal ( _Left . begin ( ), _Left . end ( ), _Right . begin ( ) ) );
 }

template < class _Ty,
 class _Alloc > inline
 bool operator != ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }

template < class _Ty,
 class _Alloc > inline
 bool operator < ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( lexicographical_compare ( _Left . begin ( ), _Left . end ( ),
  _Right . begin ( ), _Right . end ( ) ) );
 }

template < class _Ty,
 class _Alloc > inline
 bool operator > ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( _Right < _Left );
 }

template < class _Ty,
 class _Alloc > inline
 bool operator <= ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }

template < class _Ty,
 class _Alloc > inline
 bool operator >= ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }

template < class _Ty,
 class _Alloc > inline
 void swap ( vector < _Ty, _Alloc > & _Left, vector < _Ty, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }




typedef unsigned _Vbase; 
static const int _VBITS = ((8) * sizeof(_Vbase)); 


template < class _Sizet,
 class _Difft,
 class _MycontTy >
 class _Vb_iter_base
  : public _Ranit < _Bool, _Difft, bool *, bool >
 {
public :

 typedef _Range_checked_iterator_tag _Checked_iterator_category;


 _Vb_iter_base ( )
  : _Myptr ( 0 ), _Myoff ( 0 )
  {
  }











 _Vb_iter_base ( _Vbase * _Ptr, _Sizet _Off,
  const _Container_base * _Mypvbool )
  : _Myptr ( _Ptr ), _Myoff ( _Off )
  {
  { if ( ! ( _Mypvbool != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  this -> _Set_container ( _Mypvbool );
  }







 _Vbase * _Myptr;
 _Sizet _Myoff;

 static void _Xlen ( )
  {
  throw length_error ( "vector<bool> too long" );
   }

 static void _Xran ( )
  {
  throw out_of_range ( "invalid vector<bool> subscript" );
  }

 static void _Xinvarg ( )
  {
  throw invalid_argument ( "invalid vector<bool> argument" );
  }


 _Vbase * _My_cont_begin ( ) const
  {
  return ( ( ( ( _MycontTy * ) this -> _Getmycont ( ) ) -> _Myvec . begin ( ) ) . _Myptr );

  }

 _Sizet _My_actual_offset ( ) const
  {
  _Sizet _Off = this -> _Myoff;
  _Off += _VBITS * ( this -> _Myptr - _My_cont_begin ( ) );
  return ( _Off );
  }

 };
#line 1442 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
template < class _Sizet,
 class _Difft,
 class _MycontTy >
 class _Vb_reference
  : public _Vb_iter_base < _Sizet, _Difft, _MycontTy >
 {
public :
 typedef _Vb_iter_base < _Sizet, _Difft, _MycontTy > _Mybase;
 typedef _Vb_reference < _Sizet, _Difft, _MycontTy > _Mytype;

 _Vb_reference ( )
  {
  }


 _Vb_reference ( const _Mybase & _Right )
  : _Mybase ( _Right . _Myptr, _Right . _Myoff, _Right . _Getmycont ( ) )
  {
  }








 _Mytype & operator = ( const _Mytype & _Right )
  {
  return ( * this = bool ( _Right ) );
  }

 _Mytype & operator = ( bool _Val )
  {
  if ( _Val )
   * _Getptr ( ) |= _Mask ( );
  else
   * _Getptr ( ) &= ~ _Mask ( );
  return ( * this );
  }

 void flip ( )
  {
  * _Getptr ( ) ^= _Mask ( );
  }

 bool operator ~ ( ) const
  {
  return ( ! bool ( * this ) );
  }

 operator bool ( ) const
  {
  return ( ( * _Getptr ( ) & _Mask ( ) ) != 0 );
  }

 _Vbase * _Getptr ( ) const
  {








   { if ( ! ( this -> _Has_container ( ) && this -> _Myptr != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  { if ( ! ( this -> _My_actual_offset ( ) < ( ( _MycontTy * ) this -> _Getmycont ( ) ) -> _Mysize ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };


  return ( this -> _Myptr );
  }

protected :
 _Vbase _Mask ( ) const
  {
  return ( ( _Vbase ) ( 1 << this -> _Myoff ) );
  }
 };
#line 1522 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
template < class _Sizet,
 class _Difft,
 class _MycontTy >
 void swap ( _Vb_reference < _Sizet, _Difft, _MycontTy > _Left,
  _Vb_reference < _Sizet, _Difft, _MycontTy > _Right )
 {
 bool _Val = _Left;
 _Left = _Right;
 _Right = _Val;
 }


template < class _Sizet,
 class _Difft,
 class _MycontTy >
 class _Vb_const_iterator
  : public _Vb_iter_base < _Sizet, _Difft, _MycontTy >
 {
public :
 typedef _Vb_iter_base < _Sizet, _Difft, _MycontTy > _Mybase;
 typedef _Vb_const_iterator < _Sizet, _Difft, _MycontTy > _Mytype;

 typedef _Vb_reference < _Sizet, _Difft, _MycontTy > _Reft;
 typedef bool const_reference;

 typedef random_access_iterator_tag iterator_category;
 typedef _Bool value_type;
 typedef _Sizet size_type;
 typedef _Difft difference_type;
 typedef const_reference * pointer;
 typedef const_reference reference;

 _Vb_const_iterator ( )
  {
  }


 _Vb_const_iterator ( const _Vbase * _Ptr, const _Container_base * _Mypvbool )
  : _Mybase ( ( _Vbase * ) _Ptr, 0, ( _Container_base * ) _Mypvbool )






  {
  }

 const_reference operator * ( ) const
  {
  return ( _Reft ( * this ) );
  }

 _Mytype & operator ++ ( )
  {
  _Inc ( );
  return ( * this );
  }

 _Mytype operator ++ ( int )
  {
  _Mytype _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Mytype & operator -- ( )
  {
  _Dec ( );
  return ( * this );
  }

 _Mytype operator -- ( int )
  {
  _Mytype _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Mytype & operator += ( difference_type _Off )
  {
  if ( _Off == 0 )
   return ( * this );
  { if ( ! ( this -> _Has_container ( ) && this -> _Myptr != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  if ( _Off < 0 )
   {
   { if ( ! ( this -> _My_actual_offset ( ) >= ( ( size_type ) - _Off ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
   }
  else
   {
   { if ( ! ( ( this -> _My_actual_offset ( ) + _Off ) <= ( ( _MycontTy * ) this -> _Getmycont ( ) ) -> _Mysize ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
   }
  if ( _Off < 0 && this -> _Myoff < 0 - ( size_type ) _Off )
   {
   this -> _Myoff += _Off;
   this -> _Myptr -= 1 + ( ( size_type ) ( - 1 ) - this -> _Myoff ) / _VBITS;
   this -> _Myoff %= _VBITS;
   }
  else
   {
   this -> _Myoff += _Off;
   this -> _Myptr += this -> _Myoff / _VBITS;
   this -> _Myoff %= _VBITS;
   }
  return ( * this );
  }

 _Mytype operator + ( difference_type _Off ) const
  {
  _Mytype _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Mytype & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Mytype operator - ( difference_type _Off ) const
  {
  _Mytype _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - (
  const _Mytype & _Right ) const
  {





  return ( _VBITS * ( this -> _Myptr - _Right . _Myptr )
   + ( difference_type ) this -> _Myoff
   - ( difference_type ) _Right . _Myoff );
  }

 const_reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Mytype & _Right ) const
  {





  return ( this -> _Myptr == _Right . _Myptr
   && this -> _Myoff == _Right . _Myoff );
  }

 bool operator != ( const _Mytype & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Mytype & _Right ) const
  {





  return ( this -> _Myptr < _Right . _Myptr
   || this -> _Myptr == _Right . _Myptr
    && this -> _Myoff < _Right . _Myoff );
  }

 bool operator > ( const _Mytype & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Mytype & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Mytype & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }

protected :









 void _Dec ( )
  {
  if ( this -> _Myoff != 0 )
   {
   -- this -> _Myoff;
   }
  else
   {
   { if ( ! ( this -> _Has_container ( ) && this -> _Myptr != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
   { if ( ! ( this -> _Myptr > this -> _My_cont_begin ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
   -- this -> _Myptr;
   this -> _Myoff = _VBITS - 1;
   }
  }

 void _Inc ( )
  {
  { if ( ! ( this -> _Has_container ( ) && this -> _Myptr != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  { if ( ! ( ( this -> _My_actual_offset ( ) + 1 ) <= ( ( _MycontTy * ) this -> _Getmycont ( ) ) -> _Mysize ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  if ( this -> _Myoff < _VBITS - 1 )
   ++ this -> _Myoff;
  else
   this -> _Myoff = 0, ++ this -> _Myptr;
  }
 };
#line 1743 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
template < class _Sizet,
 class _Difft,
 class _MycontTy >
 _Vb_const_iterator < _Sizet, _Difft, _MycontTy > operator + ( _Difft _Off,
  _Vb_const_iterator < _Sizet, _Difft, _MycontTy > _Right )
  {
  return ( _Right += _Off );
  }


template < class _Sizet,
 class _Difft,
 class _MycontTy >
 class _Vb_iterator
  : public _Vb_const_iterator < _Sizet, _Difft, _MycontTy >
 {
public :
 typedef _Vb_const_iterator < _Sizet, _Difft, _MycontTy > _Mybase;
 typedef _Vb_iterator < _Sizet, _Difft, _MycontTy > _Mytype;

 typedef _Vb_reference < _Sizet, _Difft, _MycontTy > _Reft;
 typedef bool const_reference;

 typedef random_access_iterator_tag iterator_category;
 typedef _Bool value_type;
 typedef _Sizet size_type;
 typedef _Difft difference_type;
 typedef _Reft * pointer;
 typedef _Reft reference;

 _Vb_iterator ( )
  {
  }


 _Vb_iterator ( _Vbase * _Ptr, _Container_base * _Mypvbool )
  : _Mybase ( _Ptr, _Mypvbool )






  {
  }

 reference operator * ( ) const
  {
  return ( _Reft ( * this ) );
  }

 _Mytype & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Mytype operator ++ ( int )
  {
  _Mytype _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Mytype & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Mytype operator -- ( int )
  {
  _Mytype _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Mytype & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

 _Mytype operator + ( difference_type _Off ) const
  {
  _Mytype _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Mytype & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Mytype operator - ( difference_type _Off ) const
  {
  _Mytype _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 1854 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
template < class _Sizet,
 class _Difft,
 class _MycontTy >
 _Vb_iterator < _Sizet, _Difft, _MycontTy > operator + ( _Difft _Off,
  _Vb_iterator < _Sizet, _Difft, _MycontTy > _Right )
  {
  return ( _Right += _Off );
  }


template < class _Alloc >
 class vector < _Bool, _Alloc >
  : public _Container_base_aux_alloc_real < _Alloc >
 {
public :
 typedef typename _Alloc :: size_type size_type;
 typedef typename _Alloc :: difference_type _Dift;
 typedef std :: vector < _Vbase,
  typename _Alloc :: template rebind < _Vbase > :: other >
   _Vbtype;
 typedef std :: vector < _Bool, _Alloc > _Myt;


 typedef _Dift difference_type;
 typedef _Bool _Ty;
 typedef _Alloc allocator_type;

 typedef _Vb_reference < size_type, _Dift, _Myt > reference;
 typedef bool const_reference;
 typedef bool value_type;

 typedef reference _Reft;
 typedef _Vb_const_iterator < size_type, difference_type, _Myt > const_iterator;
 typedef _Vb_iterator < size_type, difference_type, _Myt > iterator;

 friend class _Vb_iter_base < size_type, difference_type, _Myt >;
 friend class _Vb_reference < size_type, difference_type, _Myt >;
 friend class _Vb_const_iterator < size_type, difference_type, _Myt >;
 friend class _Vb_iterator < size_type, difference_type, _Myt >;

 typedef iterator pointer;
 typedef const_iterator const_pointer;
 typedef std :: reverse_iterator < iterator > reverse_iterator;
 typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;

 static const int _VBITS = std :: _VBITS;

 vector ( )
  : _Container_base_aux_alloc_real < _Alloc > ( _Alloc ( ) ), _Mysize ( 0 ), _Myvec ( )
  {
  }

 vector ( const _Myt & _Right )
  : _Container_base_aux_alloc_real < _Alloc > ( _Right . get_allocator ( ) ), _Mysize ( _Right . _Mysize ), _Myvec ( _Right . _Myvec )
  {
  }

 explicit vector ( const _Alloc & _Al )
  : _Container_base_aux_alloc_real < _Alloc > ( _Al ), _Mysize ( 0 ), _Myvec ( _Al )
  {
  }

 explicit vector ( size_type _Count, bool _Val = false )
  : _Container_base_aux_alloc_real < _Alloc > ( _Alloc ( ) ), _Mysize ( 0 ), _Myvec ( _Nw ( _Count ), ( _Vbase ) ( _Val ? - 1 : 0 ) )
  {
  _Trim ( _Count );
  }

 vector ( size_type _Count, bool _Val, const _Alloc & _Al )
  : _Container_base_aux_alloc_real < _Alloc > ( _Al ), _Mysize ( 0 ), _Myvec ( _Nw ( _Count ), ( _Vbase ) ( _Val ? - 1 : 0 ), _Al )
  {
  _Trim ( _Count );
  }

 template < class _Iter >
  vector ( _Iter _First, _Iter _Last )
  : _Container_base_aux_alloc_real < _Alloc > ( _Alloc ( ) ), _Mysize ( 0 ), _Myvec ( )
  {
  _BConstruct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  vector ( _Iter _First, _Iter _Last, const _Alloc & _Al )
  : _Container_base_aux_alloc_real < _Alloc > ( _Al ), _Mysize ( 0 ), _Myvec ( _Al )
  {
  _BConstruct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _BConstruct ( _Iter _Count, _Iter _Val, _Int_iterator_tag )
  {
  size_type _Num = ( size_type ) _Count;
  _Myvec . assign ( _Num, ( _Ty ) _Val ? - 1 : 0 );
  _Trim ( _Num );
  }

 template < class _Iter >
  void _BConstruct ( _Iter _First, _Iter _Last, input_iterator_tag )
  {
  insert ( begin ( ), _First, _Last );
  }

 ~ vector ( )
  {
  _Mysize = 0;
  }

 void reserve ( size_type _Count )
  {
  _Myvec . reserve ( _Nw ( _Count ) );
  }

 size_type capacity ( ) const
  {
  return ( _Myvec . capacity ( ) * _VBITS );
  }


 iterator begin ( )
  {
  return ( iterator ( ( _Myvec . begin ( ) ) . _Myptr, this ) );
  }

 const_iterator begin ( ) const
  {
  return ( const_iterator ( ( _Myvec . begin ( ) ) . _Myptr, this ) );
  }













 iterator end ( )
  {
  iterator _Tmp = begin ( );
  if ( 0 < _Mysize )
   _Tmp += _Mysize;
  return ( _Tmp );
  }

 const_iterator end ( ) const
  {
  const_iterator _Tmp = begin ( );
  if ( 0 < _Mysize )
   _Tmp += _Mysize;
  return ( _Tmp );
  }

 iterator _Make_iter ( const_iterator _Where )
  {
  iterator _Tmp = begin ( );
  if ( 0 < _Mysize )
   _Tmp += _Where - begin ( );
  return ( _Tmp );
  }

 reverse_iterator rbegin ( )
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( )
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }

 void resize ( size_type _Newsize, bool _Val = false )
  {
  if ( size ( ) < _Newsize )
   _Insert_n ( end ( ), _Newsize - size ( ), _Val );
  else if ( _Newsize < size ( ) )
   erase ( begin ( ) + _Newsize, end ( ) );
  }

 size_type size ( ) const
  {
  return ( _Mysize );
  }

 size_type max_size ( ) const
  {
  const size_type _Maxsize = _Myvec . max_size ( );
  return ( _Maxsize < ( size_type ) ( - 1 ) / _VBITS
   ? _Maxsize * _VBITS : ( size_type ) ( - 1 ) );
  }

 bool empty ( ) const
  {
  return ( size ( ) == 0 );
  }

 _Alloc get_allocator ( ) const
  {

  _Alloc _Alret = _Myvec . get_allocator ( );
  return ( _Alret );
  }

 const_reference at ( size_type _Off ) const
  {
  if ( size ( ) <= _Off )
   _Xran ( );
  return ( * ( begin ( ) + _Off ) );
  }

 reference at ( size_type _Off )
  {
  if ( size ( ) <= _Off )
   _Xran ( );
  return ( * ( begin ( ) + _Off ) );
  }

 const_reference operator [ ] ( size_type _Off ) const
  {
  return ( * ( begin ( ) + _Off ) );
  }

 reference operator [ ] ( size_type _Off )
  {
  return ( * ( begin ( ) + _Off ) );
  }

 reference front ( )
  {
  return ( * begin ( ) );
  }

 const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

 reference back ( )
  {
  return ( * ( end ( ) - 1 ) );
  }

 const_reference back ( ) const
  {
  return ( * ( end ( ) - 1 ) );
  }

 void push_back ( bool _Val )
  {
  insert ( end ( ), _Val );
  }

 void pop_back ( )
  {
  if ( ! empty ( ) )
   erase ( end ( ) - 1 );
  }

 template < class _Iter >
  void assign ( _Iter _First, _Iter _Last )
  {
  _Assign ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Assign ( _Iter _Count, _Iter _Val, _Int_iterator_tag )
  {
  _Assign_n ( ( size_type ) _Count, ( bool ) _Val );
  }

 template < class _Iter >
  void _Assign ( _Iter _First, _Iter _Last, input_iterator_tag )
  {
  erase ( begin ( ), end ( ) );
  insert ( begin ( ), _First, _Last );
  }

 void assign ( size_type _Count, bool _Val )
  {
  _Assign_n ( _Count, _Val );
  }

 iterator insert ( const_iterator _Where, bool _Val )
  {
  size_type _Off = _Where - begin ( );
  _Insert_n ( _Where, ( size_type ) 1, _Val );
  return ( begin ( ) + _Off );
  }

 void insert ( const_iterator _Where, size_type _Count, bool _Val )
  {
  _Insert_n ( _Where, _Count, _Val );
  }

 template < class _Iter >
  void insert ( const_iterator _Where, _Iter _First, _Iter _Last )
  {
  _Insert ( _Where, _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where, _Iter _Count, _Iter _Val,
   _Int_iterator_tag )
  {
  _Insert_n ( _Where, ( size_type ) _Count, ( bool ) _Val );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where, _Iter _First, _Iter _Last,
   input_iterator_tag )
  {
  size_type _Off = _Where - begin ( );

  for (; _First != _Last; ++ _First, ++ _Off )
   insert ( begin ( ) + _Off, * _First );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where,
   _Iter _First, _Iter _Last,
   forward_iterator_tag )
  {





  size_type _Count = 0;
  _Distance ( _First, _Last, _Count );

  size_type _Off = _Insert_x ( _Where, _Count );
  std :: copy ( _First, _Last, begin ( ) + _Off );
  }

 iterator erase ( const_iterator _Where_arg )
  {
  iterator _Where = _Make_iter ( _Where_arg );
  size_type _Off = _Where - begin ( );








  std :: copy ( _Where + 1, end ( ), _Where );


  _Trim ( _Mysize - 1 );
  return ( begin ( ) + _Off );
  }

 iterator erase ( const_iterator _First_arg, const_iterator _Last_arg )
  {
  iterator _First = _Make_iter ( _First_arg );
  iterator _Last = _Make_iter ( _Last_arg );
  size_type _Off = _First - begin ( );










  iterator _Next = std :: copy ( _Last, end ( ), _First );
  _Trim ( _Next - begin ( ) );


  return ( begin ( ) + _Off );
  }

 void clear ( )
  {
  erase ( begin ( ), end ( ) );
  }

 void flip ( )
  {
  for ( _Vbtype :: iterator _Next = _Myvec . begin ( );
   _Next != _Myvec . end ( ); ++ _Next )
   * _Next = ( _Vbase ) ~ * _Next;
  _Trim ( _Mysize );
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {





   this -> _Swap_aux ( _Right );
   :: std :: swap ( _Mysize, _Right . _Mysize );
   _Myvec . swap ( _Right . _Myvec );
   }
  }



 static void swap ( reference _Left, reference _Right )
  {
  bool _Val = _Left;

  _Left = _Right;
  _Right = _Val;
  }


protected :
 void _Assign_n ( size_type _Count, bool _Val )
  {
  erase ( begin ( ), end ( ) );
  _Insert_n ( begin ( ), _Count, _Val );
  }

 void _Insert_n ( const_iterator _Where,
  size_type _Count, bool _Val )
  {
  size_type _Off = _Insert_x ( _Where, _Count );
  std :: fill ( begin ( ) + _Off, begin ( ) + ( _Off + _Count ), _Val );
  }

 size_type _Insert_x ( const_iterator _Where, size_type _Count )
  {
  size_type _Off = _Where - begin ( );







  if ( _Count == 0 )
   ;
  else if ( max_size ( ) - size ( ) < _Count )
   _Xlen ( );
  else
   {
   _Myvec . resize ( _Nw ( size ( ) + _Count ), 0 );
   if ( size ( ) == 0 )
    _Mysize += _Count;
   else
    {
    iterator _Oldend = end ( );
    _Mysize += _Count;
    std :: copy_backward ( begin ( ) + _Off, _Oldend, end ( ) );
    }





   }
  return ( _Off );
  }

 static size_type _Nw ( size_type _Count )
  {
  return ( ( _Count + _VBITS - 1 ) / _VBITS );
  }


























 void _Trim ( size_type _Size )
  {
  if ( max_size ( ) < _Size )
   _Xlen ( );
  size_type _Words = _Nw ( _Size );

  if ( _Words < _Myvec . size ( ) )
   _Myvec . erase ( _Myvec . begin ( ) + _Words, _Myvec . end ( ) );
  _Mysize = _Size;
  _Size %= _VBITS;
  if ( 0 < _Size )
   _Myvec [ _Words - 1 ] &= ( _Vbase ) ( ( 1 << _Size ) - 1 );
  }

 void _Xlen ( ) const
  {
  throw length_error ( "vector<bool> too long" );
  }

 void _Xran ( ) const
  {
  throw out_of_range ( "invalid vector<bool> subscript" );
  }

 size_type _Mysize;
 _Vbtype _Myvec;
 };
#line 2387 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
typedef vector< bool, allocator< bool> >  _Bvector; 
#line 2394 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
}


#pragma warning(default: 4244)
#pragma warning(pop)
#line 11 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
#pragma warning(push,3)
#pragma warning(disable: 4100 4180 4244)
#line 2399 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\vector"
#pragma pack ( pop )
#line 10 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
#pragma pack ( push, 8 )
#line 15 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
namespace std { 


template<class _Arg, class 
_Result> 
struct unary_function { 

typedef _Arg argument_type; 
typedef _Result result_type; 
}; 


template<class _Arg1, class 
_Arg2, class 
_Result> 
struct binary_function { 

typedef _Arg1 first_argument_type; 
typedef _Arg2 second_argument_type; 
typedef _Result result_type; 
}; 


template < class _Ty >
 struct plus
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left + _Right );
  }
 };


template < class _Ty >
 struct minus
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left - _Right );
  }
 };


template < class _Ty >
 struct multiplies
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left * _Right );
  }
 };


template < class _Ty >
 struct divides
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left / _Right );
  }
 };


template < class _Ty >
 struct modulus
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left % _Right );
  }
 };


template < class _Ty >
 struct negate
  : public unary_function < _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left ) const
  {
  return ( - _Left );
  }
 };


template < class _Ty >
 struct equal_to
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left == _Right );
  }
 };


template < class _Ty >
 struct not_equal_to
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left != _Right );
  }
 };


template < class _Ty >
 struct greater
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left > _Right );
  }
 };


template < class _Ty >
 struct less
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left < _Right );
  }
 };


template < class _Ty >
 struct greater_equal
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left >= _Right );
  }
 };


template < class _Ty >
 struct less_equal
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left <= _Right );
  }
 };


template < class _Ty >
 struct logical_and
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left && _Right );
  }
 };


template < class _Ty >
 struct logical_or
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left || _Right );
  }
 };


template < class _Ty >
 struct logical_not
  : public unary_function < _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left ) const
  {
  return ( ! _Left );
  }
 };


template < class _Fn1 >
 class unary_negate
 : public unary_function < typename _Fn1 :: argument_type, bool >
 {
public :
 explicit unary_negate ( const _Fn1 & _Func )
  : _Functor ( _Func )
  {
  }

 bool operator ( ) ( const typename _Fn1 :: argument_type & _Left ) const
  {
  return ( ! _Functor ( _Left ) );
  }

protected :
 _Fn1 _Functor;
 };


template < class _Fn1 > inline
 unary_negate < _Fn1 > not1 ( const _Fn1 & _Func )
 {
 return ( std :: unary_negate < _Fn1 > ( _Func ) );
 }


template < class _Fn2 >
 class binary_negate
  : public binary_function < typename _Fn2 :: first_argument_type,
   typename _Fn2 :: second_argument_type, bool >
 {
public :
 explicit binary_negate ( const _Fn2 & _Func )
  : _Functor ( _Func )
  {
  }

 bool operator ( ) ( const typename _Fn2 :: first_argument_type & _Left,
  const typename _Fn2 :: second_argument_type & _Right ) const
  {
  return ( ! _Functor ( _Left, _Right ) );
  }

protected :
 _Fn2 _Functor;
 };


template < class _Fn2 > inline
 binary_negate < _Fn2 > not2 ( const _Fn2 & _Func )
 {
 return ( std :: binary_negate < _Fn2 > ( _Func ) );
 }


template < class _Fn2 >
 class binder1st
  : public unary_function < typename _Fn2 :: second_argument_type,
   typename _Fn2 :: result_type >
 {
public :
 typedef unary_function < typename _Fn2 :: second_argument_type,
  typename _Fn2 :: result_type > _Base;
 typedef typename _Base :: argument_type argument_type;
 typedef typename _Base :: result_type result_type;

 binder1st ( const _Fn2 & _Func,
  const typename _Fn2 :: first_argument_type & _Left )
  : op ( _Func ), value ( _Left )
  {
  }

 result_type operator ( ) ( const argument_type & _Right ) const
  {
  return ( op ( value, _Right ) );
  }

 result_type operator ( ) ( argument_type & _Right ) const
  {
  return ( op ( value, _Right ) );
  }

protected :
 _Fn2 op;
 typename _Fn2 :: first_argument_type value;
 };


template < class _Fn2,
 class _Ty > inline
 binder1st < _Fn2 > bind1st ( const _Fn2 & _Func, const _Ty & _Left )
  {
  typename _Fn2 :: first_argument_type _Val ( _Left );
  return ( std :: binder1st < _Fn2 > ( _Func, _Val ) );
  }


template < class _Fn2 >
 class binder2nd
  : public unary_function < typename _Fn2 :: first_argument_type,
   typename _Fn2 :: result_type >
 {
public :
 typedef unary_function < typename _Fn2 :: first_argument_type,
  typename _Fn2 :: result_type > _Base;
 typedef typename _Base :: argument_type argument_type;
 typedef typename _Base :: result_type result_type;

 binder2nd ( const _Fn2 & _Func,
  const typename _Fn2 :: second_argument_type & _Right )
  : op ( _Func ), value ( _Right )
  {
  }

 result_type operator ( ) ( const argument_type & _Left ) const
  {
  return ( op ( _Left, value ) );
  }

 result_type operator ( ) ( argument_type & _Left ) const
  {
  return ( op ( _Left, value ) );
  }

protected :
 _Fn2 op;
 typename _Fn2 :: second_argument_type value;
 };


template < class _Fn2,
 class _Ty > inline
 binder2nd < _Fn2 > bind2nd ( const _Fn2 & _Func, const _Ty & _Right )
 {
 typename _Fn2 :: second_argument_type _Val ( _Right );
 return ( std :: binder2nd < _Fn2 > ( _Func, _Val ) );
 }


template < class _Arg,
 class _Result,
 class _Fn = _Result ( * ) ( _Arg ) >
 class pointer_to_unary_function
  : public unary_function < _Arg, _Result >
 {
public :
 explicit pointer_to_unary_function ( _Fn _Left )
  : _Pfun ( _Left )
  {
  }

 _Result operator ( ) ( _Arg _Left ) const
  {
  return ( _Pfun ( _Left ) );
  }

protected :
 _Fn _Pfun;
 };


template < class _Arg1,
 class _Arg2,
 class _Result,
 class _Fn = _Result ( * ) ( _Arg1, _Arg2 ) >
 class pointer_to_binary_function
  : public binary_function < _Arg1, _Arg2, _Result >
 {
public :
 explicit pointer_to_binary_function ( _Fn _Left )
  : _Pfun ( _Left )
  {
  }

 _Result operator ( ) ( _Arg1 _Left, _Arg2 _Right ) const
  {
  return ( _Pfun ( _Left, _Right ) );
  }

protected :
 _Fn _Pfun;
 };


template < class _Arg,
 class _Result > inline
 pointer_to_unary_function < _Arg, _Result,
  _Result ( __cdecl * ) ( _Arg ) >
   ptr_fun ( _Result ( __cdecl * _Left ) ( _Arg ) )
 {
 return ( std :: pointer_to_unary_function < _Arg, _Result,
  _Result ( __cdecl * ) ( _Arg ) > ( _Left ) );
 }


template < class _Arg,
 class _Result > inline
 pointer_to_unary_function < _Arg, _Result,
  _Result ( __stdcall * ) ( _Arg ) >
   ptr_fun ( _Result ( __stdcall * _Left ) ( _Arg ) )
 {
 return ( std :: pointer_to_unary_function < _Arg, _Result,
  _Result ( __stdcall * ) ( _Arg ) > ( _Left ) );
 }


template < class _Arg,
 class _Result > inline
 pointer_to_unary_function < _Arg, _Result,
  _Result ( __fastcall * ) ( _Arg ) >
   ptr_fun ( _Result ( __fastcall * _Left ) ( _Arg ) )
 {
 return ( std :: pointer_to_unary_function < _Arg, _Result,
  _Result ( __fastcall * ) ( _Arg ) > ( _Left ) );
 }
#line 434 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
template < class _Arg1,
 class _Arg2,
 class _Result > inline
 pointer_to_binary_function < _Arg1, _Arg2, _Result,
  _Result ( __cdecl * ) ( _Arg1, _Arg2 ) >
   ptr_fun ( _Result ( __cdecl * _Left ) ( _Arg1, _Arg2 ) )
 {
 return ( std :: pointer_to_binary_function < _Arg1, _Arg2, _Result,
  _Result ( __cdecl * ) ( _Arg1, _Arg2 ) > ( _Left ) );
 }


template < class _Arg1,
 class _Arg2,
 class _Result > inline
 pointer_to_binary_function < _Arg1, _Arg2, _Result,
  _Result ( __stdcall * ) ( _Arg1, _Arg2 ) >
   ptr_fun ( _Result ( __stdcall * _Left ) ( _Arg1, _Arg2 ) )
 {
 return ( std :: pointer_to_binary_function < _Arg1, _Arg2, _Result,
  _Result ( __stdcall * ) ( _Arg1, _Arg2 ) > ( _Left ) );
 }


template < class _Arg1,
 class _Arg2,
 class _Result > inline
 pointer_to_binary_function < _Arg1, _Arg2, _Result,
  _Result ( __fastcall * ) ( _Arg1, _Arg2 ) >
   ptr_fun ( _Result ( __fastcall * _Left ) ( _Arg1, _Arg2 ) )
 {
 return ( std :: pointer_to_binary_function < _Arg1, _Arg2, _Result,
  _Result ( __fastcall * ) ( _Arg1, _Arg2 ) > ( _Left ) );
 }
#line 485 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
template < class _Result,
 class _Ty >
 class mem_fun_t
  : public unary_function < _Ty *, _Result >
 {
public :
 explicit mem_fun_t ( _Result ( _Ty :: * _Pm ) ( ) )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( _Ty * _Pleft ) const
  {
  return ( ( _Pleft ->* _Pmemfun ) ( ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( );
 };


template < class _Result,
 class _Ty,
 class _Arg >
 class mem_fun1_t
  : public binary_function < _Ty *, _Arg, _Result >
 {
public :
 explicit mem_fun1_t ( _Result ( _Ty :: * _Pm ) ( _Arg ) )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( _Ty * _Pleft, _Arg _Right ) const
  {
  return ( ( _Pleft ->* _Pmemfun ) ( _Right ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( _Arg );
 };


template < class _Result,
 class _Ty >
 class const_mem_fun_t
  : public unary_function < const _Ty *, _Result >
 {
public :
 explicit const_mem_fun_t ( _Result ( _Ty :: * _Pm ) ( ) const )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( const _Ty * _Pleft ) const
  {
  return ( ( _Pleft ->* _Pmemfun ) ( ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( ) const;
 };


template < class _Result,
 class _Ty,
 class _Arg >
 class const_mem_fun1_t
  : public binary_function < const _Ty *, _Arg, _Result >
 {
public :
 explicit const_mem_fun1_t ( _Result ( _Ty :: * _Pm ) ( _Arg ) const )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( const _Ty * _Pleft, _Arg _Right ) const
  {
  return ( ( _Pleft ->* _Pmemfun ) ( _Right ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( _Arg ) const;
 };


template < class _Result,
 class _Ty > inline
 mem_fun_t < _Result, _Ty > mem_fun ( _Result ( _Ty :: * _Pm ) ( ) )
 {
 return ( std :: mem_fun_t < _Result, _Ty > ( _Pm ) );
 }

template < class _Result,
 class _Ty,
 class _Arg > inline
 mem_fun1_t < _Result, _Ty, _Arg > mem_fun ( _Result ( _Ty :: * _Pm ) ( _Arg ) )
 {
 return ( std :: mem_fun1_t < _Result, _Ty, _Arg > ( _Pm ) );
 }

template < class _Result,
 class _Ty > inline
 const_mem_fun_t < _Result, _Ty >
  mem_fun ( _Result ( _Ty :: * _Pm ) ( ) const )
 {
 return ( std :: const_mem_fun_t < _Result, _Ty > ( _Pm ) );
 }

template < class _Result,
 class _Ty,
 class _Arg > inline
 const_mem_fun1_t < _Result, _Ty, _Arg >
  mem_fun ( _Result ( _Ty :: * _Pm ) ( _Arg ) const )
 {
 return ( std :: const_mem_fun1_t < _Result, _Ty, _Arg > ( _Pm ) );
 }


template < class _Result,
 class _Ty,
 class _Arg > inline
 mem_fun1_t < _Result, _Ty, _Arg > mem_fun1 ( _Result ( _Ty :: * _Pm ) ( _Arg ) )
 {
 return ( std :: mem_fun1_t < _Result, _Ty, _Arg > ( _Pm ) );
 }


template < class _Result,
 class _Ty >
 class mem_fun_ref_t
  : public unary_function < _Ty, _Result >
 {
public :
 explicit mem_fun_ref_t ( _Result ( _Ty :: * _Pm ) ( ) )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( _Ty & _Left ) const
  {
  return ( ( _Left .* _Pmemfun ) ( ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( );
 };


template < class _Result,
 class _Ty,
 class _Arg >
 class mem_fun1_ref_t
  : public binary_function < _Ty, _Arg, _Result >
 {
public :
 explicit mem_fun1_ref_t ( _Result ( _Ty :: * _Pm ) ( _Arg ) )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( _Ty & _Left, _Arg _Right ) const
  {
  return ( ( _Left .* _Pmemfun ) ( _Right ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( _Arg );
 };


template < class _Result,
 class _Ty >
 class const_mem_fun_ref_t
  : public unary_function < _Ty, _Result >
 {
public :
 explicit const_mem_fun_ref_t ( _Result ( _Ty :: * _Pm ) ( ) const )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( const _Ty & _Left ) const
  {
  return ( ( _Left .* _Pmemfun ) ( ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( ) const;
 };


template < class _Result,
 class _Ty,
 class _Arg >
 class const_mem_fun1_ref_t
  : public binary_function < _Ty, _Arg, _Result >
 {
public :
 explicit const_mem_fun1_ref_t ( _Result ( _Ty :: * _Pm ) ( _Arg ) const )
  : _Pmemfun ( _Pm )
  {
  }

 _Result operator ( ) ( const _Ty & _Left, _Arg _Right ) const
  {
  return ( ( _Left .* _Pmemfun ) ( _Right ) );
  }

private :
 _Result ( _Ty :: * _Pmemfun ) ( _Arg ) const;
 };


template < class _Result,
 class _Ty > inline
 mem_fun_ref_t < _Result, _Ty > mem_fun_ref ( _Result ( _Ty :: * _Pm ) ( ) )
 {
 return ( std :: mem_fun_ref_t < _Result, _Ty > ( _Pm ) );
 }

template < class _Result,
 class _Ty,
 class _Arg > inline
 mem_fun1_ref_t < _Result, _Ty, _Arg >
  mem_fun_ref ( _Result ( _Ty :: * _Pm ) ( _Arg ) )
 {
 return ( std :: mem_fun1_ref_t < _Result, _Ty, _Arg > ( _Pm ) );
 }

template < class _Result,
 class _Ty > inline
 const_mem_fun_ref_t < _Result, _Ty >
  mem_fun_ref ( _Result ( _Ty :: * _Pm ) ( ) const )
 {
 return ( std :: const_mem_fun_ref_t < _Result, _Ty > ( _Pm ) );
 }

template < class _Result,
 class _Ty,
 class _Arg > inline
 const_mem_fun1_ref_t < _Result, _Ty, _Arg >
  mem_fun_ref ( _Result ( _Ty :: * _Pm ) ( _Arg ) const )
 {
 return ( std :: const_mem_fun1_ref_t < _Result, _Ty, _Arg > ( _Pm ) );
 }


template < class _Result,
 class _Ty,
 class _Arg > inline
 mem_fun1_ref_t < _Result, _Ty, _Arg > mem_fun1_ref ( _Result ( _Ty :: * _Pm ) ( _Arg ) )
 {
 return ( std :: mem_fun1_ref_t < _Result, _Ty, _Arg > ( _Pm ) );
 }
#line 869 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
}
#line 114 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xtr1common"
namespace std { 


template<class _T1, class 
_Ret> struct unary_function; 

template<class _T1, class 
_T2, class 
_Ret> struct binary_function; 


namespace tr1 { 



struct _Nil { 

}; 
static _Nil _Nil_obj; 


template<class _Ty, _Ty 
_Val> 
struct integral_constant { 

static const _Ty value = _Val; 

typedef _Ty value_type; 
typedef tr1::integral_constant< _Ty, _Val>  type; 
}; 

typedef integral_constant< bool, true>  true_type; 
typedef integral_constant< bool, false>  false_type; 


template<bool _First, bool 
_Second> struct _Or; 


template<> struct _Or< false, false>  : public false_type { 


}; 


template<> struct _Or< false, true>  : public true_type { 


}; 


template<> struct _Or< true, false>  : public true_type { 


}; 


template<> struct _Or< true, true>  : public true_type { 


}; 


template<bool __T0> struct _Cat_base; 


template<> struct _Cat_base< false>  : public false_type { 


}; 


template<> struct _Cat_base< true>  : public true_type { 


}; 


template<class _Ty> 
struct _Is_integral : public false_type { 


}; 


template<> struct _Is_integral< bool>  : public true_type { 


}; 


template<> struct _Is_integral< char>  : public true_type { 


}; 


template<> struct _Is_integral< unsigned char>  : public true_type { 


}; 


template<> struct _Is_integral< signed char>  : public true_type { 


}; 



template<> struct _Is_integral< __wchar_t>  : public true_type { 


}; 
#line 231 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xtr1common"
template<> struct _Is_integral< unsigned short>  : public true_type { 


}; 


template<> struct _Is_integral< signed short>  : public true_type { 


}; 


template<> struct _Is_integral< unsigned>  : public true_type { 


}; 


template<> struct _Is_integral< signed int>  : public true_type { 


}; 


template<> struct _Is_integral< unsigned long>  : public true_type { 


}; 


template<> struct _Is_integral< signed long>  : public true_type { 


}; 



template<> struct _Is_integral< __int64>  : public true_type { 


}; 


template<> struct _Is_integral< unsigned __int64>  : public true_type { 


}; 
#line 281 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xtr1common"
template<class _Ty> 
struct _Is_floating_point : public false_type { 


}; 


template<> struct _Is_floating_point< float>  : public true_type { 


}; 


template<> struct _Is_floating_point< double>  : public true_type { 


}; 


template<> struct _Is_floating_point< long double>  : public true_type { 


}; 


template<class _Ty> 
struct _Remove_reference { 

typedef _Ty _Type; 
}; 

template<class _Ty> 
struct _Remove_reference< _Ty &>  { 

typedef _Ty _Type; 
}; 


typedef char (&_No)[1]; 
typedef char (&_Yes)[2]; 




extern _No _Has_result_type(...); 

template<class _Ty> extern _Yes _Has_result_type(_Ty *, typename _Remove_reference< typename _Ty::result_type> ::_Type * = (0)); 
#line 333 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xtr1common"
}
}
#line 6 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
namespace std { 
namespace tr1 { 



template<class _Tgt, class 
_Src> 
struct _Copy_cv { 

typedef _Tgt &_Type; 
}; 

template<class _Tgt, class 
_Src> 
struct _Copy_cv< _Tgt, const _Src &>  { 

typedef const _Tgt &_Type; 
}; 

template<class _Tgt, class 
_Src> 
struct _Copy_cv< _Tgt, volatile _Src &>  { 

typedef volatile _Tgt &_Type; 
}; 

template<class _Tgt, class 
_Src> 
struct _Copy_cv< _Tgt, const volatile _Src &>  { 

typedef const volatile _Tgt &_Type; 
}; 


template<class _Ty> struct _Result_of; 
#line 8 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<bool __T1, class 
_Fty> struct _Result_type0; 



template<class _Fty> 

struct _Result_type0< true, _Fty>  { 

typedef typename _Fty::result_type _Type; 
}; 

template<class _Fty> 

struct _Result_type0< false, _Fty>  { 



typedef void _Type; 
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
}; 


template<class _Fty> 

struct _Result_of0 { 

static const bool _Value = (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])); 


typedef typename _Result_type0< (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])), _Fty> ::_Type _Type; 
}; 

template<class _Ret> 


struct _Result_of0< _Ret (&)(void)>  { 

typedef _Ret _Type; 
}; 

template<class _Ret> 


struct _Result_of0< _Ret (*)(void)>  { 

typedef _Ret _Type; 
}; 

template<class _Ret> 


struct _Result_of0< _Ret (*const)(void)>  { 

typedef _Ret _Type; 
}; 
#line 506 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Fty> 

struct _Result_of< _Fty __cdecl (void)>  { 

typedef typename _Result_of0< _Fty> ::_Type _Type; 
}; 
#line 8 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<bool __T2, class 
_Fty, class 
_Arg0> struct _Result_type1; 


template<class _Fty, class 
_Arg0> 
struct _Result_type1< true, _Fty, _Arg0>  { 

typedef typename _Fty::result_type _Type; 
}; 

template<class _Fty, class 
_Arg0> 
struct _Result_type1< false, _Fty, _Arg0>  { 
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0)> ::type _Type; 
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
}; 


template<class _Fty, class 
_Farg0> 
struct _Result_of1 { 

static const bool _Value = (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])); 


typedef typename _Result_type1< (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])), _Fty, _Farg0> ::_Type _Type; 
}; 

template<class _Ret, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Ret (&)(_Arg0), _Farg0>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Ret (*)(_Arg0), _Farg0>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Ret (*const)(_Arg0), _Farg0>  { 

typedef _Ret _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx _Arg0::*, _Farg0 &>  { 

typedef typename _Copy_cv< _Rx, _Farg0 &> ::_Type _Type; 
}; 

template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx _Arg0::*const, _Farg0 &>  { 

typedef typename _Copy_cv< _Rx, _Farg0 &> ::_Type _Type; 
}; 
#line 89 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__thiscall _Arg0::*)(void), _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__cdecl _Arg0::*)(void), _Farg0 &>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__stdcall _Arg0::*)(void), _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__fastcall _Arg0::*)(void), _Farg0 &>  { 


typedef _Rx _Type; 
}; 
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__thiscall _Arg0::*)(void) const, _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__cdecl _Arg0::*)(void) const, _Farg0 &>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__stdcall _Arg0::*)(void) const, _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__fastcall _Arg0::*)(void) const, _Farg0 &>  { 


typedef _Rx _Type; 
}; 
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__thiscall _Arg0::*)(void) volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__cdecl _Arg0::*)(void) volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__stdcall _Arg0::*)(void) volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__fastcall _Arg0::*)(void) volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 
#line 245 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__thiscall _Arg0::*)(void) const volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__cdecl _Arg0::*)(void) const volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__stdcall _Arg0::*)(void) const volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__fastcall _Arg0::*)(void) const volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 
#line 297 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__thiscall _Arg0::*const)(void), _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__cdecl _Arg0::*const)(void), _Farg0 &>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__stdcall _Arg0::*const)(void), _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__fastcall _Arg0::*const)(void), _Farg0 &>  { 


typedef _Rx _Type; 
}; 
#line 349 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__thiscall _Arg0::*const)(void) const, _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__cdecl _Arg0::*const)(void) const, _Farg0 &>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__stdcall _Arg0::*const)(void) const, _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__fastcall _Arg0::*const)(void) const, _Farg0 &>  { 


typedef _Rx _Type; 
}; 
#line 401 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__thiscall _Arg0::*const)(void) volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__cdecl _Arg0::*const)(void) volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__stdcall _Arg0::*const)(void) volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__fastcall _Arg0::*const)(void) volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 
#line 453 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__thiscall _Arg0::*const)(void) const volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__cdecl _Arg0::*const)(void) const volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__stdcall _Arg0::*const)(void) const volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class 
_Farg0> 
struct _Result_of1< _Rx (__fastcall _Arg0::*const)(void) const volatile, _Farg0 &>  { 


typedef _Rx _Type; 
}; 
#line 506 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Fty, class 
_Arg0> 
struct _Result_of< _Fty __cdecl (_Arg0)>  { 

typedef typename _Result_of1< _Fty, typename _Remove_reference< _Arg0> ::_Type &> ::_Type _Type; 
}; 
#line 8 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<bool __T3, class 
_Fty, class 
_Arg0, class _Arg1> struct _Result_type2; 


template<class _Fty, class 
_Arg0, class _Arg1> 
struct _Result_type2< true, _Fty, _Arg0, _Arg1>  { 

typedef typename _Fty::result_type _Type; 
}; 

template<class _Fty, class 
_Arg0, class _Arg1> 
struct _Result_type2< false, _Fty, _Arg0, _Arg1>  { 
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1)> ::type _Type; 
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
}; 


template<class _Fty, class 
_Farg0, class _Farg1> 
struct _Result_of2 { 

static const bool _Value = (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])); 


typedef typename _Result_type2< (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])), _Fty, _Farg0, _Farg1> ::_Type _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Ret (&)(_Arg0, _Arg1), _Farg0, _Farg1>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Ret (*)(_Arg0, _Arg1), _Farg0, _Farg1>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Ret (*const)(_Arg0, _Arg1), _Farg0, _Farg1>  { 

typedef _Ret _Type; 
}; 
#line 89 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__thiscall _Arg0::*)(_Arg1), _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__cdecl _Arg0::*)(_Arg1), _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__stdcall _Arg0::*)(_Arg1), _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__fastcall _Arg0::*)(_Arg1), _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__thiscall _Arg0::*)(_Arg1) const, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__cdecl _Arg0::*)(_Arg1) const, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__stdcall _Arg0::*)(_Arg1) const, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__fastcall _Arg0::*)(_Arg1) const, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__thiscall _Arg0::*)(_Arg1) volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__cdecl _Arg0::*)(_Arg1) volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__stdcall _Arg0::*)(_Arg1) volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__fastcall _Arg0::*)(_Arg1) volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 
#line 245 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__thiscall _Arg0::*)(_Arg1) const volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__cdecl _Arg0::*)(_Arg1) const volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__stdcall _Arg0::*)(_Arg1) const volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__fastcall _Arg0::*)(_Arg1) const volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 
#line 297 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__thiscall _Arg0::*const)(_Arg1), _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__cdecl _Arg0::*const)(_Arg1), _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__stdcall _Arg0::*const)(_Arg1), _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__fastcall _Arg0::*const)(_Arg1), _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 
#line 349 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__thiscall _Arg0::*const)(_Arg1) const, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__cdecl _Arg0::*const)(_Arg1) const, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__stdcall _Arg0::*const)(_Arg1) const, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__fastcall _Arg0::*const)(_Arg1) const, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 
#line 401 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__thiscall _Arg0::*const)(_Arg1) volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__cdecl _Arg0::*const)(_Arg1) volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__stdcall _Arg0::*const)(_Arg1) volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__fastcall _Arg0::*const)(_Arg1) volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 
#line 453 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__thiscall _Arg0::*const)(_Arg1) const volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__cdecl _Arg0::*const)(_Arg1) const volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__stdcall _Arg0::*const)(_Arg1) const volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class 
_Farg0, class _Farg1> 
struct _Result_of2< _Rx (__fastcall _Arg0::*const)(_Arg1) const volatile, _Farg0 &, _Farg1>  { 


typedef _Rx _Type; 
}; 
#line 506 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Fty, class 
_Arg0, class _Arg1> 
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1)>  { 

typedef typename _Result_of2< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &> ::_Type _Type; 
}; 
#line 8 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<bool __T4, class 
_Fty, class 
_Arg0, class _Arg1, class _Arg2> struct _Result_type3; 


template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2> 
struct _Result_type3< true, _Fty, _Arg0, _Arg1, _Arg2>  { 

typedef typename _Fty::result_type _Type; 
}; 

template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2> 
struct _Result_type3< false, _Fty, _Arg0, _Arg1, _Arg2>  { 
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2)> ::type _Type; 
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
}; 


template<class _Fty, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3 { 

static const bool _Value = (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])); 


typedef typename _Result_type3< (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])), _Fty, _Farg0, _Farg1, _Farg2> ::_Type _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Ret (&)(_Arg0, _Arg1, _Arg2), _Farg0, _Farg1, _Farg2>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Ret (*)(_Arg0, _Arg1, _Arg2), _Farg0, _Farg1, _Farg2>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Ret (*const)(_Arg0, _Arg1, _Arg2), _Farg0, _Farg1, _Farg2>  { 

typedef _Ret _Type; 
}; 
#line 89 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2), _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2), _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2), _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2), _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2) const, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2) const, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2) const, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2) const, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2) volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2) volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2) volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2) volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 
#line 245 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2) const volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2) const volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2) const volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2) const volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 
#line 297 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2), _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2), _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2), _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2), _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 
#line 349 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2) const, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2) const, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2) const, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2) const, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 
#line 401 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2) volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2) volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2) volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2) volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 
#line 453 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2) const volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2) const volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2) const volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class 
_Farg0, class _Farg1, class _Farg2> 
struct _Result_of3< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2) const volatile, _Farg0 &, _Farg1, _Farg2>  { 


typedef _Rx _Type; 
}; 
#line 506 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2> 
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2)>  { 

typedef typename _Result_of3< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &> ::_Type _Type; 
}; 
#line 8 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<bool __T5, class 
_Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3> struct _Result_type4; 


template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3> 
struct _Result_type4< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3>  { 

typedef typename _Fty::result_type _Type; 
}; 

template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3> 
struct _Result_type4< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3>  { 
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3)> ::type _Type; 
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
}; 


template<class _Fty, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4 { 

static const bool _Value = (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])); 


typedef typename _Result_type4< (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])), _Fty, _Farg0, _Farg1, _Farg2, _Farg3> ::_Type _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Ret (&)(_Arg0, _Arg1, _Arg2, _Arg3), _Farg0, _Farg1, _Farg2, _Farg3>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3), _Farg0, _Farg1, _Farg2, _Farg3>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Ret (*const)(_Arg0, _Arg1, _Arg2, _Arg3), _Farg0, _Farg1, _Farg2, _Farg3>  { 

typedef _Ret _Type; 
}; 
#line 89 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3), _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3), _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3), _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3), _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3) const, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3) const, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3) const, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3) const, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 
#line 245 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 
#line 297 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3), _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3), _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3), _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3), _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 
#line 349 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3) const, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3) const, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3) const, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3) const, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 
#line 401 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 
#line 453 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3> 
struct _Result_of4< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3>  { 


typedef _Rx _Type; 
}; 
#line 506 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3> 
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3)>  { 

typedef typename _Result_of4< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &> ::_Type _Type; 
}; 
#line 8 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<bool __T6, class 
_Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> struct _Result_type5; 


template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
struct _Result_type5< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4>  { 

typedef typename _Fty::result_type _Type; 
}; 

template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
struct _Result_type5< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4>  { 
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4)> ::type _Type; 
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
}; 


template<class _Fty, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5 { 

static const bool _Value = (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])); 


typedef typename _Result_type5< (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])), _Fty, _Farg0, _Farg1, _Farg2, _Farg3, _Farg4> ::_Type _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Ret (&)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Ret (*const)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4>  { 

typedef _Ret _Type; 
}; 
#line 89 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 
#line 245 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 
#line 297 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 
#line 349 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 
#line 401 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 
#line 453 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4> 
struct _Result_of5< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4>  { 


typedef _Rx _Type; 
}; 
#line 506 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4)>  { 

typedef typename _Result_of5< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &, typename _Remove_reference< _Arg4> ::_Type &> ::_Type _Type; 
}; 
#line 8 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<bool __T7, class 
_Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> struct _Result_type6; 


template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
struct _Result_type6< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5>  { 

typedef typename _Fty::result_type _Type; 
}; 

template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
struct _Result_type6< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5>  { 
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5)> ::type _Type; 
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
}; 


template<class _Fty, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6 { 

static const bool _Value = (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])); 


typedef typename _Result_type6< (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])), _Fty, _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5> ::_Type _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Ret (&)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Ret (*const)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 

typedef _Ret _Type; 
}; 
#line 89 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 
#line 245 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 
#line 297 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 
#line 349 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 
#line 401 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 
#line 453 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5> 
struct _Result_of6< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5>  { 


typedef _Rx _Type; 
}; 
#line 506 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5)>  { 

typedef typename _Result_of6< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &, typename _Remove_reference< _Arg4> ::_Type &, typename _Remove_reference< _Arg5> ::_Type &> ::_Type _Type; 
}; 
#line 8 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<bool __T8, class 
_Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> struct _Result_type7; 


template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
struct _Result_type7< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6>  { 

typedef typename _Fty::result_type _Type; 
}; 

template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
struct _Result_type7< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6>  { 
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6)> ::type _Type; 
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
}; 


template<class _Fty, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7 { 

static const bool _Value = (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])); 


typedef typename _Result_type7< (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])), _Fty, _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6> ::_Type _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Ret (&)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Ret (*const)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 

typedef _Ret _Type; 
}; 
#line 89 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 
#line 245 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 
#line 297 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 
#line 349 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 
#line 401 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 
#line 453 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6> 
struct _Result_of7< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6>  { 


typedef _Rx _Type; 
}; 
#line 506 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6)>  { 

typedef typename _Result_of7< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &, typename _Remove_reference< _Arg4> ::_Type &, typename _Remove_reference< _Arg5> ::_Type &, typename _Remove_reference< _Arg6> ::_Type &> ::_Type _Type; 
}; 
#line 8 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<bool __T9, class 
_Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> struct _Result_type8; 


template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
struct _Result_type8< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7>  { 

typedef typename _Fty::result_type _Type; 
}; 

template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
struct _Result_type8< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7>  { 
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7)> ::type _Type; 
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
}; 


template<class _Fty, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8 { 

static const bool _Value = (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])); 


typedef typename _Result_type8< (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])), _Fty, _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7> ::_Type _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Ret (&)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Ret (*const)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 

typedef _Ret _Type; 
}; 
#line 89 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 
#line 245 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 
#line 297 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 
#line 349 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 
#line 401 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 
#line 453 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7> 
struct _Result_of8< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7>  { 


typedef _Rx _Type; 
}; 
#line 506 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7)>  { 

typedef typename _Result_of8< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &, typename _Remove_reference< _Arg4> ::_Type &, typename _Remove_reference< _Arg5> ::_Type &, typename _Remove_reference< _Arg6> ::_Type &, typename _Remove_reference< _Arg7> ::_Type &> ::_Type _Type; 
}; 
#line 8 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<bool __T10, class 
_Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> struct _Result_type9; 


template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
struct _Result_type9< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8>  { 

typedef typename _Fty::result_type _Type; 
}; 

template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
struct _Result_type9< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8>  { 
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8)> ::type _Type; 
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
}; 


template<class _Fty, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9 { 

static const bool _Value = (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])); 


typedef typename _Result_type9< (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])), _Fty, _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8> ::_Type _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Ret (&)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Ret (*const)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 

typedef _Ret _Type; 
}; 
#line 89 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 
#line 245 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 
#line 297 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 
#line 349 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 
#line 401 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 
#line 453 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8> 
struct _Result_of9< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8>  { 


typedef _Rx _Type; 
}; 
#line 506 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8)>  { 

typedef typename _Result_of9< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &, typename _Remove_reference< _Arg4> ::_Type &, typename _Remove_reference< _Arg5> ::_Type &, typename _Remove_reference< _Arg6> ::_Type &, typename _Remove_reference< _Arg7> ::_Type &, typename _Remove_reference< _Arg8> ::_Type &> ::_Type _Type; 
}; 
#line 8 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<bool __T11, class 
_Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> struct _Result_type10; 


template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
struct _Result_type10< true, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9>  { 

typedef typename _Fty::result_type _Type; 
}; 

template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
struct _Result_type10< false, _Fty, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9>  { 
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
typedef typename _Fty::template result< _Fty (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9)> ::type _Type; 
#line 32 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
}; 


template<class _Fty, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10 { 

static const bool _Value = (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])); 


typedef typename _Result_type10< (sizeof((tr1::_Has_result_type((_Fty *)0))) == sizeof(char [2])), _Fty, _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9> ::_Type _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Ret (&)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Ret (*)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 

typedef _Ret _Type; 
}; 

template<class _Ret, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Ret (*const)(_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 

typedef _Ret _Type; 
}; 
#line 89 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 
#line 245 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__thiscall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__cdecl _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__stdcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__fastcall _Arg0::*)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 
#line 297 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9), _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 
#line 349 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 
#line 401 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 
#line 453 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__thiscall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__cdecl _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 

template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__stdcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 


template<class _Rx, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9, class 
_Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9> 
struct _Result_of10< _Rx (__fastcall _Arg0::*const)(_Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9) const volatile, _Farg0 &, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9>  { 


typedef _Rx _Type; 
}; 
#line 506 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxresult"
template<class _Fty, class 
_Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
struct _Result_of< _Fty __cdecl (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9)>  { 

typedef typename _Result_of10< _Fty, typename _Remove_reference< _Arg0> ::_Type &, typename _Remove_reference< _Arg1> ::_Type &, typename _Remove_reference< _Arg2> ::_Type &, typename _Remove_reference< _Arg3> ::_Type &, typename _Remove_reference< _Arg4> ::_Type &, typename _Remove_reference< _Arg5> ::_Type &, typename _Remove_reference< _Arg6> ::_Type &, typename _Remove_reference< _Arg7> ::_Type &, typename _Remove_reference< _Arg8> ::_Type &, typename _Remove_reference< _Arg9> ::_Type &> ::_Type _Type; 
}; 
#line 47 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
template<class _Fty> 
struct result_of { 

typedef typename _Result_of< _Fty> ::_Type type; 
}; 




template<class _Ret, class 
_Arg0> 
struct _Pmd_caller { 

template < class _Pmd,
  class _Farg0 >
  static _Ret _Call_pmd ( const volatile _Arg0 *, _Pmd _Pm, _Farg0 _F0 )
  {
  return ( ( _Ret ) ( _F0 .* _Pm ) );
  }

template < class _Pmd,
  class _Farg0 >
  static _Ret _Call_pmd ( const volatile void *, _Pmd _Pm, _Farg0 _F0 )
  {
  return ( ( * _F0 ) .* _Pm );
  }

template < class _Pmd,
  class _Farg0 >
  static _Ret _Apply_pmd ( _Pmd _Pm, _Farg0 & _F0 )
  {
  return ( _Call_pmd < _Pmd, _Farg0 & > ( & _F0, _Pm, _F0 ) );
  }

template < class _Pmd,
  class _Farg0 >
  static _Ret _Apply_pmd ( _Pmd _Pm, _Farg0 * _F0 )
  {
  return ( _Call_pmd < _Pmd, _Farg0 & > ( _F0, _Pm, * _F0 ) );
  }
}; 
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxpmfcaller"
template < class _Ty >
 class reference_wrapper;

template<class _Ret, class 
_Arg0> 
struct _Pmf_caller1 { 

typedef _Arg0 _Funobj; 


template < class _Pmf,
  class _Farg0 >
  static _Ret _Call_pmf ( const volatile
   reference_wrapper < typename _Remove_reference < _Arg0 > :: _Type > *,
    _Pmf _Pm, _Farg0 _Fx0 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( ) );
  }

template < class _Pmf,
  class _Farg0 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
    _Pmf _Pm, _Farg0 _Fx0 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( ) );
  }

template < class _Pmf,
  class _Farg0 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type &,
    _Pmf _Pm, _Farg0 _Fx0 )
  {
  return ( ( _Fx0 .* _Pm ) ( ) );
  }

template < class _Pmf,
  class _Farg0 >
  static _Ret _Call_pmf ( const volatile void *, _Pmf _Pm, _Farg0 _Fx0 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( ) );
  }

template < class _Pmf,
  class _Farg0 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 & > ( & _Fx0, _Pm,
   _Fx0 ) );
  }

template < class _Pmf,
  class _Farg0 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 * _Fx0 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 & > ( _Fx0, _Pm,
   * _Fx0 ) );
  }
}; 
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxpmfcaller"
template<class _Ty> class reference_wrapper; 


template<class _Ret, class 
_Arg0> 
struct _Pmf_caller2 { 

typedef _Arg0 _Funobj; 


template < class _Pmf,
  class _Farg0, class _Farg1 >
  static _Ret _Call_pmf ( const volatile
   reference_wrapper < typename _Remove_reference < _Arg0 > :: _Type > *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type &,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1 >
  static _Ret _Call_pmf ( const volatile void *, _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 & > ( & _Fx0, _Pm,
   _Fx0, _Fx1 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 * _Fx0, _Farg1 & _Fx1 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 & > ( _Fx0, _Pm,
   * _Fx0, _Fx1 ) );
  }
}; 
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxpmfcaller"
template<class _Ty> class reference_wrapper; 


template<class _Ret, class 
_Arg0> 
struct _Pmf_caller3 { 

typedef _Arg0 _Funobj; 


template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2 >
  static _Ret _Call_pmf ( const volatile
   reference_wrapper < typename _Remove_reference < _Arg0 > :: _Type > *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type &,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2 >
  static _Ret _Call_pmf ( const volatile void *, _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 & > ( & _Fx0, _Pm,
   _Fx0, _Fx1, _Fx2 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 * _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 & > ( _Fx0, _Pm,
   * _Fx0, _Fx1, _Fx2 ) );
  }
}; 
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxpmfcaller"
template<class _Ty> class reference_wrapper; 


template<class _Ret, class 
_Arg0> 
struct _Pmf_caller4 { 

typedef _Arg0 _Funobj; 


template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  static _Ret _Call_pmf ( const volatile
   reference_wrapper < typename _Remove_reference < _Arg0 > :: _Type > *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type &,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  static _Ret _Call_pmf ( const volatile void *, _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 & > ( & _Fx0, _Pm,
   _Fx0, _Fx1, _Fx2, _Fx3 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 * _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 & > ( _Fx0, _Pm,
   * _Fx0, _Fx1, _Fx2, _Fx3 ) );
  }
}; 
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxpmfcaller"
template<class _Ty> class reference_wrapper; 


template<class _Ret, class 
_Arg0> 
struct _Pmf_caller5 { 

typedef _Arg0 _Funobj; 


template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  static _Ret _Call_pmf ( const volatile
   reference_wrapper < typename _Remove_reference < _Arg0 > :: _Type > *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type &,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  static _Ret _Call_pmf ( const volatile void *, _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 &, _Farg4 & > ( & _Fx0, _Pm,
   _Fx0, _Fx1, _Fx2, _Fx3, _Fx4 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 * _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 &, _Farg4 & > ( _Fx0, _Pm,
   * _Fx0, _Fx1, _Fx2, _Fx3, _Fx4 ) );
  }
}; 
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxpmfcaller"
template<class _Ty> class reference_wrapper; 


template<class _Ret, class 
_Arg0> 
struct _Pmf_caller6 { 

typedef _Arg0 _Funobj; 


template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  static _Ret _Call_pmf ( const volatile
   reference_wrapper < typename _Remove_reference < _Arg0 > :: _Type > *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type &,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  static _Ret _Call_pmf ( const volatile void *, _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 &, _Farg4 &, _Farg5 & > ( & _Fx0, _Pm,
   _Fx0, _Fx1, _Fx2, _Fx3, _Fx4, _Fx5 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 * _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 &, _Farg4 &, _Farg5 & > ( _Fx0, _Pm,
   * _Fx0, _Fx1, _Fx2, _Fx3, _Fx4, _Fx5 ) );
  }
}; 
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxpmfcaller"
template<class _Ty> class reference_wrapper; 


template<class _Ret, class 
_Arg0> 
struct _Pmf_caller7 { 

typedef _Arg0 _Funobj; 


template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  static _Ret _Call_pmf ( const volatile
   reference_wrapper < typename _Remove_reference < _Arg0 > :: _Type > *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type &,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  static _Ret _Call_pmf ( const volatile void *, _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 &, _Farg4 &, _Farg5 &, _Farg6 & > ( & _Fx0, _Pm,
   _Fx0, _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 * _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 &, _Farg4 &, _Farg5 &, _Farg6 & > ( _Fx0, _Pm,
   * _Fx0, _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6 ) );
  }
}; 
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxpmfcaller"
template<class _Ty> class reference_wrapper; 


template<class _Ret, class 
_Arg0> 
struct _Pmf_caller8 { 

typedef _Arg0 _Funobj; 


template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  static _Ret _Call_pmf ( const volatile
   reference_wrapper < typename _Remove_reference < _Arg0 > :: _Type > *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6, _Farg7 _Fx7 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6, _Farg7 _Fx7 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type &,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6, _Farg7 _Fx7 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  static _Ret _Call_pmf ( const volatile void *, _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6, _Farg7 _Fx7 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 &, _Farg4 &, _Farg5 &, _Farg6 &, _Farg7 & > ( & _Fx0, _Pm,
   _Fx0, _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 * _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 &, _Farg4 &, _Farg5 &, _Farg6 &, _Farg7 & > ( _Fx0, _Pm,
   * _Fx0, _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7 ) );
  }
}; 
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxpmfcaller"
template<class _Ty> class reference_wrapper; 


template<class _Ret, class 
_Arg0> 
struct _Pmf_caller9 { 

typedef _Arg0 _Funobj; 


template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  static _Ret _Call_pmf ( const volatile
   reference_wrapper < typename _Remove_reference < _Arg0 > :: _Type > *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6, _Farg7 _Fx7, _Farg8 _Fx8 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6, _Farg7 _Fx7, _Farg8 _Fx8 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type &,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6, _Farg7 _Fx7, _Farg8 _Fx8 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  static _Ret _Call_pmf ( const volatile void *, _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6, _Farg7 _Fx7, _Farg8 _Fx8 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7, _Farg8 & _Fx8 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 &, _Farg4 &, _Farg5 &, _Farg6 &, _Farg7 &, _Farg8 & > ( & _Fx0, _Pm,
   _Fx0, _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 * _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7, _Farg8 & _Fx8 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 &, _Farg4 &, _Farg5 &, _Farg6 &, _Farg7 &, _Farg8 & > ( _Fx0, _Pm,
   * _Fx0, _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8 ) );
  }
}; 
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxpmfcaller"
template<class _Ty> class reference_wrapper; 


template<class _Ret, class 
_Arg0> 
struct _Pmf_caller10 { 

typedef _Arg0 _Funobj; 


template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  static _Ret _Call_pmf ( const volatile
   reference_wrapper < typename _Remove_reference < _Arg0 > :: _Type > *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6, _Farg7 _Fx7, _Farg8 _Fx8, _Farg9 _Fx9 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8, _Fx9 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type *,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6, _Farg7 _Fx7, _Farg8 _Fx8, _Farg9 _Fx9 )
  {
  typedef typename _Remove_reference < _Arg0 > :: _Type _Arg0_noref;
  typedef typename _Remove_reference < _Farg0 > :: _Type _Farg0_noref;
  typedef typename _Copy_cv < _Arg0_noref, _Farg0_noref > :: _Type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8, _Fx9 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  static _Ret _Call_pmf (
   const volatile typename _Remove_reference < _Arg0 > :: _Type &,
    _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6, _Farg7 _Fx7, _Farg8 _Fx8, _Farg9 _Fx9 )
  {
  return ( ( _Fx0 .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8, _Fx9 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  static _Ret _Call_pmf ( const volatile void *, _Pmf _Pm, _Farg0 _Fx0, _Farg1 _Fx1, _Farg2 _Fx2, _Farg3 _Fx3, _Farg4 _Fx4, _Farg5 _Fx5, _Farg6 _Fx6, _Farg7 _Fx7, _Farg8 _Fx8, _Farg9 _Fx9 )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8, _Fx9 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 & _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7, _Farg8 & _Fx8, _Farg9 & _Fx9 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 &, _Farg4 &, _Farg5 &, _Farg6 &, _Farg7 &, _Farg8 &, _Farg9 & > ( & _Fx0, _Pm,
   _Fx0, _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8, _Fx9 ) );
  }

template < class _Pmf,
  class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9 >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 * _Fx0, _Farg1 & _Fx1, _Farg2 & _Fx2, _Farg3 & _Fx3, _Farg4 & _Fx4, _Farg5 & _Fx5, _Farg6 & _Fx6, _Farg7 & _Fx7, _Farg8 & _Fx8, _Farg9 & _Fx9 )
  {
  return ( _Call_pmf < _Pmf, _Farg0 &, _Farg1 &, _Farg2 &, _Farg3 &, _Farg4 &, _Farg5 &, _Farg6 &, _Farg7 &, _Farg8 &, _Farg9 & > ( _Fx0, _Pm,
   * _Fx0, _Fx1, _Fx2, _Fx3, _Fx4, _Fx5, _Fx6, _Fx7, _Fx8, _Fx9 ) );
  }
}; 
#line 94 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
template<class _Ty, bool 
_Indirect> struct _Callable_base; 


template < class _Ty >
 struct _Callable_base < _Ty, false >
 {
 enum { _EEN_INDIRECT = 0 };

 typedef _Ty _MyTy;
 typedef const _Ty & _MyCnstTy;

 _Callable_base ( _Ty & _Val )
  : _Object ( _Val )
  {
  }

 const _Ty & _Get ( ) const
  {
  return ( _Object );
  }

 _Ty & _Get ( )
  {
  return ( _Object );
  }

private :
 _Ty _Object;
};

template < class _Ty >
 struct _Callable_base < _Ty, true >
 {

 enum { _EEN_INDIRECT = 1 };

 typedef _Ty _MyTy;
 typedef _Ty & _MyCnstTy;

 _Callable_base ( _Ty & _Val )
  : _Ptr ( & _Val )
  {
  }

 _MyCnstTy _Get ( ) const
  {
  return ( * _Ptr );
  }

 _Ty & _Get ( )
  {
  return ( * _Ptr );
  }

 void _Reset ( _Ty & _Val )
  {
  _Ptr = & _Val;
  }

private :
 _Ty * _Ptr;
};


template < class _Ty,
 class _Memty,
 bool _Indirect = false >
 struct _Callable_pmd
  : _Callable_base < _Ty, _Indirect >
 {
 _Callable_pmd ( _Ty & _Val )
  : _Callable_base < _Ty, _Indirect > ( _Val )
  {
  }

 template < class _Ret,
  class _Arg0 >
  _Ret _ApplyX ( _Arg0 & _A0 ) const
  {
  return ( _Pmd_caller < _Ret, _Memty > :: _Apply_pmd ( this -> _Get ( ), _A0 ) );
  }
 };


template < class _Ty,
 bool _Indirect = false >
 struct _Callable_obj
  : _Callable_base < _Ty, _Indirect >
 {
 _Callable_obj ( _Ty & _Val )
  : _Callable_base < _Ty, _Indirect > ( _Val )
  {
  }




















































































































































































































































template < class _Ret >
 _Ret _ApplyX ( ) const
 {
 return ( this -> _Get ( ) ( ) );
 }

template < class _Ret >
 _Ret _ApplyX ( )
 {
 return ( this -> _Get ( ) ( ) );
 }




































































































































































































































































































































template < class _Ret, class _Arg0 >
 _Ret _ApplyX ( _Arg0 & _Ax0 ) const
 {
 return ( this -> _Get ( ) ( _Ax0 ) );
 }

template < class _Ret, class _Arg0 >
 _Ret _ApplyX ( _Arg0 & _Ax0 )
 {
 return ( this -> _Get ( ) ( _Ax0 ) );
 }


template < class _Ret, class _Arg0 >
 _Ret _ApplyX ( const _Arg0 & _Ax0 ) const
 {
 return ( this -> _Get ( ) ( _Ax0 ) );
 }

template < class _Ret, class _Arg0 >
 _Ret _ApplyX ( const _Arg0 & _Ax0 )
 {
 return ( this -> _Get ( ) ( _Ax0 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1 ) );
 }

template < class _Ret, class _Arg0, class _Arg1 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1 ) );
 }


template < class _Ret, class _Arg0, class _Arg1 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1 ) );
 }

template < class _Ret, class _Arg0, class _Arg1 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8, _Arg9 & _Ax9 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8, _Arg9 & _Ax9 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8, _Arg9 & _Ax9 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) );
 }

template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8, _Arg9 & _Ax9 )
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) );
 }


























































































 };
#line 195 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
template < class _Ty,
 class _Memty,
 bool _Indirect = false >
 struct _Callable_pmf
  : _Callable_base < _Ty, _Indirect >
 {
 _Callable_pmf ( _Ty & _Val )
  : _Callable_base < _Ty, _Indirect > ( _Val )
  {
  }



















































































































































































































































































































































































































































































































































































template < class _Ret, class _Arg0 >
 _Ret _ApplyX ( _Arg0 & _Ax0 ) const
 {
 return ( _Pmf_caller1 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0 ) );
 }























































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1 ) const
 {
 return ( _Pmf_caller2 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1 ) );
 }























































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2 ) const
 {
 return ( _Pmf_caller3 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2 ) );
 }























































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3 ) const
 {
 return ( _Pmf_caller4 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3 ) );
 }























































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4 ) const
 {
 return ( _Pmf_caller5 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) );
 }























































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5 ) const
 {
 return ( _Pmf_caller6 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) );
 }























































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6 ) const
 {
 return ( _Pmf_caller7 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) );
 }























































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7 ) const
 {
 return ( _Pmf_caller8 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) );
 }























































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8 ) const
 {
 return ( _Pmf_caller9 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) );
 }























































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8, _Arg9 & _Ax9 ) const
 {
 return ( _Pmf_caller10 < _Ret, _Memty > ::
  _Apply_pmf ( this -> _Get ( ), _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) );
 }


























































































 };
#line 212 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
template < class _Ty,
 bool _Indirect = false >
 struct _Callable_fun
  : _Callable_base < _Ty, _Indirect >
 {
 _Callable_fun ( _Ty & _Val )
  : _Callable_base < _Ty, _Indirect > ( _Val )
  {
  }




















































































































































































































































template < class _Ret >
 _Ret _ApplyX ( ) const
 {
 return ( this -> _Get ( ) ( ) );
 }






























































































































































































































































































































template < class _Ret, class _Arg0 >
 _Ret _ApplyX ( _Arg0 & _Ax0 ) const
 {
 return ( this -> _Get ( ) ( _Ax0 ) );
 }


template < class _Ret, class _Arg0 >
 _Ret _ApplyX ( const _Arg0 & _Ax0 ) const
 {
 return ( this -> _Get ( ) ( _Ax0 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1 ) );
 }


template < class _Ret, class _Arg0, class _Arg1 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) );
 }






















































































































































































































































































































template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Ret _ApplyX ( _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8, _Arg9 & _Ax9 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) );
 }


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Ret _ApplyX ( const _Arg0 & _Ax0, _Arg1 & _Ax1, _Arg2 & _Ax2, _Arg3 & _Ax3, _Arg4 & _Ax4, _Arg5 & _Ax5, _Arg6 & _Ax6, _Arg7 & _Ax7, _Arg8 & _Ax8, _Arg9 & _Ax9 ) const
 {
 return ( this -> _Get ( ) ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) );
 }


























































































 };
#line 228 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
template < class _Callable >
 struct _Call_wrapper_base
 {
 typedef typename _Callable :: _MyTy _MyTy;
 typedef typename _Callable :: _MyCnstTy _MyCnstTy;

 _Call_wrapper_base ( _MyTy & _Val )
  : _Callee ( _Val )
  {
  }

 void _Reset ( _MyTy & _Val )
  {
  _Callee . _Reset ( _Val );
  }

 _MyCnstTy _Get ( ) const
  {
  return ( _Callee . _Get ( ) );
  }

 _MyCnstTy _Get ( )
  {
  return ( _Callee . _Get ( ) );
  }

 _Callable _Callee;
 };


template < class _Callable >
 struct _Call_wrapper
 : _Call_wrapper_base < _Callable >
 {
 typedef _Call_wrapper_base < _Callable > _Mybase;

 _Call_wrapper ( typename _Call_wrapper_base < _Callable > :: _MyTy & _Val )
  : _Call_wrapper_base < _Callable > ( _Val )
  {
  }
















































































































































































































 typename _Result_of < typename _Callable :: _MyTy ( ) > :: _Type
  operator ( ) ( ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( ) );
 }






































































































































































































































































































































































































template < class _Carg0 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0 ) );
 }


























































































































































































template < class _Carg0 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0 ) );
 }

































































































































































































































































































































































































template < class _Carg0, class _Carg1 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1 ) );
 }


























































































































































































template < class _Carg0, class _Carg1 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1 ) );
 }



























































































































































































template < class _Carg0, class _Carg1 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1 ) );
 }
























































































































































































template < class _Carg0, class _Carg1 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1 ) );
 }


























































































































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2 ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2 ) );
 }















































































































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3 ) );
 }





























































































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4 ) );
 }


























































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5 ) );
 }


























































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6 ) );
 }


























































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7 ) );
 }



























































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8 ) );
 }




























































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Result_of < typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Result_of <
  typename _Callable :: _MyTy ( const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & ) > :: _Type _Ret;
 return ( _Mybase :: _Callee . template _ApplyX < _Ret > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }




































































































































 };
#line 275 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
template<class _Ty> extern _No _Has_result_and_arg_type(const volatile void *); 


template<class _Ty> extern _Yes _Has_result_and_arg_type(_Ty *, typename _Ty::argument_type * = (0), typename _Ty::result_type * = (0)); 
#line 286 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
template<class _Ty> extern _No _Has_result_and_2arg_type(const volatile void *); 


template<class _Ty> extern _Yes _Has_result_and_2arg_type(_Ty *, typename _Ty::first_argument_type * = (0), typename _Ty::second_argument_type * = (0), typename _Ty::result_type * = (0)); 
#line 299 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
template<class _T1, class 
_Ret> extern _No 
#line 299 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
_Has_unary_base(const volatile void *); 



template<class _T1, class 
_Ret> extern _Yes 
#line 303 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
_Has_unary_base(const volatile unary_function< _T1, _Ret>  *); 
#line 312 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
template<class _T1, class 
_T2, class 
_Ret> extern _No 
#line 312 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
_Has_binary_base(const volatile void *); 




template<class _T1, class 
_T2, class 
_Ret> extern _Yes 
#line 317 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
_Has_binary_base(const volatile binary_function< _T1, _T2, _Ret>  *); 
#line 328 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
template<class _Ty, bool 
__T12> 
struct _Refwrap_result0 { 

typedef typename _Ty::result_type result_type; 
}; 

template<class _Ty> 
struct _Refwrap_result0< _Ty, false>  { 

}; 


template<class _Ty, bool 
__T13> 
struct _Refwrap_result1_helper : public _Refwrap_result0< _Ty, (sizeof((tr1::_Has_result_type((_Ty *)0))) == sizeof(char [2]))>  { 


}; 

template<class _Ty> 
struct _Refwrap_result1_helper< _Ty, true>  : public unary_function< typename _Ty::argument_type, typename _Ty::result_type>  { 



}; 


template<class _Ty, bool 
__T14> 
struct _Refwrap_result1 : public _Refwrap_result0< _Ty, (sizeof((tr1::_Has_result_type((_Ty *)0))) == sizeof(char [2]))>  { 


}; 

template<class _Ty> 
struct _Refwrap_result1< _Ty, true>  : public _Refwrap_result1_helper< _Ty, (sizeof((_Has_unary_base< typename _Ty::argument_type, typename _Ty::result_type> ((_Ty *)0))) == sizeof(char [2]))>  { 


}; 


template<class _Ty, bool 
__T15> 
struct _Refwrap_result2_helper : public _Refwrap_result1< _Ty, (sizeof((tr1::_Has_result_and_arg_type< _Ty> ((_Ty *)0))) == sizeof(char [2]))>  { 


}; 

template<class _Ty> 
struct _Refwrap_result2_helper< _Ty, true>  : public binary_function< typename _Ty::first_argument_type, typename _Ty::second_argument_type, typename _Ty::result_type>  { 




}; 


template<class _Ty, bool 
__T16> 
struct _Refwrap_result2 : public _Refwrap_result1< _Ty, (sizeof((tr1::_Has_result_and_arg_type< _Ty> ((_Ty *)0))) == sizeof(char [2]))>  { 


}; 

template<class _Ty> 
struct _Refwrap_result2< _Ty, true>  : public _Refwrap_result2_helper< _Ty, (sizeof((_Has_binary_base< typename _Ty::first_argument_type, typename _Ty::second_argument_type, typename _Ty::result_type> ((_Ty *)0))) == sizeof(char [2]))>  { 


}; 


template < class _Ty >
 struct _Refwrap_impl
  : _Call_wrapper < _Callable_obj < _Ty, true > >,
   _Refwrap_result2 < _Ty, ( sizeof ( :: std :: tr1 :: _Has_result_and_2arg_type < _Ty > ( ( _Ty * ) 0 ) ) == sizeof ( :: std :: tr1 :: _Yes ) ) >
 {
 _Refwrap_impl ( _Ty & _Val )
  : _Call_wrapper < _Callable_obj < _Ty, true > > ( _Val )
  {
  }
 };

template < class _Rx,
 class _Arg0 >
 struct _Refwrap_impl < _Rx _Arg0 :: * >
  : _Call_wrapper < _Callable_pmd < _Rx _Arg0 :: * const, _Arg0, false > >
 {
 typedef _Rx _Arg0 :: * const _Fty;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_pmd < _Fty, _Arg0, false > > ( _Val )
  {
  }
 };

template < class _Rx,
 class _Arg0 >
 struct _Refwrap_impl < _Rx _Arg0 :: * const >
  : _Call_wrapper < _Callable_pmd < _Rx _Arg0 :: *, _Arg0, false > >
 {
 typedef _Rx _Arg0 :: * _Fty;
 typedef _Rx result_type;
 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_pmd < _Fty, _Arg0, false > > ( _Val )
  {
  }
 };
#line 5 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
      >
 struct _Refwrap_impl < _Rx ( ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( ), false > >








 {
 typedef _Rx ( * _Fty ) ( );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
      >
 struct _Refwrap_impl < _Rx ( * ) ( ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( ), true > >








 {
 typedef _Rx ( * _Fty ) ( );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
      >
 struct _Refwrap_impl < _Rx ( * const ) ( ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * const ) ( ), true > >








 {
 typedef _Rx ( * const _Fty ) ( );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 5 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( _Arg0 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0 ), false > >


   , unary_function < _Arg0, _Rx >





 {
 typedef _Rx ( * _Fty ) ( _Arg0 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( * ) ( _Arg0 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0 ), true > >


   , unary_function < _Arg0, _Rx >





 {
 typedef _Rx ( * _Fty ) ( _Arg0 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( * const ) ( _Arg0 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * const ) ( _Arg0 ), true > >


   , unary_function < _Arg0, _Rx >





 {
 typedef _Rx ( * const _Fty ) ( _Arg0 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 78 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( ), _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( ) const, _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 124 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( ) volatile, _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 147 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( ) const volatile, _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 170 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( ), _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( ) const, _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 216 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( ) volatile, _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 239 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( ) const volatile, _Arg0, true > >


   , unary_function < _Arg0 * const, _Rx >





 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( _Arg0, _Arg1 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1 ), false > >





   , binary_function < _Arg0, _Arg1, _Rx >


 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( * ) ( _Arg0, _Arg1 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1 ), true > >





   , binary_function < _Arg0, _Arg1, _Rx >


 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( * const ) ( _Arg0, _Arg1 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * const ) ( _Arg0, _Arg1 ), true > >





   , binary_function < _Arg0, _Arg1, _Rx >


 {
 typedef _Rx ( * const _Fty ) ( _Arg0, _Arg1 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 78 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1 ), _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1 ) const, _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 124 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1 ) volatile, _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 147 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1 ) const volatile, _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 170 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1 ), _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1 ) const, _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 216 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1 ) volatile, _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 239 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1 ) const volatile, _Arg0, true > >





   , binary_function < _Arg0 * const, _Arg1, _Rx >


 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( _Arg0, _Arg1, _Arg2 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2 ), false > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( * ) ( _Arg0, _Arg1, _Arg2 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2 ), true > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( * const ) ( _Arg0, _Arg1, _Arg2 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * const ) ( _Arg0, _Arg1, _Arg2 ), true > >








 {
 typedef _Rx ( * const _Fty ) ( _Arg0, _Arg1, _Arg2 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 78 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 124 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 147 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 170 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 216 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 239 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( _Arg0, _Arg1, _Arg2, _Arg3 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3 ), false > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3 ), true > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3 ), true > >








 {
 typedef _Rx ( * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 78 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 124 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 147 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 170 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 216 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 239 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ), false > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ), true > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 ), true > >








 {
 typedef _Rx ( * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 78 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 124 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 147 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 170 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 216 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 239 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), false > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), true > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), true > >








 {
 typedef _Rx ( * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 78 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 124 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 147 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 170 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 216 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 239 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), false > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), true > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), true > >








 {
 typedef _Rx ( * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 78 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 124 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 147 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 170 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 216 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 239 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), false > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), true > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), true > >








 {
 typedef _Rx ( * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 78 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 124 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 147 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 170 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 216 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 239 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), false > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), true > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), true > >








 {
 typedef _Rx ( * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 78 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 124 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 147 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 170 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 216 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 239 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 5 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), false > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty _Val )
  : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val )
  {
  }
 };
#line 29 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), true > >








 {
 typedef _Rx ( * _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 52 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) >
  : _Call_wrapper < _Callable_fun <
   _Rx ( * const ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), true > >








 {
 typedef _Rx ( * const _Fty ) ( _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val )
  {
  }
 };
#line 78 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 101 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 124 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 147 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * const ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * const _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 170 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 );
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 193 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 216 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 239 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxrefwrap"
template < class _Rx
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 struct _Refwrap_impl < _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile >
  : _Call_wrapper < _Callable_pmf <
   _Rx ( _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile, _Arg0, true > >








 {
 typedef _Rx ( _Arg0 :: * _Fty ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val )
  {
  }
 };
#line 444 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xrefwrap"
template < class _Ty >
 class reference_wrapper
 : public _Refwrap_impl < _Ty >
 {
public :
 typedef _Refwrap_impl < _Ty > _MyBase;
 typedef _Ty type;

 explicit reference_wrapper ( _Ty & _Val )
  : _MyBase ( _Val )
  {
  }

 operator _Ty & ( ) const
  {
  return ( this -> _Get ( ) );
  }

 _Ty & get ( ) const
  {
  return ( this -> _Get ( ) );
  }
 };


template < class _Ty >
 reference_wrapper < _Ty > ref ( _Ty & _Val )
 {
 return ( reference_wrapper < _Ty > ( _Val ) );
 }

template < class _Ty >
 reference_wrapper < _Ty > ref ( reference_wrapper < _Ty > _Val )
 {
 return ( _Val );
 }

template < class _Ty >
 reference_wrapper < const _Ty > cref ( const _Ty & _Val )
 {
 return ( reference_wrapper < const _Ty > ( _Val ) );
 }

template < class _Ty >
 reference_wrapper < const _Ty > cref ( reference_wrapper < const _Ty > _Val )
 {
 return ( _Val );
 }

}
}
#line 880 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
namespace std { 
namespace tr1 { 



template < class _Rx,
 class _Arg0 >
 _Call_wrapper < _Callable_pmd < _Rx _Arg0 :: * const, _Arg0 > >
  mem_fn ( _Rx _Arg0 :: * const _Pmd )
 {
 return ( _Call_wrapper < _Callable_pmd < _Rx _Arg0 :: * const, _Arg0 > > ( _Pmd ) );
 }
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0 >
 class _Mem_fn1
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >


   , public :: std :: unary_function < _Arg0 *, _Rx >





 {
public :
 typedef _Rx result_type;

 _Mem_fn1 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 30 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ), _Arg0 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( ) )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ),
  _Arg0 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( ), _Arg0 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( ) )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( ),
  _Arg0 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( ), _Arg0 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( ) )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( ),
  _Arg0 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( ), _Arg0 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( ) )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( ),
  _Arg0 > ( _Pm ) );
 }
#line 83 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ) const,
  const _Arg0 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( ) const )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ) const,
  const _Arg0 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( ) const,
  const _Arg0 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( ) const )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( ) const,
  const _Arg0 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( ) const,
  const _Arg0 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( ) const )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( ) const,
  const _Arg0 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( ) const,
  const _Arg0 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( ) const )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( ) const,
  const _Arg0 > ( _Pm ) );
 }
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ) volatile,
  volatile _Arg0 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( ) volatile )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ) volatile,
  volatile _Arg0 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( ) volatile,
  volatile _Arg0 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( ) volatile )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( ) volatile,
  volatile _Arg0 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( ) volatile,
  volatile _Arg0 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( ) volatile )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( ) volatile,
  volatile _Arg0 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( ) volatile,
  volatile _Arg0 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( ) volatile )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( ) volatile,
  volatile _Arg0 > ( _Pm ) );
 }
#line 199 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ) const volatile,
  const volatile _Arg0 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( ) const volatile )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( ) const volatile,
  const volatile _Arg0 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( ) const volatile,
  const volatile _Arg0 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( ) const volatile )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( ) const volatile,
  const volatile _Arg0 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( ) const volatile,
  const volatile _Arg0 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( ) const volatile )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( ) const volatile,
  const volatile _Arg0 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0 >
 _Mem_fn1 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( ) const volatile,
  const volatile _Arg0 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( ) const volatile )
 {
 return ( _Mem_fn1 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( ) const volatile,
  const volatile _Arg0 > ( _Pm ) );
 }
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1 >
 class _Mem_fn2
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >





   , public :: std :: binary_function < _Arg0 *, _Arg1, _Rx >


 {
public :
 typedef _Rx result_type;

 _Mem_fn2 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 30 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ), _Arg0, _Arg1 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1 ) )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ),
  _Arg0, _Arg1 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1 ), _Arg0, _Arg1 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1 ) )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1 ),
  _Arg0, _Arg1 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1 ), _Arg0, _Arg1 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1 ) )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1 ),
  _Arg0, _Arg1 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1 ), _Arg0, _Arg1 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1 ) )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1 ),
  _Arg0, _Arg1 > ( _Pm ) );
 }
#line 83 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) const,
  const _Arg0, _Arg1 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1 ) const )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) const,
  const _Arg0, _Arg1 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1 ) const,
  const _Arg0, _Arg1 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1 ) const )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1 ) const,
  const _Arg0, _Arg1 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1 ) const,
  const _Arg0, _Arg1 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1 ) const )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1 ) const,
  const _Arg0, _Arg1 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1 ) const,
  const _Arg0, _Arg1 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1 ) const )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1 ) const,
  const _Arg0, _Arg1 > ( _Pm ) );
 }
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) volatile,
  volatile _Arg0, _Arg1 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1 ) volatile )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) volatile,
  volatile _Arg0, _Arg1 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1 ) volatile,
  volatile _Arg0, _Arg1 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1 ) volatile )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1 ) volatile,
  volatile _Arg0, _Arg1 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1 ) volatile,
  volatile _Arg0, _Arg1 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1 ) volatile )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1 ) volatile,
  volatile _Arg0, _Arg1 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1 ) volatile,
  volatile _Arg0, _Arg1 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1 ) volatile )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1 ) volatile,
  volatile _Arg0, _Arg1 > ( _Pm ) );
 }
#line 199 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) const volatile,
  const volatile _Arg0, _Arg1 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1 ) const volatile )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1 ) const volatile,
  const volatile _Arg0, _Arg1 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1 ) const volatile,
  const volatile _Arg0, _Arg1 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1 ) const volatile )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1 ) const volatile,
  const volatile _Arg0, _Arg1 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1 ) const volatile,
  const volatile _Arg0, _Arg1 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1 ) const volatile )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1 ) const volatile,
  const volatile _Arg0, _Arg1 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1 >
 _Mem_fn2 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1 ) const volatile,
  const volatile _Arg0, _Arg1 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1 ) const volatile )
 {
 return ( _Mem_fn2 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1 ) const volatile,
  const volatile _Arg0, _Arg1 > ( _Pm ) );
 }
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2 >
 class _Mem_fn3
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >








 {
public :
 typedef _Rx result_type;

 _Mem_fn3 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 30 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ), _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ),
  _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2 ), _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2 ),
  _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2 ), _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2 ),
  _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2 ), _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2 ),
  _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }
#line 83 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) const,
  const _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) const )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) const,
  const _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2 ) const,
  const _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) const )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2 ) const,
  const _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2 ) const,
  const _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) const )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2 ) const,
  const _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2 ) const,
  const _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) const )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2 ) const,
  const _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile,
  volatile _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) volatile )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile,
  volatile _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile,
  volatile _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) volatile )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile,
  volatile _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile,
  volatile _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) volatile )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile,
  volatile _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile,
  volatile _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) volatile )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2 ) volatile,
  volatile _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }
#line 199 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) const volatile )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) const volatile )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) const volatile )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2 >
 _Mem_fn3 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2 ) const volatile )
 {
 return ( _Mem_fn3 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2 > ( _Pm ) );
 }
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 class _Mem_fn4
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >








 {
public :
 typedef _Rx result_type;

 _Mem_fn4 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 30 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ), _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ),
  _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ), _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ),
  _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ), _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ),
  _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ), _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ),
  _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }
#line 83 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) const )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) const )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) const )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) const )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) volatile )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) volatile )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) volatile )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) volatile )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }
#line 199 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) const volatile )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) const volatile )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) const volatile )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Mem_fn4 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3 ) const volatile )
 {
 return ( _Mem_fn4 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3 > ( _Pm ) );
 }
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 class _Mem_fn5
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >








 {
public :
 typedef _Rx result_type;

 _Mem_fn5 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 30 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }
#line 83 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }
#line 199 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Mem_fn5 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile )
 {
 return ( _Mem_fn5 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Pm ) );
 }
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 class _Mem_fn6
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >








 {
public :
 typedef _Rx result_type;

 _Mem_fn6 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 30 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }
#line 83 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }
#line 199 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Mem_fn6 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile )
 {
 return ( _Mem_fn6 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Pm ) );
 }
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 class _Mem_fn7
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >








 {
public :
 typedef _Rx result_type;

 _Mem_fn7 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 30 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }
#line 83 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }
#line 199 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Mem_fn7 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile )
 {
 return ( _Mem_fn7 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Pm ) );
 }
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 class _Mem_fn8
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >








 {
public :
 typedef _Rx result_type;

 _Mem_fn8 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 30 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }
#line 83 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }
#line 199 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Mem_fn8 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile )
 {
 return ( _Mem_fn8 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Pm ) );
 }
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 class _Mem_fn9
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >








 {
public :
 typedef _Rx result_type;

 _Mem_fn9 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 30 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }
#line 83 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }
#line 199 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Mem_fn9 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile )
 {
 return ( _Mem_fn9 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Pm ) );
 }
#line 7 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Pmf, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 class _Mem_fn10
  : public _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > >








 {
public :
 typedef _Rx result_type;

 _Mem_fn10 ( _Pmf _Fx )
  : _Call_wrapper < _Callable_pmf < _Pmf, _Arg0 > > ( _Fx )
  {
  }
 };
#line 30 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ), _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ),
  _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }
#line 83 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const,
  const _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }
#line 141 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) volatile,
  volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }
#line 199 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxmem_fn"
template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __thiscall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __thiscall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __cdecl _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __cdecl _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }

template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __stdcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __stdcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }


template < class _Rx,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Mem_fn10 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
  mem_fn ( _Rx ( __fastcall _Arg0 :: * _Pm ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile )
 {
 return ( _Mem_fn10 < _Rx, _Rx ( __fastcall _Arg0 :: * ) ( _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 ) const volatile,
  const volatile _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > ( _Pm ) );
 }
#line 903 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
typedef int _Unutterable; 
#line 923 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
class bad_function_call : public exception { 



public: explicit bad_function_call(const char * = 0) 
{ 
} 

virtual const char *what() const throw() 
{ 
return "bad function call"; 
} 
}; 

extern __declspec( noreturn ) void __cdecl _Xfunc(); 


template<class _Tx> struct _Get_function_impl; 
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template < class _Rx >
 class _Impl_base0
 {
public :
 virtual _Impl_base0 * _Copy ( void * = 0 ) = 0;
 virtual _Rx _Do_call ( ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base0 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };


template < class _Callable,
 class _Rx,
 class _Alloc >
 class _Impl0
  : public _Impl_base0 < _Rx >
 {
public :
 typedef _Impl0 _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl0 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Callee ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl0 ( )
  {
  }

 virtual _Impl_base0 < _Rx > * _Copy ( void * _Where = 0 )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl0 ( * this );
  return ( ( _Impl_base0 < _Rx > * ) _Where );
  }

 _Rx _Do_call ( )
  {
  return ( _Callee . template _ApplyX < _Rx > ( ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Al . destroy ( this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 _Myalty _Myal;
 };


template < class _Ret >
 class _Function_impl0








 {
 typedef _Function_impl0 < _Ret > _Myt;
 typedef _Impl_base0 < _Ret > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myt & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( ) );
  }

 template < class _Fret,
  class _Alloc >
  void _Reset ( _Fret ( * const _Val ) ( ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( * const ) ( ) > _MyWrapper;
  typedef _Impl0 < _MyWrapper, _Ret, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fty,
  class _Alloc >
  void _Reset ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl0 < _MyWrapper, _Ret, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }




























































































































 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   {
   return;
   }

  if ( _Local ( ) )
   {
   if ( _Right . _Local ( ) )
    {
    _Myt _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
   }
  else
   {
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    {
    :: std :: swap ( _Impl, _Right . _Impl );
    }
   }
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 typedef void ( * _Pfnty ) ( );
 union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  } _Space;

 _Ptrt * _Impl;
 };
#line 385 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template<class _Ret> 
struct _Get_function_impl< _Ret (void)>  { 

typedef _Function_impl0< _Ret>  _Type; 
}; 
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template < class _Rx, class _Arg0 >
 class _Impl_base1
 {
public :
 virtual _Impl_base1 * _Copy ( void * = 0 ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base1 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };


template < class _Callable,
 class _Rx, class _Arg0,
 class _Alloc >
 class _Impl1
  : public _Impl_base1 < _Rx, _Arg0 >
 {
public :
 typedef _Impl1 _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl1 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Callee ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl1 ( )
  {
  }

 virtual _Impl_base1 < _Rx, _Arg0 > * _Copy ( void * _Where = 0 )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl1 ( * this );
  return ( ( _Impl_base1 < _Rx, _Arg0 > * ) _Where );
  }

 _Rx _Do_call ( _Arg0 _Ax0 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Al . destroy ( this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 _Myalty _Myal;
 };


template < class _Ret, class _Arg0 >
 class _Function_impl1


  : public :: std :: unary_function < _Arg0, _Ret >





 {
 typedef _Function_impl1 < _Ret, _Arg0 > _Myt;
 typedef _Impl_base1 < _Ret, _Arg0 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myt & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( ) );
  }

 template < class _Fret, class _Farg0,
  class _Alloc >
  void _Reset ( _Fret ( * const _Val ) ( _Farg0 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( * const ) ( _Farg0 ) > _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fty,
  class _Alloc >
  void _Reset ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }


 template < class _Fret,
  class _Farg0,
  class _Alloc >
  void _Reset ( _Fret _Farg0 :: * const _Val, _Alloc _Ax )
  {
  typedef _Callable_pmd < _Fret _Farg0 :: * const, _Arg0 > _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



 template < class _Fret, class _Farg0,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( ), _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( _Farg0 :: * const ) ( ), _Arg0 >
   _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( ) const, _Arg0 > _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( ) volatile, _Arg0 > _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( ) const volatile, _Arg0 >
   _MyWrapper;
  typedef _Impl1 < _MyWrapper, _Ret, _Arg0, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }


 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   {
   return;
   }

  if ( _Local ( ) )
   {
   if ( _Right . _Local ( ) )
    {
    _Myt _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
   }
  else
   {
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    {
    :: std :: swap ( _Impl, _Right . _Impl );
    }
   }
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 typedef void ( * _Pfnty ) ( );
 union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  } _Space;

 _Ptrt * _Impl;
 };
#line 385 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template<class _Ret, class _Arg0> 
struct _Get_function_impl< _Ret (_Arg0)>  { 

typedef _Function_impl1< _Ret, _Arg0>  _Type; 
}; 
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1 >
 class _Impl_base2
 {
public :
 virtual _Impl_base2 * _Copy ( void * = 0 ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base2 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };


template < class _Callable,
 class _Rx, class _Arg0, class _Arg1,
 class _Alloc >
 class _Impl2
  : public _Impl_base2 < _Rx, _Arg0, _Arg1 >
 {
public :
 typedef _Impl2 _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl2 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Callee ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl2 ( )
  {
  }

 virtual _Impl_base2 < _Rx, _Arg0, _Arg1 > * _Copy ( void * _Where = 0 )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl2 ( * this );
  return ( ( _Impl_base2 < _Rx, _Arg0, _Arg1 > * ) _Where );
  }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Al . destroy ( this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 _Myalty _Myal;
 };


template < class _Ret, class _Arg0, class _Arg1 >
 class _Function_impl2





  : public :: std :: binary_function < _Arg0, _Arg1, _Ret >


 {
 typedef _Function_impl2 < _Ret, _Arg0, _Arg1 > _Myt;
 typedef _Impl_base2 < _Ret, _Arg0, _Arg1 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myt & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset ( _Fret ( * const _Val ) ( _Farg0, _Farg1 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( * const ) ( _Farg0, _Farg1 ) > _MyWrapper;
  typedef _Impl2 < _MyWrapper, _Ret, _Arg0, _Arg1, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fty,
  class _Alloc >
  void _Reset ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl2 < _MyWrapper, _Ret, _Arg0, _Arg1, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



























 template < class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1 ), _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( _Farg0 :: * const ) ( _Farg1 ), _Arg0 >
   _MyWrapper;
  typedef _Impl2 < _MyWrapper, _Ret, _Arg0, _Arg1, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1 ) const, _Arg0 > _MyWrapper;
  typedef _Impl2 < _MyWrapper, _Ret, _Arg0, _Arg1, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1 ) volatile, _Arg0 > _MyWrapper;
  typedef _Impl2 < _MyWrapper, _Ret, _Arg0, _Arg1, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1 ) const volatile, _Arg0 >
   _MyWrapper;
  typedef _Impl2 < _MyWrapper, _Ret, _Arg0, _Arg1, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }


 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   {
   return;
   }

  if ( _Local ( ) )
   {
   if ( _Right . _Local ( ) )
    {
    _Myt _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
   }
  else
   {
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    {
    :: std :: swap ( _Impl, _Right . _Impl );
    }
   }
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 typedef void ( * _Pfnty ) ( );
 union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  } _Space;

 _Ptrt * _Impl;
 };
#line 385 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template<class _Ret, class _Arg0, class _Arg1> 
struct _Get_function_impl< _Ret (_Arg0, _Arg1)>  { 

typedef _Function_impl2< _Ret, _Arg0, _Arg1>  _Type; 
}; 
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2 >
 class _Impl_base3
 {
public :
 virtual _Impl_base3 * _Copy ( void * = 0 ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base3 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };


template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2,
 class _Alloc >
 class _Impl3
  : public _Impl_base3 < _Rx, _Arg0, _Arg1, _Arg2 >
 {
public :
 typedef _Impl3 _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl3 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Callee ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl3 ( )
  {
  }

 virtual _Impl_base3 < _Rx, _Arg0, _Arg1, _Arg2 > * _Copy ( void * _Where = 0 )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl3 ( * this );
  return ( ( _Impl_base3 < _Rx, _Arg0, _Arg1, _Arg2 > * ) _Where );
  }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Al . destroy ( this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 _Myalty _Myal;
 };


template < class _Ret, class _Arg0, class _Arg1, class _Arg2 >
 class _Function_impl3








 {
 typedef _Function_impl3 < _Ret, _Arg0, _Arg1, _Arg2 > _Myt;
 typedef _Impl_base3 < _Ret, _Arg0, _Arg1, _Arg2 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myt & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset ( _Fret ( * const _Val ) ( _Farg0, _Farg1, _Farg2 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( * const ) ( _Farg0, _Farg1, _Farg2 ) > _MyWrapper;
  typedef _Impl3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fty,
  class _Alloc >
  void _Reset ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



























 template < class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ), _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2 ), _Arg0 >
   _MyWrapper;
  typedef _Impl3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) const, _Arg0 > _MyWrapper;
  typedef _Impl3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) volatile, _Arg0 > _MyWrapper;
  typedef _Impl3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) const volatile, _Arg0 >
   _MyWrapper;
  typedef _Impl3 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }


 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   {
   return;
   }

  if ( _Local ( ) )
   {
   if ( _Right . _Local ( ) )
    {
    _Myt _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
   }
  else
   {
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    {
    :: std :: swap ( _Impl, _Right . _Impl );
    }
   }
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 typedef void ( * _Pfnty ) ( );
 union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  } _Space;

 _Ptrt * _Impl;
 };
#line 385 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template<class _Ret, class _Arg0, class _Arg1, class _Arg2> 
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2)>  { 

typedef _Function_impl3< _Ret, _Arg0, _Arg1, _Arg2>  _Type; 
}; 
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 class _Impl_base4
 {
public :
 virtual _Impl_base4 * _Copy ( void * = 0 ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base4 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };


template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3,
 class _Alloc >
 class _Impl4
  : public _Impl_base4 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3 >
 {
public :
 typedef _Impl4 _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl4 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Callee ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl4 ( )
  {
  }

 virtual _Impl_base4 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3 > * _Copy ( void * _Where = 0 )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl4 ( * this );
  return ( ( _Impl_base4 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3 > * ) _Where );
  }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Al . destroy ( this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 _Myalty _Myal;
 };


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 class _Function_impl4








 {
 typedef _Function_impl4 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3 > _Myt;
 typedef _Impl_base4 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myt & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset ( _Fret ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3 ) > _MyWrapper;
  typedef _Impl4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fty,
  class _Alloc >
  void _Reset ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



























 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ), _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ), _Arg0 >
   _MyWrapper;
  typedef _Impl4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const, _Arg0 > _MyWrapper;
  typedef _Impl4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) volatile, _Arg0 > _MyWrapper;
  typedef _Impl4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const volatile, _Arg0 >
   _MyWrapper;
  typedef _Impl4 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }


 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   {
   return;
   }

  if ( _Local ( ) )
   {
   if ( _Right . _Local ( ) )
    {
    _Myt _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
   }
  else
   {
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    {
    :: std :: swap ( _Impl, _Right . _Impl );
    }
   }
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 typedef void ( * _Pfnty ) ( );
 union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  } _Space;

 _Ptrt * _Impl;
 };
#line 385 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template<class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3)>  { 

typedef _Function_impl4< _Ret, _Arg0, _Arg1, _Arg2, _Arg3>  _Type; 
}; 
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 class _Impl_base5
 {
public :
 virtual _Impl_base5 * _Copy ( void * = 0 ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base5 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };


template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4,
 class _Alloc >
 class _Impl5
  : public _Impl_base5 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
 {
public :
 typedef _Impl5 _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl5 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Callee ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl5 ( )
  {
  }

 virtual _Impl_base5 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > * _Copy ( void * _Where = 0 )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl5 ( * this );
  return ( ( _Impl_base5 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > * ) _Where );
  }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Al . destroy ( this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 _Myalty _Myal;
 };


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 class _Function_impl5








 {
 typedef _Function_impl5 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _Myt;
 typedef _Impl_base5 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myt & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset ( _Fret ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ) > _MyWrapper;
  typedef _Impl5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fty,
  class _Alloc >
  void _Reset ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



























 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Arg0 >
   _MyWrapper;
  typedef _Impl5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const, _Arg0 > _MyWrapper;
  typedef _Impl5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile, _Arg0 > _MyWrapper;
  typedef _Impl5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile, _Arg0 >
   _MyWrapper;
  typedef _Impl5 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }


 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   {
   return;
   }

  if ( _Local ( ) )
   {
   if ( _Right . _Local ( ) )
    {
    _Myt _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
   }
  else
   {
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    {
    :: std :: swap ( _Impl, _Right . _Impl );
    }
   }
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 typedef void ( * _Pfnty ) ( );
 union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  } _Space;

 _Ptrt * _Impl;
 };
#line 385 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template<class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4)>  { 

typedef _Function_impl5< _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4>  _Type; 
}; 
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 class _Impl_base6
 {
public :
 virtual _Impl_base6 * _Copy ( void * = 0 ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base6 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };


template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5,
 class _Alloc >
 class _Impl6
  : public _Impl_base6 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
 {
public :
 typedef _Impl6 _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl6 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Callee ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl6 ( )
  {
  }

 virtual _Impl_base6 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > * _Copy ( void * _Where = 0 )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl6 ( * this );
  return ( ( _Impl_base6 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > * ) _Where );
  }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Al . destroy ( this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 _Myalty _Myal;
 };


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 class _Function_impl6








 {
 typedef _Function_impl6 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _Myt;
 typedef _Impl_base6 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myt & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset ( _Fret ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) > _MyWrapper;
  typedef _Impl6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fty,
  class _Alloc >
  void _Reset ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



























 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Arg0 >
   _MyWrapper;
  typedef _Impl6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const, _Arg0 > _MyWrapper;
  typedef _Impl6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile, _Arg0 > _MyWrapper;
  typedef _Impl6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile, _Arg0 >
   _MyWrapper;
  typedef _Impl6 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }


 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   {
   return;
   }

  if ( _Local ( ) )
   {
   if ( _Right . _Local ( ) )
    {
    _Myt _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
   }
  else
   {
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    {
    :: std :: swap ( _Impl, _Right . _Impl );
    }
   }
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 typedef void ( * _Pfnty ) ( );
 union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  } _Space;

 _Ptrt * _Impl;
 };
#line 385 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template<class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5)>  { 

typedef _Function_impl6< _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5>  _Type; 
}; 
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 class _Impl_base7
 {
public :
 virtual _Impl_base7 * _Copy ( void * = 0 ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base7 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };


template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6,
 class _Alloc >
 class _Impl7
  : public _Impl_base7 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
 {
public :
 typedef _Impl7 _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl7 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Callee ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl7 ( )
  {
  }

 virtual _Impl_base7 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > * _Copy ( void * _Where = 0 )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl7 ( * this );
  return ( ( _Impl_base7 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > * ) _Where );
  }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Al . destroy ( this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 _Myalty _Myal;
 };


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 class _Function_impl7








 {
 typedef _Function_impl7 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _Myt;
 typedef _Impl_base7 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myt & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset ( _Fret ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) > _MyWrapper;
  typedef _Impl7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fty,
  class _Alloc >
  void _Reset ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



























 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Arg0 >
   _MyWrapper;
  typedef _Impl7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const, _Arg0 > _MyWrapper;
  typedef _Impl7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile, _Arg0 > _MyWrapper;
  typedef _Impl7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile, _Arg0 >
   _MyWrapper;
  typedef _Impl7 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }


 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   {
   return;
   }

  if ( _Local ( ) )
   {
   if ( _Right . _Local ( ) )
    {
    _Myt _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
   }
  else
   {
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    {
    :: std :: swap ( _Impl, _Right . _Impl );
    }
   }
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 typedef void ( * _Pfnty ) ( );
 union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  } _Space;

 _Ptrt * _Impl;
 };
#line 385 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template<class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6)>  { 

typedef _Function_impl7< _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6>  _Type; 
}; 
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 class _Impl_base8
 {
public :
 virtual _Impl_base8 * _Copy ( void * = 0 ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base8 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };


template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7,
 class _Alloc >
 class _Impl8
  : public _Impl_base8 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
 {
public :
 typedef _Impl8 _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl8 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Callee ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl8 ( )
  {
  }

 virtual _Impl_base8 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > * _Copy ( void * _Where = 0 )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl8 ( * this );
  return ( ( _Impl_base8 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > * ) _Where );
  }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Al . destroy ( this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 _Myalty _Myal;
 };


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 class _Function_impl8








 {
 typedef _Function_impl8 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _Myt;
 typedef _Impl_base8 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myt & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset ( _Fret ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) > _MyWrapper;
  typedef _Impl8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fty,
  class _Alloc >
  void _Reset ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



























 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Arg0 >
   _MyWrapper;
  typedef _Impl8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const, _Arg0 > _MyWrapper;
  typedef _Impl8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile, _Arg0 > _MyWrapper;
  typedef _Impl8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile, _Arg0 >
   _MyWrapper;
  typedef _Impl8 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }


 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   {
   return;
   }

  if ( _Local ( ) )
   {
   if ( _Right . _Local ( ) )
    {
    _Myt _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
   }
  else
   {
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    {
    :: std :: swap ( _Impl, _Right . _Impl );
    }
   }
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 typedef void ( * _Pfnty ) ( );
 union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  } _Space;

 _Ptrt * _Impl;
 };
#line 385 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template<class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7)>  { 

typedef _Function_impl8< _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7>  _Type; 
}; 
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 class _Impl_base9
 {
public :
 virtual _Impl_base9 * _Copy ( void * = 0 ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base9 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };


template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8,
 class _Alloc >
 class _Impl9
  : public _Impl_base9 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
 {
public :
 typedef _Impl9 _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl9 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Callee ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl9 ( )
  {
  }

 virtual _Impl_base9 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > * _Copy ( void * _Where = 0 )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl9 ( * this );
  return ( ( _Impl_base9 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > * ) _Where );
  }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Al . destroy ( this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 _Myalty _Myal;
 };


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 class _Function_impl9








 {
 typedef _Function_impl9 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _Myt;
 typedef _Impl_base9 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myt & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset ( _Fret ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) > _MyWrapper;
  typedef _Impl9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fty,
  class _Alloc >
  void _Reset ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



























 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Arg0 >
   _MyWrapper;
  typedef _Impl9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const, _Arg0 > _MyWrapper;
  typedef _Impl9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile, _Arg0 > _MyWrapper;
  typedef _Impl9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile, _Arg0 >
   _MyWrapper;
  typedef _Impl9 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }


 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   {
   return;
   }

  if ( _Local ( ) )
   {
   if ( _Right . _Local ( ) )
    {
    _Myt _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
   }
  else
   {
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    {
    :: std :: swap ( _Impl, _Right . _Impl );
    }
   }
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 typedef void ( * _Pfnty ) ( );
 union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  } _Space;

 _Ptrt * _Impl;
 };
#line 385 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template<class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8)>  { 

typedef _Function_impl9< _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8>  _Type; 
}; 
#line 9 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template < class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 class _Impl_base10
 {
public :
 virtual _Impl_base10 * _Copy ( void * = 0 ) = 0;
 virtual _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 ) = 0;
 virtual const type_info & _Target_type ( ) const = 0;
 virtual void _Delete_this ( bool ) = 0;

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Target_type ( ) == _Info ? _Get ( ) : 0 );
  }

 virtual ~ _Impl_base10 ( )
  {
  }

private :
 virtual const void * _Get ( ) const = 0;
 };


template < class _Callable,
 class _Rx, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9,
 class _Alloc >
 class _Impl10
  : public _Impl_base10 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 >
 {
public :
 typedef _Impl10 _Myty;
 typedef typename _Alloc :: template rebind < _Myty > :: other _Myalty;

 _Impl10 ( typename _Callable :: _MyTy & _Val,
  _Myalty _Ax = _Myalty ( ) )
  : _Callee ( _Val ), _Myal ( _Ax )
  {
  }

 virtual ~ _Impl10 ( )
  {
  }

 virtual _Impl_base10 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > * _Copy ( void * _Where = 0 )
  {
  if ( _Where == 0 )
   _Where = _Myal . allocate ( 1 );
  new ( _Where ) _Impl10 ( * this );
  return ( ( _Impl_base10 < _Rx, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > * ) _Where );
  }

 _Rx _Do_call ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
  {
  return ( _Callee . template _ApplyX < _Rx > ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) );
  }

 const type_info & _Target_type ( ) const
  {
  return ( typeid ( typename _Callable :: _MyTy ) );
  }

private :
 const void * _Get ( ) const
  {
  return ( & _Callee . _Get ( ) );
  }

 virtual void _Delete_this ( bool _Deallocate )
  {
  _Myalty _Al = _Myal;
  _Al . destroy ( this );
  if ( _Deallocate )
   _Al . deallocate ( this, 1 );
  }

 _Callable _Callee;
 _Myalty _Myal;
 };


template < class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 class _Function_impl10








 {
 typedef _Function_impl10 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _Myt;
 typedef _Impl_base10 < _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _Ptrt;

public :
 typedef _Ret result_type;

 _Ret operator ( ) ( _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 ) const
  {
  if ( _Impl == 0 )
   _Xfunc ( );
  return ( _Impl -> _Do_call ( _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) );
  }

 bool _Empty ( ) const
  {
  return ( _Impl == 0 );
  }

protected :
 void _Reset ( )
  {
  _Set ( 0 );
  }

 void _Reset ( const _Myt & _Right )
  {
  if ( _Right . _Impl == 0 )
   _Set ( 0 );
  else if ( _Right . _Local ( ) )
   _Set ( _Right . _Impl -> _Copy ( ( void * ) & _Space ) );
  else
   _Set ( _Right . _Impl -> _Copy ( ) );
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset ( _Fret ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Alloc _Ax )
  {
  typedef _Callable_fun < _Fret ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) > _MyWrapper;
  typedef _Impl10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fty,
  class _Alloc >
  void _Reset ( _Fty _Val, _Alloc _Ax )
  {
  typedef _Callable_obj < _Fty > _MyWrapper;
  typedef _Impl10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }



























 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Alloc _Ax )
  {
  typedef _Callable_pmf < _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Arg0 >
   _MyWrapper;
  typedef _Impl10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const, _Arg0 > _MyWrapper;
  typedef _Impl10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile, _Arg0 > _MyWrapper;
  typedef _Impl10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }

 template < class _Fret, class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
  class _Alloc >
  void _Reset ( _Fret ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile,
   _Alloc _Ax )
  {
  typedef _Callable_pmf <
   _Fret ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile, _Arg0 >
   _MyWrapper;
  typedef _Impl10 < _MyWrapper, _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9, _Alloc > _Myimpl;

  if ( sizeof ( _Myimpl ) <= sizeof ( _Space ) )
   {
   new ( ( void * ) & _Space ) _Myimpl ( _Val );
   _Set ( ( _Ptrt * ) & _Space );
   }
  else
   {
   typename _Alloc :: template rebind < _Myimpl > :: other _Al = _Ax;
   _Myimpl * _Ptr = _Al . allocate ( 1 );

   new ( _Ptr ) _Myimpl ( _Val, _Al );
   _Set ( _Ptr );
   }
  }


 void _Tidy ( )
  {
  if ( _Impl != 0 )
   {
   _Impl -> _Delete_this ( ! _Local ( ) );
   _Impl = 0;
   }
  }

 void _Swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   {
   return;
   }

  if ( _Local ( ) )
   {
   if ( _Right . _Local ( ) )
    {
    _Myt _Temp;
    _Temp . _Reset ( * this );
    _Tidy ( );
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Reset ( _Temp );
    _Temp . _Tidy ( );
    }
   else
    {
    _Ptrt * _Temp = _Right . _Impl;
    _Right . _Reset ( * this );
    _Tidy ( );
    _Set ( _Temp );
    }
   }
  else
   {
   if ( _Right . _Local ( ) )
    {
    _Ptrt * _Temp = _Impl;
    _Reset ( _Right );
    _Right . _Tidy ( );
    _Right . _Set ( _Temp );
    }
   else
    {
    :: std :: swap ( _Impl, _Right . _Impl );
    }
   }
  }

 const type_info & _Target_type ( ) const
  {
  return ( _Impl ? _Impl -> _Target_type ( ) : typeid ( void ) );
  }

 const void * _Target ( const type_info & _Info ) const
  {
  return ( _Impl ? _Impl -> _Target ( _Info ) : 0 );
  }

private :
 void _Set ( _Ptrt * _Ptr )
  {
  _Impl = _Ptr;
  }

 bool _Local ( ) const
  {
  return ( ( void * ) _Impl == ( void * ) & _Space );
  }

 typedef void ( * _Pfnty ) ( );
 union
  {
  _Pfnty _Pfn [ 3 ];
  void * _Pobj [ 3 ];
  long double _Ldbl;
  } _Space;

 _Ptrt * _Impl;
 };
#line 385 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxfunction"
template<class _Ret, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
struct _Get_function_impl< _Ret (_Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9)>  { 

typedef _Function_impl10< _Ret, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9>  _Type; 
}; 
#line 948 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
template < class _Fty >
 class function
  : public _Get_function_impl < _Fty > :: _Type
 {
public :
 typedef function < _Fty > _Myt;
 typedef typename _Get_function_impl < _Fty > :: _Type _Mybase;
 typedef std :: allocator < int > _Alty0;

 explicit function ( )
  {
  this -> _Reset ( );
  }

 function ( const _Myt & _Right )
  {
  this -> _Reset ( ( const _Mybase & ) _Right );
  }

 template < class _Fx >
  function ( _Fx _Func )
  {
  this -> _Reset ( _Func, _Alty0 ( ) );
  }

 template < class _Fx,
  class _Alloc >
  function ( _Fx _Func, _Alloc _Ax )
  {
  this -> _Reset ( _Func, _Ax );
  }

 template < class _Fx >
  function ( reference_wrapper < _Fx > _Func )
  {
  this -> _Reset ( _Func . get ( ), _Alty0 ( ) );
  }

 template < class _Fx,
  class _Alloc >
  function ( reference_wrapper < _Fx > _Func, _Alloc _Ax )
  {
  this -> _Reset ( _Func . get ( ), _Ax );
  }

 function ( _Unutterable )
  {
  this -> _Reset ( );
  }

 ~ function ( )
  {
  this -> _Tidy ( );
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  if ( this != & _Right )
   {
   this -> _Tidy ( );
   this -> _Reset ( ( const _Mybase & ) _Right );
   }
  return ( * this );
  }

 template < class _Fx >
  _Myt & operator = ( _Fx _Func )
  {
  this -> _Tidy ( );
  this -> _Reset ( _Func, _Alty0 ( ) );
  return ( * this );
  }

 function & operator = ( _Unutterable )
  {
  this -> _Tidy ( );
  this -> _Reset ( );
  return ( * this );
  }

 template < class _Fx >
  _Myt & operator = ( reference_wrapper < _Fx > _Func )
  {
  this -> _Reset ( _Func . get ( ), _Alty0 ( ) );
  return ( * this );
  }

 template < class _Fx,
  class _Alloc >
  void assign ( _Fx _Func, _Alloc _Ax )
  {
  this -> _Reset ( _Func, _Ax );
  }

 template < class _Fx,
  class _Alloc >
  void assign ( reference_wrapper < _Fx > _Func, _Alloc _Ax )
  {
  this -> _Reset ( _Func . get ( ), _Ax );
  }

 void swap ( _Myt & _Right )
  {
  this -> _Swap ( _Right );
  }


 operator :: std :: _Bool_type ( ) const
  {
  return ( ! this -> _Empty ( ) ? ( & :: std :: _Bool_struct :: _Member ) : 0 );
  }

 const type_info & target_type ( ) const
  {
  return ( this -> _Target_type ( ) );
  }

 template < class _Fty2 >
  _Fty2 * target ( )
  {
  return ( ( _Fty2 * ) this -> _Target ( typeid ( _Fty2 ) ) );
  }

 template < class _Fty2 >
  const _Fty2 * target ( ) const
  {
  return ( ( const _Fty2 * ) this -> _Target ( typeid ( _Fty2 ) ) );
  }

private :

 template < class _Fty2 >
  void operator == ( const function < _Fty2 > & );
 template < class _Fty2 >
  void operator != ( const function < _Fty2 > & );
 };


template < class _Fty >
 void swap ( function < _Fty > & _Left, function < _Fty > & _Right )
 {
 _Left . swap ( _Right );
 }


template < class _Fty >
 bool operator == ( const function < _Fty > & _Other, _Unutterable )
 {
 return ( ! _Other );
 }

template < class _Fty >
 bool operator == ( _Unutterable _Npc, const function < _Fty > & _Other )
 {
 return ( operator == ( _Other, _Npc ) );
 }

template < class _Fty >
 bool operator != ( const function < _Fty > & _Other, _Unutterable _Npc )
 {
 return ( ! operator == ( _Other, _Npc ) );
 }

template < class _Fty >
 bool operator != ( _Unutterable _Npc, const function < _Fty > & _Other )
 {
 return ( ! operator == ( _Other, _Npc ) );
 }
#line 1127 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
template<int _Nx> 
class _Ph { 

}; 

template<class _Tx> 
struct is_placeholder { 

static const int value = 0; 
}; 

template<int _Nx> 
struct is_placeholder< _Ph< _Nx> >  { 

static const int value = _Nx; 
}; 


struct _Notforced { 

}; 

template<class _Override, class 
_Natural> 
struct _Bindret { 

typedef _Override _Type; 
}; 

template<class _Natural> 
struct _Bindret< _Notforced, _Natural>  { 

typedef _Natural _Type; 
}; 


template < class _Ret,
 class _BindN >
 class _Bind
 {
public :
 typedef typename _BindN :: _MyTy _MyTy;
 typedef _BindN _MyBind;

 _Bind ( _BindN _B0 )
  : _Bx ( _B0 )
  {
  }
















































































































































































































 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }




 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }






































































































































































































































































































































































































template < class _Carg0 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


























































































































































































template < class _Carg0 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }

































































































































































































































































































































































































template < class _Carg0, class _Carg1 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


























































































































































































template < class _Carg0, class _Carg1 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


























































































































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }















































































































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }





























































































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


























































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Nil &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _Nil_obj, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


























































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Nil &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _Nil_obj, _Nil_obj, _Nil_obj ) );
 }


























































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Nil &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _Nil_obj, _Nil_obj ) );
 }



























































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Nil & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _Nil_obj ) );
 }




























































































































































































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }



























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
    _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }
























































































































































































template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >


 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 ) const
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }


template < class _Carg0, class _Carg1, class _Carg2, class _Carg3, class _Carg4, class _Carg5, class _Carg6, class _Carg7, class _Carg8, class _Carg9 >

 typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type
  operator ( ) ( const _Carg0 & _CA0, const _Carg1 & _CA1, const _Carg2 & _CA2, const _Carg3 & _CA3, const _Carg4 & _CA4, _Carg5 & _CA5, _Carg6 & _CA6, _Carg7 & _CA7, _Carg8 & _CA8, _Carg9 & _CA9 )
 {
 typedef typename _Bindret < _Ret,
  typename _MyBind :: template _Return <
   const _Carg0 &, const _Carg1 &, const _Carg2 &, const _Carg3 &, const _Carg4 &, _Carg5 &, _Carg6 &, _Carg7 &, _Carg8 &, _Carg9 & > :: _Type > :: _Type _Rx;
 return ( _Bx . template _ApplyX < _Rx > ( _CA0, _CA1, _CA2, _CA3, _CA4, _CA5, _CA6, _CA7, _CA8, _CA9 ) );
 }




































































































































private :
 _BindN _Bx;
 };
#line 1184 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
template<class _Tx> 
struct is_bind_expression { 

static const bool value = false; 
}; 

template<class _Rx, class 
_BindN> 
struct is_bind_expression< _Bind< _Rx, _BindN> >  { 

static const bool value = true; 
}; 


template<bool _Expr, int 
_Nx> struct _Binder; 



template<> struct _Binder< true, 0>  { 

template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static typename _Arg ::
   _MyBind :: template _Return < _Barg0 &, _Barg1 &, _Barg2 &, _Barg3 &, _Barg4 &, _Barg5 &, _Barg6 &, _Barg7 &, _Barg8 &, _Barg9 & > :: _Type
    _Get ( _Arg _Ax, _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( _Ax ( _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) );
  }

template<class _Arg, class 
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
struct _Ret { 



typedef typename _Arg::_MyBind::template _Return< _Barg0, _Barg1, _Barg2, _Barg3, _Barg4, _Barg5, _Barg6, _Barg7, _Barg8, _Barg9> ::_Type _Type; 
}; 
}; 


template<> struct _Binder< false, 0>  { 

template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Arg & _Get ( _Arg & _Val, _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( _Val );
  }
template<class _Arg, class 
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
struct _Ret { 

typedef _Arg &_Type; 
}; 
}; 
#line 206 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Callable >
 class _Bind0
 {
public :
 typedef _Callable _MyCallable;
 typedef typename _Callable :: _MyTy _MyTy;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( ) > :: type _Type;
  };

 _Bind0 ( _MyTy & _Val )
  : _Callee ( _Val )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 _Bx0, _Barg1 _Bx1, _Barg2 _Bx2, _Barg3 _Bx3, _Barg4 _Bx4, _Barg5 _Bx5, _Barg6 _Bx6, _Barg7 _Bx7, _Barg8 _Bx8, _Barg9 _Bx9 ) const
  {
  return ( _Callee . template _ApplyX < _Ret > ( ) );
  }

 _MyCallable _Callee;
 };
#line 302 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<class _Ret, class _BindTy> 
struct _Result_of0< _Bind< _Ret, _BindTy> >  { 

typedef _Ret _Type; 
}; 

template<class _BindTy> 
struct _Result_of0< _Bind< _Notforced, _BindTy> >  { 


typedef typename _BindTy::template _Return< _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
}; 

template < class _Ret,
 class _Fty
      >
 _Bind < _Ret,
  _Bind0 < _Callable_obj < _Fty > > >
   bind ( _Fty _Val )
 {
 typedef _Bind0 < _Callable_obj < _Fty > > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val ) ) );
 }

template < class _Fty
      >
 _Bind < _Notforced,
  _Bind0 < _Callable_obj < _Fty > > >
   bind ( _Fty _Val )
 {
 typedef _Bind0 < _Callable_obj < _Fty > > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val ) ) );
 }


template < class _Ret,
 class _Rx >







 _Bind < _Ret,
  _Bind0 < _Callable_fun < _Rx ( * const ) ( ) > > >
   bind ( _Rx ( * const _Val ) ( ) )
 {
 typedef _Callable_fun < _Rx ( * const ) ( ) > _Callable;
 typedef _Bind0 < _Callable > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val ) ) );
 }
#line 356 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Rx >






 _Bind < _Notforced,
  _Bind0 < _Callable_fun < _Rx ( * const ) ( ) > > >
   bind ( _Rx ( * const _Val ) ( ) )
 {
 typedef _Callable_fun < _Rx ( * const ) ( ) > _Callable;
 typedef _Bind0 < _Callable > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val ) ) );
 }
#line 237 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<> struct _Binder< false, 1>  { 

template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg0 & _Get ( _Arg, _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( _Bx0 );
  }

template<class _Arg, class 
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
struct _Ret { 

typedef _Barg0 _Type; 
}; 
}; 

template < class _Callable,
 class _Arg0 >
 class _Bind1
  : public _Bind0 < _Callable >
 {
public :
 typedef _Bind1 < _Callable, _Arg0 > _Self;
 typedef _Binder < is_bind_expression < _Arg0 > :: value,
  is_placeholder < _Arg0 > :: value > _Binder0;
 typedef _Arg0 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind0 < _Callable > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0 ) > :: type _Type;
  };

 _Bind1 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0 )
  : _Vx0 ( _Ax0 ), _Bind0 < _Callable > ( _Val )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg0 _Vx0;
 };


namespace placeholders { 
static _Ph< 1>  _1; 
}
#line 302 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<class _Ret, class _BindTy, class _Arg0> 
struct _Result_of1< _Bind< _Ret, _BindTy> , _Arg0>  { 

typedef _Ret _Type; 
}; 

template<class _BindTy, class _Arg0> 
struct _Result_of1< _Bind< _Notforced, _BindTy> , _Arg0>  { 


typedef typename _BindTy::template _Return< _Arg0, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
}; 

template < class _Ret,
 class _Fty
 , class _Arg0 >
 _Bind < _Ret,
  _Bind1 < _Callable_obj < _Fty >, _Arg0 > >
   bind ( _Fty _Val, _Arg0 _Ax0 )
 {
 typedef _Bind1 < _Callable_obj < _Fty >, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }

template < class _Fty
 , class _Arg0 >
 _Bind < _Notforced,
  _Bind1 < _Callable_obj < _Fty >, _Arg0 > >
   bind ( _Fty _Val, _Arg0 _Ax0 )
 {
 typedef _Bind1 < _Callable_obj < _Fty >, _Arg0 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 341 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret
 , class _Farg0
 , class _Arg0,
 class _Rx >

 _Bind < _Ret,
  _Bind1 < _Callable_fun < _Rx ( * const ) ( _Farg0 ) >, _Arg0 > >
   bind ( _Rx ( * const _Val ) ( _Farg0 ), _Arg0 _Ax0 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0 ) > _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 359 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Farg0
 , class _Arg0,
 class _Rx >

 _Bind < _Notforced,
  _Bind1 < _Callable_fun < _Rx ( * const ) ( _Farg0 ) >, _Arg0 > >
   bind ( _Rx ( * const _Val ) ( _Farg0 ), _Arg0 _Ax0 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0 ) > _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 373 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret,
 class _Farg0,
 class _Arg0,
 class _Rx >
 _Bind < _Ret,
  _Bind1 < _Callable_pmd < _Rx _Farg0 :: * const, _Farg0 >, _Arg0 > >
   bind ( _Rx _Farg0 :: * const _Val, _Arg0 _A0 )
 {
 typedef _Callable_pmd < _Rx _Farg0 :: * const, _Farg0 > _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _A0 ) ) );
 }

template < class _Farg0,
 class _Arg0,
 class _Rx >
 _Bind < _Notforced,
  _Bind1 < _Callable_pmd < _Rx _Farg0 :: * const, _Farg0 >, _Arg0 > >
   bind ( _Rx _Farg0 :: * const _Val, _Arg0 _A0 )
 {
 typedef _Callable_pmd < _Rx _Farg0 :: * const, _Farg0 > _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _A0 ) ) );
 }
#line 400 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret,
 class _Farg0,
 class _Arg0,
 class _Rx >
 _Bind < _Ret,
  _Bind1 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ), _Farg0 >,
   _Arg0 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( ), _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ), _Farg0 >
  _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }

template < class _Farg0,
 class _Arg0,
 class _Rx >
 _Bind < _Notforced,
  _Bind1 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ), _Farg0 >,
   _Arg0 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( ), _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ), _Farg0 >
  _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }

template < class _Ret,
 class _Farg0,
 class _Arg0,
 class _Rx >
 _Bind < _Ret,
  _Bind1 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ) const,
   _Farg0 >, _Arg0 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( ) const, _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ) const, _Farg0 >
  _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }

template < class _Farg0,
 class _Arg0,
 class _Rx >
 _Bind < _Notforced,
  _Bind1 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ) const,
   _Farg0 >, _Arg0 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( ) const, _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ) const, _Farg0 >
  _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }

template < class _Ret,
 class _Farg0,
 class _Arg0,
 class _Rx >
 _Bind < _Ret,
  _Bind1 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ) volatile,
   _Farg0 >, _Arg0 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) ( ) volatile, _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ) volatile, _Farg0 >
  _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }

template < class _Farg0,
 class _Arg0,
 class _Rx >
 _Bind < _Notforced,
  _Bind1 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ) volatile,
   _Farg0 >, _Arg0 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( ) volatile, _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ) volatile, _Farg0 >
  _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }

template < class _Ret,
 class _Farg0,
 class _Arg0,
 class _Rx >
 _Bind < _Ret,
  _Bind1 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ) const volatile,
   _Farg0 >, _Arg0 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( )
    const volatile, _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }

template < class _Farg0,
 class _Arg0,
 class _Rx >
 _Bind < _Notforced,
  _Bind1 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ) const volatile,
   _Farg0 >, _Arg0 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) (
     ) const volatile, _Arg0 _Ax0 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind1 < _Callable, _Arg0 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0 ) ) );
 }
#line 237 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<> struct _Binder< false, 2>  { 

template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg1 & _Get ( _Arg, _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( _Bx1 );
  }

template<class _Arg, class 
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
struct _Ret { 

typedef _Barg1 _Type; 
}; 
}; 

template < class _Callable,
 class _Arg0, class _Arg1 >
 class _Bind2
  : public _Bind1 < _Callable, _Arg0 >
 {
public :
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _Self;
 typedef _Binder < is_bind_expression < _Arg1 > :: value,
  is_placeholder < _Arg1 > :: value > _Binder1;
 typedef _Arg1 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind1 < _Callable, _Arg0 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1 ) > :: type _Type;
  };

 _Bind2 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1 )
  : _Vx1 ( _Ax1 ), _Bind1 < _Callable, _Arg0 > ( _Val, _Ax0 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg1 _Vx1;
 };


namespace placeholders { 
static _Ph< 2>  _2; 
}
#line 302 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<class _Ret, class _BindTy, class _Arg0, class _Arg1> 
struct _Result_of2< _Bind< _Ret, _BindTy> , _Arg0, _Arg1>  { 

typedef _Ret _Type; 
}; 

template<class _BindTy, class _Arg0, class _Arg1> 
struct _Result_of2< _Bind< _Notforced, _BindTy> , _Arg0, _Arg1>  { 


typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
}; 

template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1 >
 _Bind < _Ret,
  _Bind2 < _Callable_obj < _Fty >, _Arg0, _Arg1 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Bind2 < _Callable_obj < _Fty >, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }

template < class _Fty
 , class _Arg0, class _Arg1 >
 _Bind < _Notforced,
  _Bind2 < _Callable_obj < _Fty >, _Arg0, _Arg1 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Bind2 < _Callable_obj < _Fty >, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 341 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret
 , class _Farg0, class _Farg1
 , class _Arg0, class _Arg1,
 class _Rx >

 _Bind < _Ret,
  _Bind2 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1 ) >, _Arg0, _Arg1 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1 ), _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1 ) > _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 359 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Farg0, class _Farg1
 , class _Arg0, class _Arg1,
 class _Rx >

 _Bind < _Notforced,
  _Bind2 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1 ) >, _Arg0, _Arg1 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1 ), _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1 ) > _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 400 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret,
 class _Farg0, class _Farg1,
 class _Arg0, class _Arg1,
 class _Rx >
 _Bind < _Ret,
  _Bind2 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ), _Farg0 >,
   _Arg0, _Arg1 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1 ), _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ), _Farg0 >
  _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }

template < class _Farg0, class _Farg1,
 class _Arg0, class _Arg1,
 class _Rx >
 _Bind < _Notforced,
  _Bind2 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ), _Farg0 >,
   _Arg0, _Arg1 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1 ), _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ), _Farg0 >
  _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1,
 class _Arg0, class _Arg1,
 class _Rx >
 _Bind < _Ret,
  _Bind2 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ) const,
   _Farg0 >, _Arg0, _Arg1 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1 ) const, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ) const, _Farg0 >
  _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }

template < class _Farg0, class _Farg1,
 class _Arg0, class _Arg1,
 class _Rx >
 _Bind < _Notforced,
  _Bind2 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ) const,
   _Farg0 >, _Arg0, _Arg1 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1 ) const, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ) const, _Farg0 >
  _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1,
 class _Arg0, class _Arg1,
 class _Rx >
 _Bind < _Ret,
  _Bind2 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ) volatile,
   _Farg0 >, _Arg0, _Arg1 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }

template < class _Farg0, class _Farg1,
 class _Arg0, class _Arg1,
 class _Rx >
 _Bind < _Notforced,
  _Bind2 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ) volatile,
   _Farg0 >, _Arg0, _Arg1 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1,
 class _Arg0, class _Arg1,
 class _Rx >
 _Bind < _Ret,
  _Bind2 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ) const volatile,
   _Farg0 >, _Arg0, _Arg1 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }

template < class _Farg0, class _Farg1,
 class _Arg0, class _Arg1,
 class _Rx >
 _Bind < _Notforced,
  _Bind2 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ) const volatile,
   _Farg0 >, _Arg0, _Arg1 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) (
     _Farg1 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind2 < _Callable, _Arg0, _Arg1 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1 ) ) );
 }
#line 237 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<> struct _Binder< false, 3>  { 

template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg2 & _Get ( _Arg, _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( _Bx2 );
  }

template<class _Arg, class 
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
struct _Ret { 

typedef _Barg2 _Type; 
}; 
}; 

template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2 >
 class _Bind3
  : public _Bind2 < _Callable, _Arg0, _Arg1 >
 {
public :
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _Self;
 typedef _Binder < is_bind_expression < _Arg2 > :: value,
  is_placeholder < _Arg2 > :: value > _Binder2;
 typedef _Arg2 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind2 < _Callable, _Arg0, _Arg1 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2 ) > :: type _Type;
  };

 _Bind3 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
  : _Vx2 ( _Ax2 ), _Bind2 < _Callable, _Arg0, _Arg1 > ( _Val, _Ax0, _Ax1 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg2 _Vx2;
 };


namespace placeholders { 
static _Ph< 3>  _3; 
}
#line 302 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2> 
struct _Result_of3< _Bind< _Ret, _BindTy> , _Arg0, _Arg1, _Arg2>  { 

typedef _Ret _Type; 
}; 

template<class _BindTy, class _Arg0, class _Arg1, class _Arg2> 
struct _Result_of3< _Bind< _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2>  { 


typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
}; 

template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2 >
 _Bind < _Ret,
  _Bind3 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Bind3 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }

template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2 >
 _Bind < _Notforced,
  _Bind3 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Bind3 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 341 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret
 , class _Farg0, class _Farg1, class _Farg2
 , class _Arg0, class _Arg1, class _Arg2,
 class _Rx >

 _Bind < _Ret,
  _Bind3 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2 ) >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2 ) > _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 359 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Farg0, class _Farg1, class _Farg2
 , class _Arg0, class _Arg1, class _Arg2,
 class _Rx >

 _Bind < _Notforced,
  _Bind3 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2 ) >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2 ) > _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 400 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2,
 class _Rx >
 _Bind < _Ret,
  _Bind3 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ), _Farg0 >
  _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2,
 class _Rx >
 _Bind < _Notforced,
  _Bind3 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ), _Farg0 >
  _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2,
 class _Rx >
 _Bind < _Ret,
  _Bind3 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) const, _Farg0 >
  _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2,
 class _Rx >
 _Bind < _Notforced,
  _Bind3 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) const, _Farg0 >
  _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2,
 class _Rx >
 _Bind < _Ret,
  _Bind3 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2,
 class _Rx >
 _Bind < _Notforced,
  _Bind3 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2,
 class _Rx >
 _Bind < _Ret,
  _Bind3 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2,
 class _Arg0, class _Arg1, class _Arg2,
 class _Rx >
 _Bind < _Notforced,
  _Bind3 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) (
   _Farg1, _Farg2 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2 ) ) );
 }
#line 237 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<> struct _Binder< false, 4>  { 

template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg3 & _Get ( _Arg, _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( _Bx3 );
  }

template<class _Arg, class 
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
struct _Ret { 

typedef _Barg3 _Type; 
}; 
}; 

template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 class _Bind4
  : public _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 >
 {
public :
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _Self;
 typedef _Binder < is_bind_expression < _Arg3 > :: value,
  is_placeholder < _Arg3 > :: value > _Binder3;
 typedef _Arg3 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3 ) > :: type _Type;
  };

 _Bind4 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
  : _Vx3 ( _Ax3 ), _Bind3 < _Callable, _Arg0, _Arg1, _Arg2 > ( _Val, _Ax0, _Ax1, _Ax2 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg3 _Vx3;
 };


namespace placeholders { 
static _Ph< 4>  _4; 
}
#line 302 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
struct _Result_of4< _Bind< _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3>  { 

typedef _Ret _Type; 
}; 

template<class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3> 
struct _Result_of4< _Bind< _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3>  { 


typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
}; 

template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Bind < _Ret,
  _Bind4 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Bind4 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }

template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3 >
 _Bind < _Notforced,
  _Bind4 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Bind4 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 341 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3,
 class _Rx >

 _Bind < _Ret,
  _Bind4 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3 ) >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3 ) > _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 359 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Farg0, class _Farg1, class _Farg2, class _Farg3
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3,
 class _Rx >

 _Bind < _Notforced,
  _Bind4 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3 ) >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3 ) > _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 400 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3,
 class _Rx >
 _Bind < _Ret,
  _Bind4 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ), _Farg0 >
  _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3,
 class _Rx >
 _Bind < _Notforced,
  _Bind4 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ), _Farg0 >
  _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3,
 class _Rx >
 _Bind < _Ret,
  _Bind4 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const, _Farg0 >
  _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3,
 class _Rx >
 _Bind < _Notforced,
  _Bind4 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const, _Farg0 >
  _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3,
 class _Rx >
 _Bind < _Ret,
  _Bind4 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3,
 class _Rx >
 _Bind < _Notforced,
  _Bind4 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3,
 class _Rx >
 _Bind < _Ret,
  _Bind4 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3,
 class _Rx >
 _Bind < _Notforced,
  _Bind4 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 ) ) );
 }
#line 237 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<> struct _Binder< false, 5>  { 

template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg4 & _Get ( _Arg, _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( _Bx4 );
  }

template<class _Arg, class 
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
struct _Ret { 

typedef _Barg4 _Type; 
}; 
}; 

template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 class _Bind5
  : public _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 >
 {
public :
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _Self;
 typedef _Binder < is_bind_expression < _Arg4 > :: value,
  is_placeholder < _Arg4 > :: value > _Binder4;
 typedef _Arg4 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3, _Barg4 ) > :: type _Type;
  };

 _Bind5 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
  : _Vx4 ( _Ax4 ), _Bind4 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3 > ( _Val, _Ax0, _Ax1, _Ax2, _Ax3 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg4 _Vx4;
 };


namespace placeholders { 
static _Ph< 5>  _5; 
}
#line 302 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
struct _Result_of5< _Bind< _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4>  { 

typedef _Ret _Type; 
}; 

template<class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4> 
struct _Result_of5< _Bind< _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4>  { 


typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Nil &, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
}; 

template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Bind < _Ret,
  _Bind5 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Bind5 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }

template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4 >
 _Bind < _Notforced,
  _Bind5 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Bind5 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 341 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4,
 class _Rx >

 _Bind < _Ret,
  _Bind5 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ) > _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 359 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4,
 class _Rx >

 _Bind < _Notforced,
  _Bind5 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4 ) > _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 400 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4,
 class _Rx >
 _Bind < _Ret,
  _Bind5 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Farg0 >
  _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4,
 class _Rx >
 _Bind < _Notforced,
  _Bind5 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ), _Farg0 >
  _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4,
 class _Rx >
 _Bind < _Ret,
  _Bind5 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const, _Farg0 >
  _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4,
 class _Rx >
 _Bind < _Notforced,
  _Bind5 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const, _Farg0 >
  _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4,
 class _Rx >
 _Bind < _Ret,
  _Bind5 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4,
 class _Rx >
 _Bind < _Notforced,
  _Bind5 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4,
 class _Rx >
 _Bind < _Ret,
  _Bind5 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4,
 class _Rx >
 _Bind < _Notforced,
  _Bind5 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 ) ) );
 }
#line 237 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<> struct _Binder< false, 6>  { 

template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg5 & _Get ( _Arg, _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( _Bx5 );
  }

template<class _Arg, class 
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
struct _Ret { 

typedef _Barg5 _Type; 
}; 
}; 

template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 class _Bind6
  : public _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 >
 {
public :
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _Self;
 typedef _Binder < is_bind_expression < _Arg5 > :: value,
  is_placeholder < _Arg5 > :: value > _Binder5;
 typedef _Arg5 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3, _Barg4, _Barg5 ) > :: type _Type;
  };

 _Bind6 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
  : _Vx5 ( _Ax5 ), _Bind5 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4 > ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg5 _Vx5;
 };


namespace placeholders { 
static _Ph< 6>  _6; 
}
#line 302 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
struct _Result_of6< _Bind< _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5>  { 

typedef _Ret _Type; 
}; 

template<class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5> 
struct _Result_of6< _Bind< _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5>  { 


typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Nil &, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
}; 

template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Bind < _Ret,
  _Bind6 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Bind6 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }

template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5 >
 _Bind < _Notforced,
  _Bind6 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Bind6 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 341 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5,
 class _Rx >

 _Bind < _Ret,
  _Bind6 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) > _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 359 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5,
 class _Rx >

 _Bind < _Notforced,
  _Bind6 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) > _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 400 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5,
 class _Rx >
 _Bind < _Ret,
  _Bind6 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Farg0 >
  _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5,
 class _Rx >
 _Bind < _Notforced,
  _Bind6 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ), _Farg0 >
  _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5,
 class _Rx >
 _Bind < _Ret,
  _Bind6 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const, _Farg0 >
  _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5,
 class _Rx >
 _Bind < _Notforced,
  _Bind6 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const, _Farg0 >
  _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5,
 class _Rx >
 _Bind < _Ret,
  _Bind6 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5,
 class _Rx >
 _Bind < _Notforced,
  _Bind6 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5,
 class _Rx >
 _Bind < _Ret,
  _Bind6 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5,
 class _Rx >
 _Bind < _Notforced,
  _Bind6 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 ) ) );
 }
#line 237 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<> struct _Binder< false, 7>  { 

template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg6 & _Get ( _Arg, _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( _Bx6 );
  }

template<class _Arg, class 
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
struct _Ret { 

typedef _Barg6 _Type; 
}; 
}; 

template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 class _Bind7
  : public _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 >
 {
public :
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _Self;
 typedef _Binder < is_bind_expression < _Arg6 > :: value,
  is_placeholder < _Arg6 > :: value > _Binder6;
 typedef _Arg6 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3, _Barg4, _Barg5, _Barg6 ) > :: type _Type;
  };

 _Bind7 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
  : _Vx6 ( _Ax6 ), _Bind6 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5 > ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg6 _Vx6;
 };


namespace placeholders { 
static _Ph< 7>  _7; 
}
#line 302 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
struct _Result_of7< _Bind< _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6>  { 

typedef _Ret _Type; 
}; 

template<class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6> 
struct _Result_of7< _Bind< _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6>  { 


typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Nil &, _Nil &, _Nil &> ::_Type _Type; 
}; 

template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Bind < _Ret,
  _Bind7 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Bind7 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }

template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6 >
 _Bind < _Notforced,
  _Bind7 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Bind7 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 341 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6,
 class _Rx >

 _Bind < _Ret,
  _Bind7 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) > _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 359 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6,
 class _Rx >

 _Bind < _Notforced,
  _Bind7 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) > _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 400 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6,
 class _Rx >
 _Bind < _Ret,
  _Bind7 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Farg0 >
  _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6,
 class _Rx >
 _Bind < _Notforced,
  _Bind7 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ), _Farg0 >
  _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6,
 class _Rx >
 _Bind < _Ret,
  _Bind7 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const, _Farg0 >
  _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6,
 class _Rx >
 _Bind < _Notforced,
  _Bind7 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const, _Farg0 >
  _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6,
 class _Rx >
 _Bind < _Ret,
  _Bind7 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6,
 class _Rx >
 _Bind < _Notforced,
  _Bind7 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6,
 class _Rx >
 _Bind < _Ret,
  _Bind7 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6,
 class _Rx >
 _Bind < _Notforced,
  _Bind7 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 ) ) );
 }
#line 237 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<> struct _Binder< false, 8>  { 

template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg7 & _Get ( _Arg, _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( _Bx7 );
  }

template<class _Arg, class 
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
struct _Ret { 

typedef _Barg7 _Type; 
}; 
}; 

template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 class _Bind8
  : public _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 >
 {
public :
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _Self;
 typedef _Binder < is_bind_expression < _Arg7 > :: value,
  is_placeholder < _Arg7 > :: value > _Binder7;
 typedef _Arg7 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3, _Barg4, _Barg5, _Barg6, _Barg7 ) > :: type _Type;
  };

 _Bind8 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
  : _Vx7 ( _Ax7 ), _Bind7 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6 > ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder7 :: _Get ( this -> _Vx7, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder7 :: _Get ( this -> _Vx7, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg7 _Vx7;
 };


namespace placeholders { 
static _Ph< 8>  _8; 
}
#line 302 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
struct _Result_of8< _Bind< _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7>  { 

typedef _Ret _Type; 
}; 

template<class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7> 
struct _Result_of8< _Bind< _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7>  { 


typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Nil &, _Nil &> ::_Type _Type; 
}; 

template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Bind < _Ret,
  _Bind8 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Bind8 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }

template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7 >
 _Bind < _Notforced,
  _Bind8 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Bind8 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 341 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7,
 class _Rx >

 _Bind < _Ret,
  _Bind8 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) > _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 359 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7,
 class _Rx >

 _Bind < _Notforced,
  _Bind8 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) > _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 400 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7,
 class _Rx >
 _Bind < _Ret,
  _Bind8 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Farg0 >
  _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7,
 class _Rx >
 _Bind < _Notforced,
  _Bind8 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ), _Farg0 >
  _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7,
 class _Rx >
 _Bind < _Ret,
  _Bind8 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const, _Farg0 >
  _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7,
 class _Rx >
 _Bind < _Notforced,
  _Bind8 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const, _Farg0 >
  _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7,
 class _Rx >
 _Bind < _Ret,
  _Bind8 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7,
 class _Rx >
 _Bind < _Notforced,
  _Bind8 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7,
 class _Rx >
 _Bind < _Ret,
  _Bind8 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7,
 class _Rx >
 _Bind < _Notforced,
  _Bind8 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 ) ) );
 }
#line 237 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<> struct _Binder< false, 9>  { 

template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg8 & _Get ( _Arg, _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( _Bx8 );
  }

template<class _Arg, class 
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
struct _Ret { 

typedef _Barg8 _Type; 
}; 
}; 

template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 class _Bind9
  : public _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 >
 {
public :
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _Self;
 typedef _Binder < is_bind_expression < _Arg8 > :: value,
  is_placeholder < _Arg8 > :: value > _Binder8;
 typedef _Arg8 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3, _Barg4, _Barg5, _Barg6, _Barg7, _Barg8 ) > :: type _Type;
  };

 _Bind9 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
  : _Vx8 ( _Ax8 ), _Bind8 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7 > ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder7 :: _Get ( this -> _Vx7, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder8 :: _Get ( this -> _Vx8, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder7 :: _Get ( this -> _Vx7, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder8 :: _Get ( this -> _Vx8, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg8 _Vx8;
 };


namespace placeholders { 
static _Ph< 9>  _9; 
}
#line 302 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
struct _Result_of9< _Bind< _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8>  { 

typedef _Ret _Type; 
}; 

template<class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8> 
struct _Result_of9< _Bind< _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8>  { 


typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Nil &> ::_Type _Type; 
}; 

template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Bind < _Ret,
  _Bind9 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Bind9 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }

template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8 >
 _Bind < _Notforced,
  _Bind9 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Bind9 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 341 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8,
 class _Rx >

 _Bind < _Ret,
  _Bind9 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) > _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 359 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8,
 class _Rx >

 _Bind < _Notforced,
  _Bind9 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) > _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 400 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8,
 class _Rx >
 _Bind < _Ret,
  _Bind9 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Farg0 >
  _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8,
 class _Rx >
 _Bind < _Notforced,
  _Bind9 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ), _Farg0 >
  _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8,
 class _Rx >
 _Bind < _Ret,
  _Bind9 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const, _Farg0 >
  _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8,
 class _Rx >
 _Bind < _Notforced,
  _Bind9 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const, _Farg0 >
  _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8,
 class _Rx >
 _Bind < _Ret,
  _Bind9 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8,
 class _Rx >
 _Bind < _Notforced,
  _Bind9 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8,
 class _Rx >
 _Bind < _Ret,
  _Bind9 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8,
 class _Rx >
 _Bind < _Notforced,
  _Bind9 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 ) ) );
 }
#line 237 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<> struct _Binder< false, 10>  { 

template < class _Arg,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  static _Barg9 & _Get ( _Arg, _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( _Bx9 );
  }

template<class _Arg, class 
_Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9> 
struct _Ret { 

typedef _Barg9 _Type; 
}; 
}; 

template < class _Callable,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 class _Bind10
  : public _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 >
 {
public :
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _Self;
 typedef _Binder < is_bind_expression < _Arg9 > :: value,
  is_placeholder < _Arg9 > :: value > _Binder9;
 typedef _Arg9 _MyArg;

 template < class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  struct _Return
  {
  typedef typename _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > :: _MyCallable
   _MyCallable;
  typedef typename _MyCallable :: _MyTy _MyTy;
  typedef typename result_of < _MyTy ( _Barg0, _Barg1, _Barg2, _Barg3, _Barg4, _Barg5, _Barg6, _Barg7, _Barg8, _Barg9 ) > :: type _Type;
  };

 _Bind10 ( typename _Callable :: _MyTy _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
  : _Vx9 ( _Ax9 ), _Bind9 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8 > ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8 )
  {
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 ) const
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder7 :: _Get ( this -> _Vx7, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder8 :: _Get ( this -> _Vx8, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder9 :: _Get ( this -> _Vx9, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 template < class _Ret,
  class _Barg0, class _Barg1, class _Barg2, class _Barg3, class _Barg4, class _Barg5, class _Barg6, class _Barg7, class _Barg8, class _Barg9 >
  _Ret _ApplyX ( _Barg0 & _Bx0, _Barg1 & _Bx1, _Barg2 & _Bx2, _Barg3 & _Bx3, _Barg4 & _Bx4, _Barg5 & _Bx5, _Barg6 & _Bx6, _Barg7 & _Bx7, _Barg8 & _Bx8, _Barg9 & _Bx9 )
  {
  return ( this -> _Callee . template _ApplyX < _Ret > ( _Self :: _Binder0 :: _Get ( this -> _Vx0, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder1 :: _Get ( this -> _Vx1, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder2 :: _Get ( this -> _Vx2, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder3 :: _Get ( this -> _Vx3, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder4 :: _Get ( this -> _Vx4, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder5 :: _Get ( this -> _Vx5, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder6 :: _Get ( this -> _Vx6, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder7 :: _Get ( this -> _Vx7, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder8 :: _Get ( this -> _Vx8, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ), _Self :: _Binder9 :: _Get ( this -> _Vx9, _Bx0, _Bx1, _Bx2, _Bx3, _Bx4, _Bx5, _Bx6, _Bx7, _Bx8, _Bx9 ) ) );
  }

 _Arg9 _Vx9;
 };


namespace placeholders { 
static _Ph< 10>  _10; 
}
#line 302 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template<class _Ret, class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
struct _Result_of10< _Bind< _Ret, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9>  { 

typedef _Ret _Type; 
}; 

template<class _BindTy, class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9> 
struct _Result_of10< _Bind< _Notforced, _BindTy> , _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9>  { 


typedef typename _BindTy::template _Return< _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9> ::_Type _Type; 
}; 

template < class _Ret,
 class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Bind < _Ret,
  _Bind10 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Bind10 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }

template < class _Fty
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9 >
 _Bind < _Notforced,
  _Bind10 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Fty _Val, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Bind10 < _Callable_obj < _Fty >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 341 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret
 , class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9,
 class _Rx >

 _Bind < _Ret,
  _Bind10 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) > _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 359 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9
 , class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9,
 class _Rx >

 _Bind < _Notforced,
  _Bind10 < _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Rx ( * const _Val ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_fun < _Rx ( * const ) ( _Farg0, _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) > _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 400 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\xxbind1"
template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9,
 class _Rx >
 _Bind < _Ret,
  _Bind10 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Farg0 >
  _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9,
 class _Rx >
 _Bind < _Notforced,
  _Bind10 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Farg0 >,
   _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ), _Farg0 >
  _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9,
 class _Rx >
 _Bind < _Ret,
  _Bind10 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const, _Farg0 >
  _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9,
 class _Rx >
 _Bind < _Notforced,
  _Bind10 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const, _Farg0 >
  _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9,
 class _Rx >
 _Bind < _Ret,
  _Bind10 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9,
 class _Rx >
 _Bind < _Notforced,
  _Bind10 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) volatile, _Farg0 >
  _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }

template < class _Ret,
 class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9,
 class _Rx >
 _Bind < _Ret,
  _Bind10 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
   bind ( _Rx ( _Farg0 :: * const _Val ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 )
    const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Ret, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }

template < class _Farg0, class _Farg1, class _Farg2, class _Farg3, class _Farg4, class _Farg5, class _Farg6, class _Farg7, class _Farg8, class _Farg9,
 class _Arg0, class _Arg1, class _Arg2, class _Arg3, class _Arg4, class _Arg5, class _Arg6, class _Arg7, class _Arg8, class _Arg9,
 class _Rx >
 _Bind < _Notforced,
  _Bind10 < _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile,
   _Farg0 >, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > >
  bind ( _Rx ( _Farg0 :: * const _Val ) (
   _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile, _Arg0 _Ax0, _Arg1 _Ax1, _Arg2 _Ax2, _Arg3 _Ax3, _Arg4 _Ax4, _Arg5 _Ax5, _Arg6 _Ax6, _Arg7 _Ax7, _Arg8 _Ax8, _Arg9 _Ax9 )
 {
 typedef _Callable_pmf < _Rx ( _Farg0 :: * const ) ( _Farg1, _Farg2, _Farg3, _Farg4, _Farg5, _Farg6, _Farg7, _Farg8, _Farg9 ) const volatile,
  _Farg0 > _Callable;
 typedef _Bind10 < _Callable, _Arg0, _Arg1, _Arg2, _Arg3, _Arg4, _Arg5, _Arg6, _Arg7, _Arg8, _Arg9 > _MyBind;
 return ( _Bind < _Notforced, _MyBind > ( _MyBind ( _Val, _Ax0, _Ax1, _Ax2, _Ax3, _Ax4, _Ax5, _Ax6, _Ax7, _Ax8, _Ax9 ) ) );
 }
#line 1244 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
}

template<class _Fty> 
class _Move_operation_category< tr1::function< _Fty> >  { 


public: typedef _Swap_move_tag _Move_cat; 
}; 
}
#line 1255 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\functional"
namespace std { 
namespace tr1 { 

template < class _Kty >
 class hash
  : public unary_function < _Kty, size_t >
 {
public :
 size_t operator ( ) ( const _Kty & _Keyval ) const
  {
  ldiv_t _Qrem = ldiv ( ( long ) ( size_t ) _Keyval, 127773 );

  _Qrem . rem = 16807 * _Qrem . rem - 2836 * _Qrem . quot;
  if ( _Qrem . rem < 0 )
   _Qrem . rem += 2147483647;
  return ( ( size_t ) _Qrem . rem );
  }
 };


template<> class hash< basic_string< char, char_traits< char> , allocator< char> > >  : public unary_function< basic_string< char, char_traits< char> , allocator< char> > , unsigned>  { 



public: typedef string _Kty; 

size_t operator()(const _Kty &_Keyval) const 
{ 
auto size_t _Val = (2166136261U); 
auto size_t _First = (0); 
auto size_t _Last = _Keyval.size(); 
auto size_t _Stride = ((1) + _Last / (10)); 

if (_Stride < _Last) { 
_Last -= _Stride; }  
for (; _First < _Last; _First += _Stride) { 
_Val = (16777619U * _Val) ^ ((unsigned)(_Keyval[_First])); }  
return _Val; 
} 
}; 


template<> class hash< basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > >  : public unary_function< basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > , unsigned>  { 



public: typedef wstring _Kty; 

size_t operator()(const _Kty &_Keyval) const 
{ 
auto size_t _Val = (2166136261U); 
auto size_t _First = (0); 
auto size_t _Last = _Keyval.size(); 
auto size_t _Stride = ((1) + _Last / (10)); 

if (_Stride < _Last) { 
_Last -= _Stride; }  
for (; _First < _Last; _First += _Stride) { 
_Val = (16777619U * _Val) ^ ((unsigned)(_Keyval[_First])); }  
return _Val; 
} 
}; 

}
}


#pragma warning(default: 4100 4180 4244)
#pragma warning(pop)
#pragma pack ( pop )
#line 11 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\list"
#pragma pack ( push, 8 )
#line 14 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\list"
namespace std { 


template < class _Ty,
 class _Alloc >
 class _List_nod
  : public _Container_base_aux_alloc_real < _Alloc >
 {
protected :
 struct _Node;
 friend struct _Node;
 typedef _Node * _Nodeptr;





#pragma warning(push)
#pragma warning(disable:4512)
 struct _Node
  {
  _Node ( )
   {
   }

  _Nodeptr _Next;
  _Nodeptr _Prev;
  _Ty _Myval;
  };
#pragma warning(pop)

 _List_nod ( _Alloc _Al )
  : _Container_base_aux_alloc_real < _Alloc > ( _Al ), _Alnod ( _Al )
  {
  }

 typename _Alloc :: template rebind < _Node > :: other
  _Alnod;
 };


template < class _Ty,
 class _Alloc >
 class _List_ptr
  : public _List_nod < _Ty, _Alloc >
 {
protected :
 typedef _List_nod < _Ty, _Alloc > _Mybase;
 typedef typename _Mybase :: _Node _Node;
 typedef typename _Mybase :: _Nodeptr _Nodeptr;

 _List_ptr ( _Alloc _Al )
  : _List_nod < _Ty, _Alloc > ( _Al ), _Alptr ( _Al )
  {
  }

 typename _Alloc :: template rebind < _Nodeptr > :: other
  _Alptr;
 };


template < class _Ty,
 class _Alloc >
 class _List_val
  : public _List_ptr < _Ty, _Alloc >
 {
public :
 typedef typename _Alloc :: template rebind < _Ty > :: other _Alty;

 _List_val ( _Alloc _Al = _Alloc ( ) )
  : _List_ptr < _Ty, _Alloc > ( _Al ), _Alval ( _Al )
  {
  }

 _Alty _Alval;
 };


template < class _Ty,
 class _Ax = allocator < _Ty > >
 class list
  : public _List_val < _Ty, _Ax >
 {
public :
 typedef list < _Ty, _Ax > _Myt;
 typedef _List_val < _Ty, _Ax > _Mybase;
 typedef typename _Mybase :: _Alty _Alloc;

protected :
 typedef typename _Mybase :: _Node _Node;
 typedef typename _Mybase :: _Nodeptr _Nodeptr;

 typedef typename _Alloc :: template rebind < _Nodeptr > :: other
  _Nodeptr_alloc;
 typedef typename _Nodeptr_alloc :: reference _Nodepref;


 typedef typename _Alloc :: reference _Vref;

 static _Nodepref _Nextnode ( _Nodeptr _Pnode )
  {
  return ( ( _Nodepref ) ( * _Pnode ) . _Next );
  }

 static _Nodepref _Prevnode ( _Nodeptr _Pnode )
  {
  return ( ( _Nodepref ) ( * _Pnode ) . _Prev );
  }

 static _Vref _Myval ( _Nodeptr _Pnode )
  {
  return ( ( _Vref ) ( * _Pnode ) . _Myval );
  }

public :
 typedef _Alloc allocator_type;
 typedef typename _Alloc :: size_type size_type;
 typedef typename _Alloc :: difference_type _Dift;
 typedef _Dift difference_type;
 typedef typename _Alloc :: pointer _Tptr;
 typedef typename _Alloc :: const_pointer _Ctptr;
 typedef _Tptr pointer;
 typedef _Ctptr const_pointer;
 typedef typename _Alloc :: reference _Reft;
 typedef _Reft reference;
 typedef typename _Alloc :: const_reference const_reference;
 typedef typename _Alloc :: value_type value_type;


 template < bool _Secure_validation > class _Const_iterator;
 friend class _Const_iterator < true >;

 friend class _Const_iterator < false >;


 template < bool _Secure_validation >
 class _Const_iterator
  : public _Bidit < _Ty, _Dift, _Ctptr, const_reference >
  {
 public :
  typedef _Const_iterator < _Secure_validation > _Myt_iter;
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Ty value_type;
  typedef _Dift difference_type;
  typedef _Ctptr pointer;
  typedef const_reference reference;

  _Const_iterator ( )
   : _Ptr ( 0 )
   {
   }









  _Const_iterator ( _Nodeptr _Pnode, const _Myt * _Plist )
   : _Ptr ( _Pnode )
   {
   { __pragma(warning(push)); __pragma(warning(disable: 4127)); if ( _Secure_validation ) { { if ( ! ( _Plist != 0 ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; } } __pragma(warning(pop)); };
   this -> _Set_container ( _Plist );
   }









 typedef typename _Secure_validation_helper < _Secure_validation > :: _Checked_iterator_category _Checked_iterator_category;
 typedef typename _If < _Secure_validation,
  _Const_iterator < false >,
  _Unchanged_checked_iterator_base_type_tag > :: _Result _Checked_iterator_base_type;

 friend _Const_iterator < false >;
 friend _Const_iterator < true >;

 _Const_iterator < false > _Checked_iterator_base ( ) const
 {
  _Const_iterator < false > _Base ( this -> _Ptr, ( ( _Myt * ) this -> _Getmycont ( ) ) );
  return _Base;
 }

 void _Checked_iterator_assign_from_base ( _Const_iterator < false > _Base )
 {
  { if ( ! ( this -> _Same_container ( _Base ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  this -> _Ptr = _Base . _Ptr;
 }


  const_reference operator * ( ) const
   {










   { __pragma(warning(push)); __pragma(warning(disable: 4127)); if ( _Secure_validation ) { { if ( ! ( this -> _Has_container ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; } } __pragma(warning(pop)); };
   { __pragma(warning(push)); __pragma(warning(disable: 4127)); if ( _Secure_validation ) { { if ( ! ( _Ptr != ( ( _Myt * ) ( this -> _Getmycont ( ) ) ) -> _Myhead ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; } } __pragma(warning(pop)); };


   return ( _Myval ( _Ptr ) );
   }

  _Ctptr operator -> ( ) const
   {
   return ( & * * this );
   }

  _Myt_iter & operator ++ ( )
   {










   { __pragma(warning(push)); __pragma(warning(disable: 4127)); if ( _Secure_validation ) { { if ( ! ( this -> _Has_container ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; } } __pragma(warning(pop)); };
   { __pragma(warning(push)); __pragma(warning(disable: 4127)); if ( _Secure_validation ) { { if ( ! ( _Ptr != ( ( _Myt * ) ( this -> _Getmycont ( ) ) ) -> _Myhead ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; } } __pragma(warning(pop)); };


   _Ptr = _Nextnode ( _Ptr );
   return ( * this );
   }

  _Myt_iter operator ++ ( int )
   {
   _Myt_iter _Tmp = * this;
   ++ * this;
   return ( _Tmp );
   }

  _Myt_iter & operator -- ( )
   {











   { __pragma(warning(push)); __pragma(warning(disable: 4127)); if ( _Secure_validation ) { { if ( ! ( this -> _Has_container ( ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; } } __pragma(warning(pop)); };
   _Ptr = _Prevnode ( _Ptr );
   { __pragma(warning(push)); __pragma(warning(disable: 4127)); if ( _Secure_validation ) { { if ( ! ( _Ptr != ( ( _Myt * ) ( this -> _Getmycont ( ) ) ) -> _Myhead ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; } } __pragma(warning(pop)); };


   return ( * this );
   }

  _Myt_iter operator -- ( int )
   {
   _Myt_iter _Tmp = * this;
   -- * this;
   return ( _Tmp );
   }

  bool operator == ( const _Myt_iter & _Right ) const
   {




   { __pragma(warning(push)); __pragma(warning(disable: 4127)); if ( _Secure_validation ) { { if ( ! ( this -> _Has_container ( ) && this -> _Same_container ( _Right ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; } } __pragma(warning(pop)); };


   return ( _Ptr == _Right . _Ptr );
   }

  bool operator != ( const _Myt_iter & _Right ) const
   {
   return ( ! ( * this == _Right ) );
   }

  _Nodeptr _Mynode ( ) const
   {
   return ( _Ptr );
   }












  _Nodeptr _Ptr;
  };

 typedef _Const_iterator < true > const_iterator;


 template < bool _Secure_validation > class _Iterator;
 friend class _Iterator < true >;

 friend class _Iterator < false >;


 template < bool _Secure_validation >
 class _Iterator
  : public _Const_iterator < _Secure_validation >
  {
 public :
  friend class list < _Ty, _Ax >;
  typedef _Iterator < _Secure_validation > _Myt_iter;
  typedef _Const_iterator < _Secure_validation > _Mybase_iter;
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Ty value_type;
  typedef _Dift difference_type;
  typedef _Tptr pointer;
  typedef _Reft reference;

  _Iterator ( )
   {
   }








  _Iterator ( _Nodeptr _Pnode, const _Myt * _Plist )
   : _Mybase_iter ( _Pnode, _Plist )
   {
   }









 typedef typename _If < _Secure_validation,
  _Iterator < false >,
  _Unchanged_checked_iterator_base_type_tag > :: _Result _Checked_iterator_base_type;

 friend _Iterator < false >;
 friend _Iterator < true >;

 _Iterator < false > _Checked_iterator_base ( ) const
 {
  _Iterator < false > _Base ( this -> _Ptr, ( ( _Myt * ) this -> _Getmycont ( ) ) );
  return _Base;
 }

 void _Checked_iterator_assign_from_base ( _Iterator < false > _Base )
 {
  { if ( ! ( this -> _Same_container ( _Base ) ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo ( ); }; };
  this -> _Ptr = _Base . _Ptr;
 }


  reference operator * ( ) const
   {
   return ( ( reference ) * * ( _Mybase_iter * ) this );
   }

  _Tptr operator -> ( ) const
   {
   return ( & * * this );
   }

  _Myt_iter & operator ++ ( )
   {
   ++ ( * ( _Mybase_iter * ) this );
   return ( * this );
   }

  _Myt_iter operator ++ ( int )
   {
   _Myt_iter _Tmp = * this;
   ++ * this;
   return ( _Tmp );
   }

  _Myt_iter & operator -- ( )
   {
   -- ( * ( _Mybase_iter * ) this );
   return ( * this );
   }

  _Myt_iter operator -- ( int )
   {
   _Myt_iter _Tmp = * this;
   -- * this;
   return ( _Tmp );
   }
  };

 typedef _Iterator < true > iterator;

 typedef std :: reverse_iterator < iterator > reverse_iterator;
 typedef std :: reverse_iterator < const_iterator > const_reverse_iterator;

 list ( )
  : _Mybase ( ), _Myhead ( _Buynode ( ) ), _Mysize ( 0 )
  {
  }

 explicit list ( const _Alloc & _Al )
  : _Mybase ( _Al ), _Myhead ( _Buynode ( ) ), _Mysize ( 0 )
  {
  }

 explicit list ( size_type _Count )
  : _Mybase ( ), _Mysize ( 0 )
  {
  _Ty _Val = _Ty ( );
  _Myhead = _Buynode ( );
  _Construct_n ( _Count, _Val );
  }

 list ( size_type _Count, const _Ty & _Val )
  : _Mybase ( ), _Myhead ( _Buynode ( ) ), _Mysize ( 0 )
  {
  _Construct_n ( _Count, _Val );
  }

 list ( size_type _Count, const _Ty & _Val, const _Alloc & _Al )
  : _Mybase ( _Al ), _Myhead ( _Buynode ( ) ), _Mysize ( 0 )
  {
  _Construct_n ( _Count, _Val );
  }

 list ( const _Myt & _Right )
  : _Mybase ( _Right . _Alval ),
   _Myhead ( _Buynode ( ) ), _Mysize ( 0 )
  {
  try {
  insert ( begin ( ), _Right . begin ( ), _Right . end ( ) );
  } catch ( ... ) {
  _Tidy ( );
  throw;
  }
  }

 template < class _Iter >
  list ( _Iter _First, _Iter _Last )
  : _Mybase ( ), _Myhead ( _Buynode ( ) ), _Mysize ( 0 )
  {
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  list ( _Iter _First, _Iter _Last, const _Alloc & _Al )
  : _Mybase ( _Al ), _Myhead ( _Buynode ( ) ), _Mysize ( 0 )
  {
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Construct ( _Iter _Count, _Iter _Val, _Int_iterator_tag )
  {
  _Construct_n ( ( size_type ) _Count, ( _Ty ) _Val );
  }

 template < class _Iter >
  void _Construct ( _Iter _First,
   _Iter _Last, input_iterator_tag )
  {
  try {
  insert ( begin ( ), _First, _Last );
  } catch ( ... ) {
  _Tidy ( );
  throw;
  }
  }

 void _Construct_n ( size_type _Count,
  const _Ty & _Val )
  {
  try {
  _Insert_n ( begin ( ), _Count, _Val );
  } catch ( ... ) {
  _Tidy ( );
  throw;
  }
  }

 ~ list ( )
  {
  _Tidy ( );
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  if ( this != & _Right )
   assign ( _Right . begin ( ), _Right . end ( ) );
  return ( * this );
  }


 iterator begin ( )
  {
  return ( iterator ( _Nextnode ( _Myhead ), this ) );
  }

 const_iterator begin ( ) const
  {
  return ( const_iterator ( _Nextnode ( _Myhead ), this ) );
  }

 iterator end ( )
  {
  return ( iterator ( _Myhead, this ) );
  }

 const_iterator end ( ) const
  {
  return ( const_iterator ( _Myhead, this ) );
  }

 iterator _Make_iter ( const_iterator _Where ) const
  {
  return ( iterator ( _Where . _Ptr, this ) );
  }




























 reverse_iterator rbegin ( )
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( )
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }

 void resize ( size_type _Newsize )
  {
  resize ( _Newsize, _Ty ( ) );
  }

 void resize ( size_type _Newsize, _Ty _Val )
  {
  if ( _Mysize < _Newsize )
   _Insert_n ( end ( ), _Newsize - _Mysize, _Val );
  else
   while ( _Newsize < _Mysize )
    pop_back ( );
  }

 size_type size ( ) const
  {
  return ( _Mysize );
  }

 size_type max_size ( ) const
  {
  return ( this -> _Alval . max_size ( ) );
  }

 bool empty ( ) const
  {
  return ( _Mysize == 0 );
  }

 allocator_type get_allocator ( ) const
  {
  return ( this -> _Alval );
  }

 reference front ( )
  {
  return ( * begin ( ) );
  }

 const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

 reference back ( )
  {
  return ( * ( -- end ( ) ) );
  }

 const_reference back ( ) const
  {
  return ( * ( -- end ( ) ) );
  }

 void push_front ( const _Ty & _Val )
  {
  _Insert ( begin ( ), _Val );
  }

 void pop_front ( )
  {
  erase ( begin ( ) );
  }

 void push_back ( const _Ty & _Val )
  {
  _Insert ( end ( ), _Val );
  }

 void pop_back ( )
  {
  erase ( -- end ( ) );
  }

 template < class _Iter >
  void assign ( _Iter _First, _Iter _Last )
  {
  _Assign ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Assign ( _Iter _Count, _Iter _Val, _Int_iterator_tag )
  {
  _Assign_n ( ( size_type ) _Count, ( _Ty ) _Val );
  }

 template < class _Iter >
  void _Assign ( _Iter _First, _Iter _Last, input_iterator_tag )
  {
  clear ( );
  insert ( begin ( ), _First, _Last );
  }

 void assign ( size_type _Count, const _Ty & _Val )
  {
  _Assign_n ( _Count, _Val );
  }

 iterator insert ( const_iterator _Where, const _Ty & _Val )
  {
  _Insert ( _Where, _Val );
  return ( _Make_iter ( -- _Where ) );
  }

 void _Insert ( const_iterator _Where,
  const _Ty & _Val )
  {






  _Nodeptr _Pnode = _Where . _Mynode ( );
  _Nodeptr _Newnode = _Buynode ( _Pnode, _Prevnode ( _Pnode ), _Val );
  _Incsize ( 1 );
  _Prevnode ( _Pnode ) = _Newnode;
  _Nextnode ( _Prevnode ( _Newnode ) ) = _Newnode;
  }

 void insert ( const_iterator _Where, size_type _Count, const _Ty & _Val )
  {
  _Insert_n ( _Where, _Count, _Val );
  }

 template < class _Iter >
  void insert ( const_iterator _Where, _Iter _First, _Iter _Last )
  {
  _Insert ( _Where, _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where, _Iter _Count, _Iter _Val,
   _Int_iterator_tag )
  {
  _Insert_n ( _Where, ( size_type ) _Count, ( _Ty ) _Val );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where,
   _Iter _First, _Iter _Last, input_iterator_tag )
  {
  size_type _Num = 0;

  try {
  for (; _First != _Last; ++ _First, ++ _Num )
   _Insert ( _Where, * _First );
  } catch ( ... ) {
  for (; 0 < _Num; -- _Num )
   {
   const_iterator _Before = _Where;
   erase ( -- _Before );
   }
  throw;
  }
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where,
   _Iter _First, _Iter _Last, forward_iterator_tag )
  {





  _Iter _Next = _First;

  try {
  for (; _First != _Last; ++ _First )
   _Insert ( _Where, * _First );
  } catch ( ... ) {
  for (; _Next != _First; ++ _Next )
   {
   const_iterator _Before = _Where;
   erase ( -- _Before );
   }
  throw;
  }
  }

 iterator erase ( const_iterator _Where )
  {








  _Nodeptr _Pnode = ( _Where ++ ) . _Mynode ( );


  if ( _Pnode != _Myhead )
   {
   _Nextnode ( _Prevnode ( _Pnode ) ) = _Nextnode ( _Pnode );
   _Prevnode ( _Nextnode ( _Pnode ) ) = _Prevnode ( _Pnode );
   this -> _Alnod . destroy ( _Pnode );
   this -> _Alnod . deallocate ( _Pnode, 1 );
   -- _Mysize;
   }
  return ( _Make_iter ( _Where ) );
  }

 iterator erase ( const_iterator _First, const_iterator _Last )
  {
  if ( _First == begin ( ) && _Last == end ( ) )
   {
   clear ( );
   return ( end ( ) );
   }
  else
   {
   while ( _First != _Last )
    _First = erase ( _First );
   return ( _Make_iter ( _Last ) );
   }
  }

 void clear ( )
  {





  _Nodeptr _Pnext;
  _Nodeptr _Pnode = _Nextnode ( _Myhead );
  _Nextnode ( _Myhead ) = _Myhead;
  _Prevnode ( _Myhead ) = _Myhead;
  _Mysize = 0;

  for (; _Pnode != _Myhead; _Pnode = _Pnext )
   {
   _Pnext = _Nextnode ( _Pnode );
   this -> _Alnod . destroy ( _Pnode );
   this -> _Alnod . deallocate ( _Pnode, 1 );
   }
  }

 void swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( this -> _Alval == _Right . _Alval )
   {





   this -> _Swap_aux ( _Right );

   std :: swap ( _Myhead, _Right . _Myhead );
   std :: swap ( _Mysize, _Right . _Mysize );
   }
  else
   {
   this -> _Swap_aux ( _Right );

   iterator _Where = begin ( );
   splice ( _Where, _Right );
   _Right . splice ( _Right . begin ( ), * this, _Where, end ( ) );
   }
  }



 void splice ( const_iterator _Where, _Myt & _Right )
  {
  if ( this != & _Right && ! _Right . empty ( ) )
   {
   _Splice ( _Where, _Right, _Right . begin ( ), _Right . end ( ),
    _Right . _Mysize );
   }
  }

 void splice ( const_iterator _Where, _Myt & _Right, const_iterator _First )
  {







  if ( _First != _Right . end ( ) )


   {
   const_iterator _Last = _First;
   ++ _Last;
   if ( this != & _Right
    || ( _Where != _First && _Where != _Last ) )
    _Splice ( _Where, _Right, _First, _Last, 1 );
   }
  }

 void splice ( const_iterator _Where,
  _Myt & _Right, const_iterator _First, const_iterator _Last )
  {
  if ( _First != _Last && ( this != & _Right || _Where != _Last ) )
   {
   size_type _Count = 0;
   if ( this == & _Right )
    ;
   else if ( _First == _Right . begin ( ) && _Last == _Right . end ( ) )
    _Count = _Right . _Mysize;
   else
    {
    const_iterator _Next = _First;

    for (; _Next != _Last; ++ _Next, ++ _Count )
     if ( _Next == _Right . end ( ) )
     if ( _First == _Right . end ( ) )
      throw length_error ( "list<T> bad splice" );
    }
   _Splice ( _Where, _Right, _First, _Last, _Count );
   }
  }

 void remove ( const _Ty & _Val_arg )
  {






  const _Ty _Val = _Val_arg;
  iterator _Last = end ( );
  for ( iterator _First = begin ( ); _First != _Last; )
   if ( * _First == _Val )
    _First = erase ( _First );
   else
    ++ _First;
  }

 template < class _Pr1 >
  void remove_if ( _Pr1 _Pred )
  {
  iterator _Last = end ( );
  for ( iterator _First = begin ( ); _First != _Last; )
   if ( _Pred ( * _First ) )
    _First = erase ( _First );
   else
    ++ _First;
  }

 void unique ( )
  {
  if ( 2 <= _Mysize )
   {
   iterator _First = begin ( );
   iterator _After = _First;
   for ( ++ _After; _After != end ( ); )
    if ( * _First == * _After )
     _After = erase ( _After );
    else
     _First = _After ++;
   }
  }

 template < class _Pr2 >
  void unique ( _Pr2 _Pred )
  {
  if ( 2 <= _Mysize )
   {
   iterator _First = begin ( );
   iterator _After = _First;
   for ( ++ _After; _After != end ( ); )
    if ( _Pred ( * _First, * _After ) )
     _After = erase ( _After );
    else
     _First = _After ++;
   }
  }

 void merge ( _Myt & _Right )
  {
  if ( & _Right != this )
   {
   iterator _First1 = begin ( ), _Last1 = end ( );
   iterator _First2 = _Right . begin ( ), _Last2 = _Right . end ( );
   ;
   ;

   while ( _First1 != _Last1 && _First2 != _Last2 )
    if ( ( ( * _First2 ) < ( * _First1 ) ) )
     {
     iterator _Mid2 = _First2;
     _Splice ( _First1, _Right, _First2, ++ _Mid2, 1 );
     _First2 = _Mid2;
     }
    else
     ++ _First1;

   if ( _First2 != _Last2 )
    _Splice ( _Last1, _Right, _First2, _Last2,
     _Right . _Mysize );
   }
  }

 template < class _Pr3 >
  void merge ( _Myt & _Right, _Pr3 _Pred )
  {
  if ( & _Right != this )
   {
   iterator _First1 = begin ( ), _Last1 = end ( );
   iterator _First2 = _Right . begin ( ), _Last2 = _Right . end ( );
   ;
   ;

   while ( _First1 != _Last1 && _First2 != _Last2 )
    if ( _Pred ( * _First2, * _First1 ) )
     {
     iterator _Mid2 = _First2;
     _Splice ( _First1, _Right, _First2, ++ _Mid2, 1 );
     _First2 = _Mid2;
     }
    else
     ++ _First1;

   if ( _First2 != _Last2 )
    _Splice ( _Last1, _Right, _First2, _Last2,
     _Right . _Mysize );
   }
  }

 void sort ( )
  {
  if ( 2 <= _Mysize )
   {
   const size_t _MAXBINS = 25;
   _Myt _Templist ( this -> _Alval ), _Binlist [ _MAXBINS + 1 ];
   size_t _Maxbin = 0;

   while ( ! empty ( ) )
    {
    _Templist . _Splice ( _Templist . begin ( ), * this, begin ( ),
     ++ begin ( ), 1, true );

    size_t _Bin;
    for ( _Bin = 0; _Bin < _Maxbin && ! _Binlist [ _Bin ] . empty ( );
     ++ _Bin )
     {
     _Binlist [ _Bin ] . merge ( _Templist );
     _Binlist [ _Bin ] . swap ( _Templist );
     }

    if ( _Bin == _MAXBINS )
     _Binlist [ _Bin - 1 ] . merge ( _Templist );
    else
     {
     _Binlist [ _Bin ] . swap ( _Templist );
     if ( _Bin == _Maxbin )
      ++ _Maxbin;
     }
    }

   for ( size_t _Bin = 1; _Bin < _Maxbin; ++ _Bin )
    _Binlist [ _Bin ] . merge ( _Binlist [ _Bin - 1 ] );
   splice ( begin ( ), _Binlist [ _Maxbin - 1 ] );
   }
  }

 template < class _Pr3 >
  void sort ( _Pr3 _Pred )
  {
  if ( 2 <= _Mysize )
   {
   const size_t _MAXBINS = 25;
   _Myt _Templist ( this -> _Alval ), _Binlist [ _MAXBINS + 1 ];
   size_t _Maxbin = 0;

   while ( ! empty ( ) )
    {
    _Templist . _Splice ( _Templist . begin ( ), * this, begin ( ),
     ++ begin ( ), 1, true );

    size_t _Bin;
    for ( _Bin = 0; _Bin < _Maxbin && ! _Binlist [ _Bin ] . empty ( );
     ++ _Bin )
     {
     _Binlist [ _Bin ] . merge ( _Templist, _Pred );
     _Binlist [ _Bin ] . swap ( _Templist );
     }

    if ( _Bin == _MAXBINS )
     _Binlist [ _Bin - 1 ] . merge ( _Templist, _Pred );
    else
     {
     _Binlist [ _Bin ] . swap ( _Templist );
     if ( _Bin == _Maxbin )
      ++ _Maxbin;
     }
    }

   for ( size_t _Bin = 1; _Bin < _Maxbin; ++ _Bin )
    _Binlist [ _Bin ] . merge ( _Binlist [ _Bin - 1 ],
     _Pred );
   splice ( begin ( ), _Binlist [ _Maxbin - 1 ] );
   }
  }

 void reverse ( )
  {
  if ( 2 <= _Mysize )
   {
   iterator _Last = end ( );
   for ( iterator _Next = ++ begin ( ); _Next != _Last; )
    {
    iterator _Before = _Next;
    _Splice ( begin ( ), * this, _Before, ++ _Next, 1 );
    }
   }
  }

 void _Splice ( const_iterator _Where,
  _Myt & _Right, const_iterator _First, const_iterator _Last,
  size_type _Count, bool _Keep = false )
  {










        _Keep;
  if ( this -> _Alval == _Right . _Alval )
   {


   if ( this != & _Right )
    {
    _Incsize ( _Count );
    _Right . _Mysize -= _Count;
    }
   _Nextnode ( _Prevnode ( _First . _Mynode ( ) ) ) = _Last . _Mynode ( );
   _Nextnode ( _Prevnode ( _Last . _Mynode ( ) ) ) = _Where . _Mynode ( );
   _Nextnode ( _Prevnode ( _Where . _Mynode ( ) ) ) = _First . _Mynode ( );
   _Nodeptr _Pnode = _Prevnode ( _Where . _Mynode ( ) );
   _Prevnode ( _Where . _Mynode ( ) ) = _Prevnode ( _Last . _Mynode ( ) );
   _Prevnode ( _Last . _Mynode ( ) ) = _Prevnode ( _First . _Mynode ( ) );
   _Prevnode ( _First . _Mynode ( ) ) = _Pnode;
   }
  else
   {
   insert ( _Where, _First, _Last );
   _Right . erase ( _First, _Last );
   }
        }

protected :
 void _Assign_n ( size_type _Count, const _Ty & _Val )
  {
  _Ty _Tmp = _Val;
  clear ( );
  _Insert_n ( begin ( ), _Count, _Tmp );
  }

 _Nodeptr _Buynode ( )
  {
  _Nodeptr _Pnode = this -> _Alnod . allocate ( 1 );
  int _Linkcnt = 0;

  try {
  this -> _Alptr . construct ( & _Nextnode ( _Pnode ), _Pnode );
  ++ _Linkcnt;
  this -> _Alptr . construct ( & _Prevnode ( _Pnode ), _Pnode );
  } catch ( ... ) {
  if ( 0 < _Linkcnt )
   this -> _Alptr . destroy ( & _Nextnode ( _Pnode ) );
  this -> _Alnod . deallocate ( _Pnode, 1 );
  throw;
  }
  return ( _Pnode );
  }

 _Nodeptr _Buynode ( _Nodeptr _Next,
  _Nodeptr _Prev, const _Ty & _Val )
  {
  _Nodeptr _Pnode = this -> _Alnod . allocate ( 1 );
  int _Linkcnt = 0;

  try {
  this -> _Alptr . construct ( & _Nextnode ( _Pnode ), _Next );
  ++ _Linkcnt;
  this -> _Alptr . construct ( & _Prevnode ( _Pnode ), _Prev );
  ++ _Linkcnt;
  this -> _Alval . construct ( & _Myval ( _Pnode ), _Val );
  } catch ( ... ) {
  if ( 1 < _Linkcnt )
   this -> _Alptr . destroy ( & _Prevnode ( _Pnode ) );
  if ( 0 < _Linkcnt )
   this -> _Alptr . destroy ( & _Nextnode ( _Pnode ) );
  this -> _Alnod . deallocate ( _Pnode, 1 );
  throw;
  }
  return ( _Pnode );
  }

 void _Tidy ( )
  {
  clear ( );
  this -> _Alptr . destroy ( & _Nextnode ( _Myhead ) );
  this -> _Alptr . destroy ( & _Prevnode ( _Myhead ) );
  this -> _Alnod . deallocate ( _Myhead, 1 );
  _Myhead = 0;
  }

 void _Insert_n ( const_iterator _Where,
  size_type _Count, const _Ty & _Val )
  {
  size_type _Countsave = _Count;

  try {
  for (; 0 < _Count; -- _Count )
   _Insert ( _Where, _Val );
  } catch ( ... ) {
  for (; _Count < _Countsave; ++ _Count )
   {
   const_iterator _Before = _Where;
   erase ( -- _Before );
   }
  throw;
  }
  }

 void _Incsize ( size_type _Count )
  {
  if ( max_size ( ) - _Mysize < _Count )
   throw length_error ( "list<T> too long" );
  _Mysize += _Count;
  }

 static void _Xran ( )
  {
  throw out_of_range ( "invalid list<T> subscript" );
  }

 static void _Xinvarg ( )
  {
  throw invalid_argument ( "invalid list<T> argument" );
  }


















 _Nodeptr _Myhead;
 size_type _Mysize;
 };
#line 1277 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\list"
template<class _Ty, class _Ax> 
class _Move_operation_category< list< _Ty, _Ax> >  { 


public: typedef _Swap_move_tag _Move_cat; 
}; 

template < class _Ty,
 class _Alloc > inline
 void swap ( list < _Ty, _Alloc > & _Left, list < _Ty, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }

template < class _Ty,
 class _Alloc > inline
 bool operator == ( const list < _Ty, _Alloc > & _Left,
  const list < _Ty, _Alloc > & _Right )
 {
 return ( _Left . size ( ) == _Right . size ( )
  && equal ( _Left . begin ( ), _Left . end ( ), _Right . begin ( ) ) );
 }

template < class _Ty,
 class _Alloc > inline
 bool operator != ( const list < _Ty, _Alloc > & _Left,
  const list < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }

template < class _Ty,
 class _Alloc > inline
 bool operator < ( const list < _Ty, _Alloc > & _Left,
  const list < _Ty, _Alloc > & _Right )
 {
 return ( lexicographical_compare ( _Left . begin ( ), _Left . end ( ),
  _Right . begin ( ), _Right . end ( ) ) );
 }

template < class _Ty,
 class _Alloc > inline
 bool operator > ( const list < _Ty, _Alloc > & _Left,
  const list < _Ty, _Alloc > & _Right )
 {
 return ( _Right < _Left );
 }

template < class _Ty,
 class _Alloc > inline
 bool operator <= ( const list < _Ty, _Alloc > & _Left,
  const list < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }

template < class _Ty,
 class _Alloc > inline
 bool operator >= ( const list < _Ty, _Alloc > & _Left,
  const list < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }

#pragma warning(default:4284)
#line 1347 "c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\INCLUDE\\list"
}


#pragma pack ( pop )
#line 22 "../trimesh2/include\\trimesh.h"
using std::vector;



class TriMesh { 

protected: static bool read_helper(const char *, TriMesh *); 



public: struct Face { 
int v[3]; 
float speedInv; 
float T[3]; 
Vec< 3, float>  edgeLens; 

Face() { } 
Face(const int &v0, const int &v1, const int &v2) 
{ 
((this->v)[0]) = v0; ((this->v)[1]) = v1; ((this->v)[2]) = v2; 
} 
Face(const int *v_) 
{ 
((this->v)[0]) = v_[0]; ((this->v)[1]) = v_[1]; ((this->v)[2]) = v_[2]; 
} 
int &operator[](int i) { return (this->v)[i]; } 
const int &operator[](int i) const { return (this->v)[i]; } 
operator const int *() const { return this->v + 0; } 
operator const int *() { return this->v + 0; } 
operator int *() { return this->v + 0; } 
int indexof(int v_) const 
{ 
return (((this->v)[0]) == v_) ? 0 : ((((this->v)[1]) == v_) ? 1 : ((((this->v)[2]) == v_) ? 2 : (-1))); 


} 
}; 

struct BBox { 
point min; point max; 
point center() const { return ((0.5F) * ((this->min) + (this->max))); } 
vec size() const { return ((this->max) - (this->min)); } 
bool valid; 
BBox() : valid(false) 
{ } 
}; 

struct BSphere { 
point center; 
float r; 
bool valid; 
BSphere() : valid(false) 
{ } 
}; 


enum tstrip_rep { TSTRIP_LENGTH, TSTRIP_TERM}; 
enum __cuda_GRID_INVALID { GRID_INVALID = (-1)}; 


std::vector< Vec< 3, float> , std::allocator< Vec< 3, float> > >  vertices; 
std::vector< Face, std::allocator< Face> >  faces; 


std::vector< int, std::allocator< int> >  tstrips; 


std::vector< int, std::allocator< int> >  grid; 
int grid_width; int grid_height; 


std::vector< Color, std::allocator< Color> >  colors; 
std::vector< float, std::allocator< float> >  confidences; 
std::vector< unsigned, std::allocator< unsigned> >  flags; 
unsigned flag_curr; 


std::vector< Vec< 3, float> , std::allocator< Vec< 3, float> > >  normals; 
std::vector< Vec< 3, float> , std::allocator< Vec< 3, float> > >  pdir1; std::vector< Vec< 3, float> , std::allocator< Vec< 3, float> > >  pdir2; 
std::vector< float, std::allocator< float> >  curv1; std::vector< float, std::allocator< float> >  curv2; 
std::vector< Vec< 4, float> , std::allocator< Vec< 4, float> > >  dcurv; 
std::vector< Vec< 3, float> , std::allocator< Vec< 3, float> > >  cornerareas; 
std::vector< float, std::allocator< float> >  pointareas; 
std::vector< float, std::allocator< float> >  vertT; 


BBox bbox; 
BSphere bsphere; 

std::vector< float, std::allocator< float> >  noiseOnVert; 

std::vector< std::vector< Face, std::allocator< Face> > , std::allocator< std::vector< Face, std::allocator< Face> > > >  faceVirtualFaces; 



std::vector< std::vector< int, std::allocator< int> > , std::allocator< std::vector< int, std::allocator< int> > > >  neighbors; 

std::vector< std::vector< int *, std::allocator< int *> > , std::allocator< std::vector< int *, std::allocator< int *> > > >  NonObtuseNeighborFaces; 


std::vector< std::vector< int, std::allocator< int> > , std::allocator< std::vector< int, std::allocator< int> > > >  adjacentfaces; 



std::vector< Face, std::allocator< Face> >  across_edge; 


void need_tstrips(); 
void convert_strips(tstrip_rep); 
void unpack_tstrips(); 
void need_noise(); 
void need_speed(); 
void triangulate_grid(); 
void need_faces(); 
void need_faceedges(); 
void need_normals(); 
void need_pointareas(); 
void need_curvatures(); 
void need_dcurv(); 
void need_bbox(); 
void need_bsphere(); 
void need_neighbors(); 
void need_adjacentfaces(); 
void need_across_edge(); 
void need_face_virtual_faces(); 


static TriMesh *read(const char *); 
void write(const char *); 



float feature_size(); 



bool is_bdy(int v) 
{ 
if ((this->neighbors).empty()) { this->need_neighbors(); }  
if ((this->adjacentfaces).empty()) { this->need_adjacentfaces(); }  
return (this->neighbors)[(v)].size() != (this->adjacentfaces)[(v)].size(); 
} 


vec trinorm(int f) 
{ 
if ((this->faces).empty()) { this->need_faces(); }  
return ::trinorm((this->vertices)[((this->faces)[(f)][0])], (this->vertices)[((this->faces)[(f)][1])], (this->vertices)[((this->faces)[(f)][2])]); 

} 


bool IsNonObtuse(int v, Face f) 
{ 
auto int iV = f.indexof(v); 

auto point A = ((this->vertices)[(v)]); 
auto point B = ((this->vertices)[(f[((iV + 1) % 3)])]); 
auto point C = ((this->vertices)[(f[((iV + 2) % 3)])]); 

auto float a = dist(B, C); 
auto float b = dist(A, C); 
auto float c = dist(A, B); 

auto float angA = ((0.0)); 

if (((a > (0)) && (b > (0))) && (c > (0))) 
{ 
angA = acos(((b * b + c * c) - a * a) / (((2) * b) * c)); 
}  

return angA < ((3.1415926535897931) / ((2.0F))); 

} 


void SplitFace(std::vector< Face, std::allocator< Face> >  &acFaces, int v, Face cf, int nfAdj) 
{ 
#line 209 "../trimesh2/include\\trimesh.h"
auto int iV = cf.indexof(v); 
auto int v1 = v; 
auto int v2 = (cf[((iV + 1) % 3)]); 
auto int v4 = (cf[((iV + 2) % 3)]); 
iV = (this->faces)[(nfAdj)].indexof(v2); 
auto int v3 = ((this->faces)[(nfAdj)][((iV + 1) % 3)]); 


auto Face f1(v1, v3, v4); 
#line 223 "../trimesh2/include\\trimesh.h"
auto Face f2(v1, v2, v3); 
#line 229 "../trimesh2/include\\trimesh.h"
if (this->IsNonObtuse(v, f1)) 
{ 
switch (1) 
{ 


case 2: 
(f1.speedInv) = ((abs((this->curv1)[(f1[0])] + (this->curv2)[(f1[0])]) + abs((this->curv1)[(f1[1])] + (this->curv2)[(f1[1])])) + abs((this->curv1)[(f1[2])] + (this->curv2)[(f1[2])])) / (6); 
break;
case 1: 
(f1.speedInv) = ((1.0)); 
break;
case 3: 
(f1.speedInv) = (((this->noiseOnVert)[(f1[0])] + (this->noiseOnVert)[(f1[1])]) + (this->noiseOnVert)[(f1[2])]) / (3); 
break;
default: 
(f1.speedInv) = ((1.0)); 
break;

}  

auto point edge01 = (((this->vertices)[(f1[1])] - (this->vertices)[(f1[0])])); 
auto point edge12 = (((this->vertices)[(f1[2])] - (this->vertices)[(f1[1])])); 
auto point edge20 = (((this->vertices)[(f1[0])] - (this->vertices)[(f1[2])])); 
(f1.edgeLens)[0] = sqrt((edge01[0] * edge01[0] + edge01[1] * edge01[1]) + edge01[2] * edge01[2]); 
(f1.edgeLens)[1] = sqrt((edge12[0] * edge12[0] + edge12[1] * edge12[1]) + edge12[2] * edge12[2]); 
(f1.edgeLens)[2] = sqrt((edge20[0] * edge20[0] + edge20[1] * edge20[1]) + edge20[2] * edge20[2]); 
acFaces.push_back(f1); 
} else 

{ 
auto int nfAdj_new = ((this->across_edge)[(nfAdj)][(this->faces)[(nfAdj)].indexof(v2)]); 
if (nfAdj_new > (-1)) { 
this->SplitFace(acFaces, v, f1, nfAdj_new); } else { 

printf("NO cross edge!!! Maybe a hole!!\n"); }  


}  

if (this->IsNonObtuse(v, f2)) 
{ 
switch (1) 
{ 


case 2: 
(f2.speedInv) = ((abs((this->curv1)[(f2[0])] + (this->curv2)[(f2[0])]) + abs((this->curv1)[(f2[1])] + (this->curv2)[(f2[1])])) + abs((this->curv1)[(f2[2])] + (this->curv2)[(f2[2])])) / (6); 
break;
case 1: 
(f2.speedInv) = ((1.0)); 
break;
case 3: 
(f2.speedInv) = (((this->noiseOnVert)[(f2[0])] + (this->noiseOnVert)[(f2[1])]) + (this->noiseOnVert)[(f2[2])]) / (3); 
break;
default: 
(f2.speedInv) = ((1.0)); 
break;

}  
auto point edge01 = (((this->vertices)[(f2[1])] - (this->vertices)[(f2[0])])); 
auto point edge12 = (((this->vertices)[(f2[2])] - (this->vertices)[(f2[1])])); 
auto point edge20 = (((this->vertices)[(f2[0])] - (this->vertices)[(f2[2])])); 
(f2.edgeLens)[0] = sqrt((edge01[0] * edge01[0] + edge01[1] * edge01[1]) + edge01[2] * edge01[2]); 
(f2.edgeLens)[1] = sqrt((edge12[0] * edge12[0] + edge12[1] * edge12[1]) + edge12[2] * edge12[2]); 
(f2.edgeLens)[2] = sqrt((edge20[0] * edge20[0] + edge20[1] * edge20[1]) + edge20[2] * edge20[2]); 
acFaces.push_back(f2); 
} else 

{ 
auto int nfAdj_new = ((this->across_edge)[(nfAdj)][(this->faces)[(nfAdj)].indexof(v4)]); 
if (nfAdj_new > (-1)) { 
this->SplitFace(acFaces, v, f2, nfAdj_new); } else { 

printf("NO cross edge!!! Maybe a hole!!\n"); }  
}  
} 


std::vector< Face, std::allocator< Face> >  GetOneRing(int v) 
{ 

if ((this->across_edge).empty()) { 
this->need_across_edge(); }  


auto std::vector< Face, std::allocator< Face> >  oneRingFaces; 
auto std::vector< Face, std::allocator< Face> >  t_faces; 


auto int naf = ((this->adjacentfaces)[(v)].size()); 

if (!(naf)) 
{ 
((((std::cout << ("vertex ")) << v) << (" has 0 adjacent faces...")) << (std::endl)); 
} else 

{ 
for (int af = 0; af < naf; af++) 
{ 
auto Face cf = ((this->faces)[((this->adjacentfaces)[(v)][(af)])]); 

t_faces.clear(); 
if (this->IsNonObtuse(v, cf)) 
{ 
t_faces.push_back(cf); 
} else 

{ 
auto int nfae = ((this->across_edge)[((this->adjacentfaces)[(v)][(af)])][cf.indexof(v)]); 
this->SplitFace(t_faces, v, cf, nfae); 
}  

for (int tf = 0; tf < t_faces.size(); tf++) 
{ 
oneRingFaces.push_back(t_faces[(tf)]); 
}  
}  
}  

return oneRingFaces; 
} 



void InitializeAttributes(std::vector< int, std::allocator< int> >  seeds = std::vector< int, std::allocator< int> > ()) 
{ 

auto int nv = ((this->vertices).size()); 

for (int v = 0; v < nv; v++) 
{ 
(this->vertT).push_back(((10000000.0))); 
}  




if (!seeds.empty()) 
{ 
auto int ns = (seeds.size()); 
for (int s = 0; s < ns; s++) 
{ 
(this->vertT)[(seeds[(s)])] = ((0.0)); 


}  


}  


this->need_neighbors(); 
this->need_normals(); 
this->need_adjacentfaces(); 
this->need_across_edge(); 
this->need_faces(); 
this->need_face_virtual_faces(); 


auto int nf = ((this->faces).size()); 
for (int f = 0; f < nf; f++) 
{ 
auto Face cf = ((this->faces)[(f)]); 


(((this->faces)[(f)].T)[0]) = (this->vertT)[(cf[0])]; 
(((this->faces)[(f)].T)[1]) = (this->vertT)[(cf[1])]; 
(((this->faces)[(f)].T)[2]) = (this->vertT)[(cf[2])]; 



}  
} 


static int verbose; 
static void set_verbose(int); 
static int dprintf(const char *, ...); 


TriMesh() : grid_width((-1)), grid_height((-1)), flag_curr((0)) 
{ } 
}; 
#line 8 "d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu"
void run_reduction__entry(int *con, int *blockCon, int *ActiveList, int nActiveBlock, int *blockSizes);














































#line 56 "d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu"
#line 51 "d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu"




#line 56 "d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu"
#line 54 "d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu"
void FIMCuda__entry(float *d_triMem, float *d_triMemOut, int *d_vertMem, int *d_vertMemOutside, float *d_edgeMem0, float *d_edgeMem1, float *d_edgeMem2, float *d_speed, int *d_BlockSizes, int *d_con, int *ActiveList, int nActiveBlock, int maxNumTotalFaces, int maxNumVert, float m_StopDistance);











































































































































































































































































































































































#line 419 "d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu"
#line 440 "d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu"




#line 445 "d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu"
#line 444 "d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu"
void run_check_neighbor__entry(float *d_triMem, float *d_triMemOut, int *d_vertMem, int *d_vertMemOutside, float *d_edgeMem0, float *d_edgeMem1, float *d_edgeMem2, float *d_speed, int *d_BlockSizes, int *d_con, int *d_ActiveList, int numOldActive, int maxNumTotalFaces, int maxNumVert, int nTotalActive, int m_StopDistance);







































































































































































































































































































































































#line 805 "d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu"

#line 1 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"

extern "C" {
#line 4 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"
#line 1 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.fatbin.c"
#line 1 "C:\\CUDA\\bin64/../include\\__cudaFatFormat.h"


















































































extern "C" {
#line 85 "C:\\CUDA\\bin64/../include\\__cudaFatFormat.h"












typedef struct {
    char*            gpuProfileName;
    char*            cubin;
} __cudaFatCubinEntry;












typedef struct {
    char*            gpuProfileName;            
    char*            ptx;
} __cudaFatPtxEntry;








typedef struct __cudaFatDebugEntryRec {
    char*                   gpuProfileName;            
    char*                   debug;
    struct __cudaFatDebugEntryRec *next;
    unsigned int                   size;
} __cudaFatDebugEntry;


typedef enum {
      __cudaFatDontSearchFlag = (1 << 0),
      __cudaFatDontCacheFlag  = (1 << 1),
      __cudaFatSassDebugFlag  = (1 << 2)
} __cudaFatCudaBinaryFlag;








typedef struct {
    char* name;
} __cudaFatSymbol;










 
typedef struct __cudaFatCudaBinaryRec {
    unsigned long            magic;
    unsigned long            version;
    unsigned long            gpuInfoVersion;
    char*                   key;
    char*                   ident;
    char*                   usageMode;
    __cudaFatPtxEntry             *ptx;
    __cudaFatCubinEntry           *cubin;
    __cudaFatDebugEntry           *debug;
    void*                  debugInfo;
    unsigned int                   flags;
    __cudaFatSymbol               *exported;
    __cudaFatSymbol               *imported;
    struct __cudaFatCudaBinaryRec *dependends;
    unsigned int                   characteristic;
} __cudaFatCudaBinary;



















    typedef enum {
        __cudaFatAvoidPTX,
        __cudaFatPreferBestCode
    } __cudaFatCompilationPolicy;



















void fatGetCubinForGpuWithPolicy( __cudaFatCudaBinary *binary, __cudaFatCompilationPolicy policy, char* gpuName, char* *cubin, char* *dbgInfoFile );










void fatFreeCubin( char* cubin, char* dbgInfoFile );


}
#line 235 "C:\\CUDA\\bin64/../include\\__cudaFatFormat.h"

#line 237 "C:\\CUDA\\bin64/../include\\__cudaFatFormat.h"
#line 2 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.fatbin.c"




extern "C" {
#line 8 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.fatbin.c"

static const unsigned long long __deviceText_$sm_13$[] = {
0x6365746968637261,0x6d737b2065727574,0x62610a0d7d33315f,0x6e6f697372657669,
0x0a0d7d317b202020,0x20656d616e646f6d,0x75637b2020202020,0x6f630a0d7d6e6962,
0x6e090a0d7b206564,0x5a5f203d20656d61,0x68635f6e75723831,0x6769656e5f6b6365,
0x5f536650726f6268,0x535f535f30536950,0x5f30535f535f535f,0x69695f30535f3053,
0x6d6c090a0d696969,0x0a0d30203d206d65,0x203d206d656d7309,0x676572090a0d3038,
0x0a0d3332203d2020,0x203d202072616209,0x736e6f63090a0d31,0x0909090a0d7b2074,
0x20656d616e676573,0x0d74736e6f63203d,0x6e6765730909090a,0x0d31203d20206d75,
0x7366666f0909090a,0x0d30203d20207465,0x657479620909090a,0x3633203d20202073,
0x206d656d09090a0d,0x78300909090a0d7b,0x6330303030303030,0x3030386537783020,
0x6633783020303030,0x3020303030303038,0x3030303030303078,0x300909090a0d2035,
0x3030303030303078,0x6666666678302036,0x3378302066666666,0x2064623733363835,
0x3030303030307830,0x0909090a0d206633,0x3030303865337830,0x7d09090a0d203030,
0x62090a0d7d090a0d,0x7b2065646f636e69,0x3061783009090a0d,0x3020393063343030,
0x3837303032343078,0x3030303178302030,0x3478302039306530,0x2030383734303030,
0x3036783009090a0d,0x3020353038343230,0x3837383032303078,0x3130303378302030,
0x3678302064663565,0x2038633763303234,0x3033783009090a0d,0x3020333030303030,
0x3832303030303078,0x3230303378302030,0x6378302035303230,0x2030383730303134,
0x3032783009090a0d,0x3020353063643030,0x3837343032343078,0x6530306478302030,
0x3878302039313230,0x2030383730306330,0x3031783009090a0d,0x3020353030323030,
0x3837633030343478,0x3330303478302030,0x3078302039303831,0x2030383730303030,
0x3036783009090a0d,0x3020393061313230,0x3837383030303078,0x3031303378302030,
0x6378302039303430,0x2030383730303134,0x3036783009090a0d,0x3020643138313230,
0x3837383030303078,0x3030306178302030,0x3078302039323030,0x2030383730303034,
0x3032783009090a0d,0x3020313065303030,0x3837383230343078,0x3230303378302030,
0x6378302064303030,0x2030383730303134,0x3033783009090a0d,0x3020313030303330,
0x3837303031346378,0x3030303278302030,0x3078302031303630,0x2030383730303034,
0x3034783009090a0d,0x3020643334316334,0x3030303030303078,0x3030303278302033,
0x3078302031303863,0x2030383730303234,0x3064783009090a0d,0x3020393030306530,
0x3837303063303878,0x3030303078302030,0x6378302035306531,0x2030383730303030,
0x3032783009090a0d,0x3020353030383430,0x3030303030303078,0x6530306478302033,
0x3878302035303230,0x2030383730306330,0x3032783009090a0d,0x3020313030383830,
0x3030303030303078,0x6530306478302033,0x3878302031303030,0x2030383730306330,
0x3430783009090a0d,0x3020313038323030,0x3837383032346578,0x3030343078302030,
0x6578302031306132,0x2030383734303234,0x3033783009090a0d,0x3020353063303230,
0x3837303031346378,0x3030343078302030,0x6578302031306332,0x2030383730303234,
0x3061783009090a0d,0x3020333030313530,0x3030303030303078,0x6130303378302030,
0x3678302064663365,0x2038633763303234,0x3032783009090a0d,0x3020313038643030,
0x3837343032343078,0x6530306478302030,0x3878302035303030,0x2030383730306330,
0x3032783009090a0d,0x3020313036643030,0x3837633032343078,0x6530306478302030,
0x3878302064323030,0x2030383730306330,0x3032783009090a0d,0x3020313030643030,
0x3837633032343078,0x6530306478302030,0x3878302031333030,0x2030383730306330,
0x3032783009090a0d,0x3020313032643030,0x3837633032343078,0x6530306478302030,
0x3878302035333030,0x2030383730306330,0x3032783009090a0d,0x3020313034643030,
0x3837633032343078,0x6530306478302030,0x3878302039333030,0x2030383730306330,
0x3031783009090a0d,0x3020333030313530,0x3832303030303078,0x3030303178302030,
0x3478302031303232,0x2030383763303034,0x3034783009090a0d,0x3020393038313130,
0x3837303030303078,0x3030303678302030,0x3078302039306131,0x2030383738303030,
0x3033783009090a0d,0x3020393034303031,0x3837303031346378,0x3030303678302030,
0x3078302031303831,0x2030383738303030,0x3032783009090a0d,0x3020393030303030,
0x3837383230343078,0x3031303178302030,0x3078302031303038,0x2037303030303030,
0x3033783009090a0d,0x3020643034303430,0x3837303031346378,0x3330303378302030,
0x6378302039303430,0x2030383730303134,0x3036783009090a0d,0x3020313030653038,
0x3837303036303678,0x3230303278302030,0x3278302063303638,0x2038306539303030,
0x3033783009090a0d,0x3020313165303130,0x3837303031346378,0x3030303278302030,
0x3078302064306363,0x2030383763303234,0x3064783009090a0d,0x3020313036306530,
0x3837303034303878,0x3030303078302030,0x6378302035303430,0x2030383730303030,
0x3032783009090a0d,0x3020393038303030,0x3837633130343078,0x3430303278302030,
0x3078302031313638,0x2033303030303030,0x3064783009090a0d,0x3020353138306530,
0x3837303034303878,0x3830303278302030,0x3078302031313638,0x2033303030303030,
0x3064783009090a0d,0x3020313138306530,0x3837303034303878,0x3034303278302030,
0x3078302031303030,0x2030383738303034,0x3430783009090a0d,0x3020313030303030,
0x3837303030306578,0x3030303378302030,0x3078302031303430,0x2030383734313034,
0x3430783009090a0d,0x3020313032303030,0x3837303030306578,0x3030303378302030,
0x3078302031303430,0x2030383730313034,0x3032783009090a0d,0x3020313136386330,
0x3030303030303078,0x6530306478302033,0x3878302035313830,0x2030383730303430,
0x3430783009090a0d,0x3020313034303030,0x3837303030306578,0x3031303278302030,
0x3078302031303638,0x2033303030303030,0x3064783009090a0d,0x3020313130306530,
0x3837303034303878,0x3431303278302030,0x3078302031303638,0x2033303030303030,
0x3064783009090a0d,0x3020643030306530,0x3837303034303878,0x3030303378302030,
0x3078302031303430,0x2030383734313034,0x3430783009090a0d,0x3020313036303030,
0x3837303030306578,0x3030303378302030,0x3078302031303430,0x2030383730313034,
0x3033783009090a0d,0x3020393034303030,0x3837633030343078,0x3030343078302030,
0x6578302031303830,0x2030383730303030,0x3430783009090a0d,0x3020313061303030,
0x3837303130306578,0x3030306678302030,0x6578302031303030,0x2032303030303030,
0x3638783009090a0d,0x3020333065666631,0x3030303030303078,0x6130303378302030,
0x3678302031303230,0x2030633730313034,0x3061783009090a0d,0x3020646631303030,
0x6437343130633078,0x3630306178302038,0x3078302033303030,0x2030303030303030,
0x3031783009090a0d,0x3020333030663530,0x3031303030303078,0x3031303178302030,
0x3078302031303038,0x2037303030303030,0x3036783009090a0d,0x3020313030653038,
0x3837303036303678,0x3030303278302030,0x3078302031306531,0x2030383730303034,
0x3030783009090a0d,0x3020353030303030,0x3837303030306378,0x3030346178302030,
0x3078302031303038,0x2030383730313234,0x3030783009090a0d,0x3020353030303230,
0x3837303030306378,0x3030343178302030,0x3478302031303832,0x2030383763303034,
0x3031783009090a0d,0x3020333030303630,0x3837303030303078,0x3030303178302030,
0x3078302031303038,0x2062363938316234,0x3030783009090a0d,0x3020353065313030,
0x3837303030306378,0x3030343178302032,0x3478302035303832,0x2030383763303034,
0x3031783009090a0d,0x3020393030383030,0x3030303030303078,0x3031303178302033,
0x3078302064303038,0x2066323133363134,0x3061783009090a0d,0x3020313132303030,
0x3837303034346378,0x3230306578302030,0x6578302064663930,0x2038633738313030,
0x3061783009090a0d,0x3020333030656232,0x3030303030303078,0x3030343178302030,
0x3478302035303832,0x2030383763303034,0x3431783009090a0d,0x3020643061323030,
0x3837633030343478,0x3030343178302030,0x3478302039306332,0x2030383763303034,
0x3031783009090a0d,0x3020333030623730,0x3031303030303078,0x3030303078302030,
0x6378302035306531,0x2030383730303030,0x3431783009090a0d,0x3020643061323030,
0x3837633030343478,0x3030303178302030,0x3078302031323038,0x2033303030303030,
0x3031783009090a0d,0x3020353230383031,0x3231333631343078,0x3030306178302066,
0x6378302031313630,0x2030383730303434,0x3065783009090a0d,0x3020646639303830,
0x6337383130306578,0x3030343178302038,0x3478302064306132,0x2030383763303034,
0x3031783009090a0d,0x3020333030623730,0x3031303030303078,0x3030303078302030,
0x6378302035306531,0x2030383730303030,0x3431783009090a0d,0x3020393063323030,
0x3837633030343478,0x3030303178302030,0x3078302031323038,0x2033303030303030,
0x3031783009090a0d,0x3020353230383031,0x3231333631343078,0x3030306178302066,
0x6378302031313430,0x2030383730303434,0x3065783009090a0d,0x3020646639303830,
0x6337383130306578,0x3030343178302038,0x3478302039306332,0x2030383763303034,
0x3031783009090a0d,0x3020333030656232,0x3832303030303078,0x3334306278302030,
0x6378302038343430,0x2034323631623030,0x3063783009090a0d,0x3020343134323231,
0x3132316430306378,0x6430306578302030,0x3078302035313830,0x2030383734313038,
0x3063783009090a0d,0x3020343161313530,0x3261313530306378,0x6330306578302030,
0x3078302031343631,0x2030383763303030,0x3065783009090a0d,0x3020353436316530,
0x3837383030303078,0x6337306278302030,0x3678302064663131,0x2038633730313030,
0x3061783009090a0d,0x3020333030613331,0x3030303030303078,0x3131306278302030,
0x3678302064663132,0x2038653734303030,0x3031783009090a0d,0x3020333030653231,
0x3031303030303078,0x6330306278302030,0x6378302063343831,0x2034356131343030,
0x3062783009090a0d,0x3020343161316430,0x3561316430306378,0x6430306378302038,
0x3078302031353632,0x2030383730303030,0x3063783009090a0d,0x3020313138313030,
0x3030303830343078,0x3231306578302033,0x3078302035353432,0x2030383734353038,
0x3065783009090a0d,0x3020393538316330,0x3837383530303078,0x3138306278302030,
0x3678302064663932,0x2038633730313530,0x3063783009090a0d,0x3020343138313530,
0x3138313430306378,0x6530306578302030,0x3078302039356331,0x2030383738353034,
0x3063783009090a0d,0x3020393563323838,0x3836303034303078,0x3838306378302030,
0x3078302031353832,0x2030383630303430,0x3039783009090a0d,0x3020303538323030,
0x3563323431306378,0x3530306378302030,0x6378302034313832,0x2034356132353030,
0x3063783009090a0d,0x3020303130313430,0x3134323430306378,0x3430306378302030,
0x3078302031313432,0x2030383730303030,0x3165783009090a0d,0x3020353138323431,
0x3837383034343078,0x3430306378302030,0x3078302031316130,0x2030383730303030,
0x3039783009090a0d,0x3020353138303030,0x3837303030303478,0x3830306278302030,
0x3978302030313031,0x2030326130303030,0x3062783009090a0d,0x3020646639303138,
0x6337303135303678,0x3230303178302038,0x6278302034313838,0x2038356161383030,
0x3063783009090a0d,0x3020393563323838,0x3836303034303078,0x3838306378302030,
0x3078302031313830,0x2030383630303430,0x3039783009090a0d,0x3020303138303030,
0x3163323430306378,0x3030306278302030,0x3078302031326132,0x2030383730323030,
0x3062783009090a0d,0x3020646639306337,0x6337383130303678,0x3238306278302038,
0x3678302064663930,0x2038633263303430,0x3061783009090a0d,0x3020333030646130,
0x3030303030303078,0x3030306178302030,0x6578302031323031,0x2030383734303034,
0x3031783009090a0d,0x3020333030636130,0x3031303030303078,0x6430306378302030,
0x6378302038353830,0x2034356332363130,0x3063783009090a0d,0x3020393563323331,
0x3837303030303078,0x6330306578302030,0x3078302035353831,0x2030383734353030,
0x3065783009090a0d,0x3020353538323631,0x3837343530343078,0x3030303978302030,
0x3478302035356132,0x2030383730303030,0x3065783009090a0d,0x3020313138303231,
0x3837633030303078,0x3030303978302030,0x3078302035356132,0x2030383730303030,
0x3065783009090a0d,0x3020313136313531,0x3837303130303078,0x6130303178302030,
0x3078302033303064,0x2030383730303030,0x3031783009090a0d,0x3020313130383030,
0x3639383162343078,0x3138306278302062,0x3678302064666230,0x2061633730313530,
0x3063783009090a0d,0x3020313230313838,0x3836303034303078,0x3838306378302030,
0x3078302035316130,0x2030383630303430,0x3039783009090a0d,0x3020343161303030,
0x3230313530306378,0x6337306278302030,0x3678302064663131,0x2038633738313030,
0x3062783009090a0d,0x3020646631313238,0x6332633034303678,0x6230306178302038,
0x3078302033303066,0x2030303030303030,0x3031783009090a0d,0x3020333030656230,
0x3031303030303078,0x3231306578302030,0x3078302035313031,0x2030383763303030,
0x3063783009090a0d,0x3020303230316430,0x3430313331306378,0x3830306378302038,
0x3078302031323031,0x2030383730303030,0x3065783009090a0d,0x3020313238316330,
0x3837303230303078,0x3231306578302030,0x3078302031323832,0x2030383730323034,
0x3039783009090a0d,0x3020313230313030,0x3837303030303478,0x3030303978302030,
0x3078302031323031,0x2030383730303030,0x3065783009090a0d,0x3020353136313830,
0x3837343130303078,0x6230303178302030,0x3078302033303066,0x2030383730303030,
0x3031783009090a0d,0x3020353130383030,0x3639383162343078,0x3030306678302062,
0x6578302031303030,0x2032303030303030,0x3061783009090a0d,0x3020333030396330,
0x3030303030303078,0x6330303178302030,0x3078302033303036,0x2030303132303030,
0x3062783009090a0d,0x3020646631323430,0x6337303130303678,0x3130303178302038,
0x3078302031323038,0x2033303030303030,0x3031783009090a0d,0x3020313238663030,
0x3832633330343078,0x6330303178302030,0x3078302033303039,0x2030383730303030,
0x3062783009090a0d,0x3020646633323430,0x6337303130303678,0x3130303178302038,
0x3078302031323038,0x2033303030303030,0x3031783009090a0d,0x3020313238663030,
0x3832633330343078,0x6337303378302030,0x3678302064663131,0x2061633738303063,
0x3061783009090a0d,0x3020333030616430,0x3030303030303078,0x6430303178302030,
0x3078302033303037,0x2030383230303030,0x3061783009090a0d,0x3020333030356430,
0x3030303030303078,0x6430303178302030,0x3078302033303032,0x2030303132303030,
0x3062783009090a0d,0x3020646631323530,0x6337303130303678,0x3130303178302038,
0x3078302031323038,0x2033303030303030,0x3031783009090a0d,0x3020313238663030,
0x3832633330343078,0x6430303178302030,0x3078302033303035,0x2030383730303030,
0x3062783009090a0d,0x3020646633323530,0x6337303130303678,0x3130303178302038,
0x3078302031323038,0x2033303030303030,0x3031783009090a0d,0x3020313238663030,
0x3832633330343078,0x3030306678302030,0x6578302031303030,0x2032303030303030,
0x3031783009090a0d,0x3020333030616430,0x3837303030303078,0x3430306278302030,
0x3678302064666230,0x2038633734303030,0x3031783009090a0d,0x3020313230383130,
0x3030303030303078,0x3030303178302033,0x3078302031323866,0x2030383263333034,
0x3033783009090a0d,0x3020646631316337,0x6337383030633678,0x6630306178302061,
0x3078302033303063,0x2030303030303030,0x3031783009090a0d,0x3020333030396630,
0x3832303030303078,0x6530306178302030,0x3078302033303036,0x2030303030303030,
0x3031783009090a0d,0x3020333030336530,0x3031323030303078,0x3430306278302030,
0x3678302064663132,0x2038633730313030,0x3031783009090a0d,0x3020313230383130,
0x3030303030303078,0x3030303178302033,0x3078302031323866,0x2030383263333034,
0x3031783009090a0d,0x3020333030366530,0x3837303030303078,0x3430306278302030,
0x3678302064663332,0x2038633730313030,0x3031783009090a0d,0x3020313230383130,
0x3030303030303078,0x3030303178302033,0x3078302031323866,0x2030383263333034,
0x3033783009090a0d,0x3020646631316337,0x6337383030633678,0x6630306178302061,
0x3078302033303037,0x2030303030303030,0x3031783009090a0d,0x3020333030346630,
0x3832303030303078,0x6630306178302030,0x3078302033303032,0x2030303030303030,
0x3031783009090a0d,0x3020333030666530,0x3031323030303078,0x3130306278302030,
0x3678302064663132,0x2038633730313030,0x3031783009090a0d,0x3020313230383130,
0x3030303030303078,0x3030303178302033,0x3078302031323866,0x2030383263333034,
0x3031783009090a0d,0x3020333030326630,0x3837303030303078,0x3130306278302030,
0x3678302064663332,0x2038633730313030,0x3031783009090a0d,0x3020313230383130,
0x3030303030303078,0x3030303178302033,0x3078302031323866,0x2030383263333034,
0x3066783009090a0d,0x3020313030303030,0x3030303030306578,0x6630303178302032,
0x3078302033303037,0x2030383730303030,0x3062783009090a0d,0x3020646633303430,
0x6337343030303678,0x3130303178302038,0x3078302031323038,0x2033303030303030,
0x3031783009090a0d,0x3020313238663030,0x3832633330343078,0x3030306678302030,
0x6578302031303030,0x2032303030303030,0x3031783009090a0d,0x3020333030636630,
0x3837303030303078,0x3530306278302030,0x3678302064663330,0x2038633734303030,
0x3031783009090a0d,0x3020313230383130,0x3030303030303078,0x3030303178302033,
0x3078302031323866,0x2030383263333034,0x3033783009090a0d,0x3020646631316337,
0x6337383030633678,0x3231306178302061,0x3078302033303063,0x2030303030303030,
0x3031783009090a0d,0x3020333030623231,0x3832303030303078,0x3031306178302030,
0x3078302033303038,0x2030303030303030,0x3031783009090a0d,0x3020333030353031,
0x3031323030303078,0x3430306278302030,0x3678302064663132,0x2038633730313030,
0x3031783009090a0d,0x3020313230383130,0x3030303030303078,0x3030303178302033,
0x3078302031323866,0x2030383263333034,0x3031783009090a0d,0x3020333030383031,
0x3837303030303078,0x3430306278302030,0x3678302064663332,0x2038633730313030,
0x3031783009090a0d,0x3020313230383130,0x3030303030303078,0x3030303178302033,
0x3078302031323866,0x2030383263333034,0x3033783009090a0d,0x3020646631316337,
0x6337383030633678,0x3131306178302061,0x3078302033303039,0x2030303030303030,
0x3031783009090a0d,0x3020333030363131,0x3832303030303078,0x3131306178302030,
0x3078302033303034,0x2030303030303030,0x3031783009090a0d,0x3020333030313131,
0x3031323030303078,0x3530306278302030,0x3678302064663132,0x2038633730313030,
0x3031783009090a0d,0x3020313230383130,0x3030303030303078,0x3030303178302033,
0x3078302031323866,0x2030383263333034,0x3031783009090a0d,0x3020333030343131,
0x3837303030303078,0x3530306278302030,0x3678302064663332,0x2038633730313030,
0x3031783009090a0d,0x3020313230383130,0x3030303030303078,0x3030303178302033,
0x3078302031323866,0x2030383263333034,0x3066783009090a0d,0x3020313030303030,
0x3030303030306578,0x3131303178302032,0x3078302033303039,0x2030383730303030,
0x3062783009090a0d,0x3020646662303430,0x6337343030303678,0x3130303178302038,
0x3078302031323038,0x2033303030303030,0x3031783009090a0d,0x3020313238663030,
0x3832633330343078,0x6337303378302030,0x3678302064663131,0x2061633738303063,
0x3061783009090a0d,0x3020333030393231,0x3030303030303078,0x3231303178302030,
0x3078302033303038,0x2030383230303030,0x3061783009090a0d,0x3020333030353231,
0x3030303030303078,0x3231303178302030,0x3078302033303032,0x2030303132303030,
0x3062783009090a0d,0x3020646631323430,0x6337303130303678,0x3130303178302038,
0x3078302035313038,0x2033303030303030,0x3031783009090a0d,0x3020353138663030,
0x3832633330343078,0x3231303178302030,0x3078302033303035,0x2030383730303030,
0x3062783009090a0d,0x3020646633323430,0x6337303130303678,0x3130303178302038,
0x3078302035313038,0x2033303030303030,0x3031783009090a0d,0x3020353138663030,
0x3832633330343078,0x6337303378302030,0x3678302064666230,0x2061633738303063,
0x3062783009090a0d,0x3020313130323131,0x3035303030306178,0x3231303178302030,
0x3078302033303039,0x2030383730303030,0x3031783009090a0d,0x3020313161303030,
0x3837633330343078,0x3030306678302030,0x6578302031303030,0x2032303030303030,
0x3031783009090a0d,0x3020333030633231,0x3837303030303078,0x3030303178302030,
0x3078302031313230,0x2030383763333036,0x3066783009090a0d,0x3020313030303030,
0x3030303030306578,0x3331303178302032,0x3078302033303061,0x2030383730303030,
0x3061783009090a0d,0x3020333030373331,0x3030303030303078,0x3331303178302030,
0x3078302033303034,0x2030303132303030,0x3062783009090a0d,0x3020646631323130,
0x6337303130303678,0x3130303178302038,0x3078302031313038,0x2033303030303030,
0x3031783009090a0d,0x3020313138663030,0x3832633330343078,0x3331303178302030,
0x3078302033303037,0x2030383730303030,0x3062783009090a0d,0x3020646633323130,
0x6337303130303678,0x3130303178302038,0x3078302031313038,0x2033303030303030,
0x3031783009090a0d,0x3020313138663030,0x3832633330343078,0x6337303378302030,
0x3678302064663930,0x2061633738303063,0x3062783009090a0d,0x3020313130323131,
0x3035303030306178,0x3030303178302030,0x3078302031313230,0x2030383263333034,
0x3062783009090a0d,0x3020393432303030,0x3837383030383078,0x6530306378302032,
0x6378302030323231,0x2034313432323130,0x3065783009090a0d,0x3020353130316530,
0x3837343130383078,0x3530306378302030,0x6378302034316331,0x2034316331353030,
0x3030783009090a0d,0x3020353065313030,0x3837303030306378,0x6330306578302030,
0x3078302031343631,0x2030383734303030,0x3065783009090a0d,0x3020353436316430,
0x3837383030303078,0x6337306278302030,0x3678302064666230,0x2038633730313030,
0x3430783009090a0d,0x3020313038323030,0x3837303132346578,0x6631306178302030,
0x3078302033303062,0x2030303030303030,0x3062783009090a0d,0x3020646631323131,
0x6537303130303678,0x6531303178302038,0x3078302033303066,0x2030303130303030,
0x3062783009090a0d,0x3020633461316430,0x3563313830306378,0x6530306378302034,
0x6278302038356331,0x2030326331653030,0x3063783009090a0d,0x3020313536326530,
0x3837303030303078,0x3030306378302030,0x3078302031316131,0x2033303030383034,
0x3065783009090a0d,0x3020353534323231,0x3837343530383078,0x6430306578302030,
0x3078302039356131,0x2030383738353030,0x3062783009090a0d,0x3020646639323138,
0x6337303135303678,0x3830306378302038,0x6378302030326131,0x2030316131343030,
0x3065783009090a0d,0x3020393538316330,0x3837383530343078,0x3838306378302030,
0x3078302039356332,0x2030383630303430,0x3063783009090a0d,0x3020313538323838,
0x3836303034303078,0x3030303978302030,0x6378302030353832,0x2030356332343130,
0x3063783009090a0d,0x3020303238323830,0x3261323830306378,0x3430306378302030,
0x6378302030316130,0x2030313432343030,0x3063783009090a0d,0x3020313134323430,
0x3837303030303078,0x3431316578302030,0x3078302035353832,0x2030383738303434,
0x3063783009090a0d,0x3020313161323430,0x3837303030303078,0x3030303978302030,
0x3478302035353830,0x2030383730303030,0x3062783009090a0d,0x3020303161303530,
0x3561323030303978,0x3138306278302034,0x3678302064663930,0x2038633730313530,
0x3031783009090a0d,0x3020343138383230,0x3530393531306278,0x3838306378302038,
0x3078302039356332,0x2030383630303430,0x3063783009090a0d,0x3020313138303838,
0x3836303034303078,0x3030303978302030,0x6378302030313830,0x2030316332343030,
0x3062783009090a0d,0x3020313230313030,0x3837343530303078,0x6337306278302030,
0x3678302064663930,0x2038633738313030,0x3062783009090a0d,0x3020646639303238,
0x6332633034303678,0x3631306178302038,0x3078302033303065,0x2030303030303030,
0x3061783009090a0d,0x3020313230313030,0x3837343030346578,0x3631303178302030,
0x3078302033303064,0x2030303130303030,0x3063783009090a0d,0x3020383538306530,
0x3563323631306378,0x3331306378302034,0x3078302039356332,0x2030383730303030,
0x3065783009090a0d,0x3020353561316430,0x3837343530303078,0x3631306578302030,
0x3078302035353832,0x2030383734353034,0x3039783009090a0d,0x3020353561323030,
0x3837303030303478,0x3231306578302030,0x3078302031313830,0x2030383738303030,
0x3039783009090a0d,0x3020353561323030,0x3837303030303078,0x3531306578302030,
0x3078302031313631,0x2030383730313030,0x3031783009090a0d,0x3020333030653631,
0x3837303030303078,0x3030303178302030,0x3078302031313038,0x2062363938316234,
0x3062783009090a0d,0x3020646662303138,0x6337303135303678,0x3838306378302061,
0x3078302031323031,0x2030383630303430,0x3063783009090a0d,0x3020353161303838,
0x3836303034303078,0x3030303978302030,0x6378302034316130,0x2030323031353030,
0x3062783009090a0d,0x3020646631316337,0x6337383130303678,0x3238306278302038,
0x3678302064663131,0x2038633263303430,0x3061783009090a0d,0x3020333030303831,
0x3030303030303078,0x3731303178302030,0x3078302033303066,0x2030303130303030,
0x3065783009090a0d,0x3020353130313231,0x3837383030303078,0x6530306378302030,
0x6378302030323031,0x2038343031333130,0x3063783009090a0d,0x3020313230313830,
0x3837303030303078,0x6430306578302030,0x3078302031326131,0x2030383730323030,
0x3065783009090a0d,0x3020313238323231,0x3837303230343078,0x3030303978302030,
0x3478302031323031,0x2030383730303030,0x3039783009090a0d,0x3020313230313030,
0x3837303030303078,0x3830306578302030,0x3078302035313631,0x2030383734313030,
0x3031783009090a0d,0x3020333030303831,0x3837303030303078,0x3030303178302030,
0x3078302035313038,0x2062363938316234,0x3066783009090a0d,0x3020313030303030,
0x3030303030306578,0x3831306178302032,0x3078302033303061,0x2030303030303030,
0x3031783009090a0d,0x3020333030373831,0x3031323030303078,0x3430306278302030,
0x3678302064663332,0x2038633730313030,0x3031783009090a0d,0x3020313230383130,
0x3030303030303078,0x3030303178302033,0x3078302031323866,0x2030383263333034,
0x3031783009090a0d,0x3020333030613831,0x3837303030303078,0x3430306278302030,
0x3678302064663132,0x2038633730313030,0x3031783009090a0d,0x3020313230383130,
0x3030303030303078,0x3030303178302033,0x3078302031323866,0x2030383263333034,
0x3033783009090a0d,0x3020646631316337,0x6337383030633678,0x3931306178302061,
0x3078302033303062,0x2030303030303030,0x3031783009090a0d,0x3020333030383931,
0x3832303030303078,0x3931306178302030,0x3078302033303036,0x2030303030303030,
0x3031783009090a0d,0x3020333030333931,0x3031323030303078,0x3530306278302030,
0x3678302064663332,0x2038633730313030,0x3031783009090a0d,0x3020313230383130,
0x3030303030303078,0x3030303178302033,0x3078302031323866,0x2030383263333034,
0x3031783009090a0d,0x3020333030363931,0x3837303030303078,0x3530306278302030,
0x3678302064663132,0x2038633730313030,0x3031783009090a0d,0x3020313230383130,
0x3030303030303078,0x3030303178302033,0x3078302031323866,0x2030383263333034,
0x3066783009090a0d,0x3020313030303030,0x3030303030306578,0x3931303178302032,
0x3078302033303062,0x2030383730303030,0x3062783009090a0d,0x3020646662303430,
0x6337343030303678,0x3130303178302038,0x3078302031323038,0x2033303030303030,
0x3031783009090a0d,0x3020313238663030,0x3832633330343078,0x6337303378302030,
0x3678302064663131,0x2061633738303063,0x3061783009090a0d,0x3020333030646231,
0x3030303030303078,0x6231303178302030,0x3078302033303061,0x2030383230303030,
0x3061783009090a0d,0x3020333030376131,0x3030303030303078,0x6131303178302030,
0x3078302033303034,0x2030303132303030,0x3062783009090a0d,0x3020646633323430,
0x6337303130303678,0x3130303178302038,0x3078302031323038,0x2033303030303030,
0x3031783009090a0d,0x3020313238663030,0x3832633330343078,0x6131303178302030,
0x3078302033303037,0x2030383730303030,0x3062783009090a0d,0x3020646631323430,
0x6337303130303678,0x3130303178302038,0x3078302031323038,0x2033303030303030,
0x3031783009090a0d,0x3020313238663030,0x3832633330343078,0x6337303378302030,
0x3678302064663131,0x2061633738303063,0x3061783009090a0d,0x3020333030386231,
0x3030303030303078,0x6231303178302030,0x3078302033303035,0x2030383230303030,
0x3061783009090a0d,0x3020333030336231,0x3030303030303078,0x6231303178302030,
0x3078302033303030,0x2030303132303030,0x3062783009090a0d,0x3020646633323330,
0x6337303130303678,0x3130303178302038,0x3078302031323038,0x2033303030303030,
0x3031783009090a0d,0x3020313238663030,0x3832633330343078,0x6231303178302030,
0x3078302033303033,0x2030383730303030,0x3062783009090a0d,0x3020646631323330,
0x6337303130303678,0x3130303178302038,0x3078302031323038,0x2033303030303030,
0x3031783009090a0d,0x3020313238663030,0x3832633330343078,0x3030306678302030,
0x6578302031303030,0x2032303030303030,0x3031783009090a0d,0x3020333030386231,
0x3837303030303078,0x3430306278302030,0x3678302064663730,0x2038633734303030,
0x3031783009090a0d,0x3020313230383130,0x3030303030303078,0x3030303178302033,
0x3078302031323866,0x2030383263333034,0x3066783009090a0d,0x3020313030303030,
0x3030303030306578,0x6231303178302032,0x3078302033303064,0x2030383730303030,
0x3062783009090a0d,0x3020646637303530,0x6337343030303678,0x3130303178302038,
0x3078302031323038,0x2033303030303030,0x3031783009090a0d,0x3020313238663030,
0x3832633330343078,0x6337303378302030,0x3678302064663131,0x2061633738303063,
0x3061783009090a0d,0x3020333030646531,0x3030303030303078,0x6531303178302030,
0x3078302033303063,0x2030383230303030,0x3061783009090a0d,0x3020333030396331,
0x3030303030303078,0x6331303178302030,0x3078302033303036,0x2030303132303030,
0x3062783009090a0d,0x3020646633323430,0x6337303130303678,0x3130303178302038,
0x3078302031323038,0x2033303030303030,0x3031783009090a0d,0x3020313238663030,
0x3832633330343078,0x6331303178302030,0x3078302033303039,0x2030383730303030,
0x3062783009090a0d,0x3020646631323430,0x6337303130303678,0x3130303178302038,
0x3078302031323038,0x2033303030303030,0x3031783009090a0d,0x3020313238663030,
0x3832633330343078,0x6337303378302030,0x3678302064663131,0x2061633738303063,
0x3061783009090a0d,0x3020333030616431,0x3030303030303078,0x6431303178302030,
0x3078302033303037,0x2030383230303030,0x3061783009090a0d,0x3020333030356431,
0x3030303030303078,0x6431303178302030,0x3078302033303032,0x2030303132303030,
0x3062783009090a0d,0x3020646633323530,0x6337303130303678,0x3130303178302038,
0x3078302031323038,0x2033303030303030,0x3031783009090a0d,0x3020313238663030,
0x3832633330343078,0x6431303178302030,0x3078302033303035,0x2030383730303030,
0x3062783009090a0d,0x3020646631323530,0x6337303130303678,0x3130303178302038,
0x3078302031323038,0x2033303030303030,0x3031783009090a0d,0x3020313238663030,
0x3832633330343078,0x3030306678302030,0x6578302031303030,0x2032303030303030,
0x3031783009090a0d,0x3020333030616431,0x3837303030303078,0x3430306278302030,
0x3678302064666230,0x2038633734303030,0x3031783009090a0d,0x3020313230383130,
0x3030303030303078,0x3030303178302033,0x3078302031323866,0x2030383263333034,
0x3033783009090a0d,0x3020646631316337,0x6337383030633678,0x6531306178302061,
0x3078302033303061,0x2030303030303030,0x3031783009090a0d,0x3020333030396531,
0x3832303030303078,0x6531306178302030,0x3078302033303036,0x2030303030303030,
0x3031783009090a0d,0x3020333030336531,0x3031323030303078,0x3430306278302030,
0x3678302064663332,0x2038633730313030,0x3031783009090a0d,0x3020353130383130,
0x3030303030303078,0x3030303178302033,0x3078302035313866,0x2030383263333034,
0x3031783009090a0d,0x3020333030366531,0x3837303030303078,0x3430306278302030,
0x3678302064663132,0x2038633730313030,0x3031783009090a0d,0x3020353130383130,
0x3030303030303078,0x3030303178302033,0x3078302035313866,0x2030383263333034,
0x3033783009090a0d,0x3020646662306337,0x6337383030633678,0x3131306278302061,
0x6178302031313032,0x2030303530303030,0x3031783009090a0d,0x3020333030616531,
0x3837303030303078,0x3030303178302030,0x3078302031316130,0x2030383763333034,
0x3066783009090a0d,0x3020313030303030,0x3030303030306578,0x6531303178302032,
0x3078302033303064,0x2030383730303030,0x3031783009090a0d,0x3020313136303030,
0x3837633330363078,0x3030306678302030,0x6578302031303030,0x2032303030303030,
0x3031783009090a0d,0x3020333030626631,0x3837303030303078,0x6631306178302030,
0x3078302033303038,0x2030303030303030,0x3031783009090a0d,0x3020333030356631,
0x3031323030303078,0x3330306278302030,0x3678302064663332,0x2038633730313030,
0x3031783009090a0d,0x3020313130383130,0x3030303030303078,0x3030303178302033,
0x3078302031313866,0x2030383263333034,0x3031783009090a0d,0x3020333030386631,
0x3837303030303078,0x3330306278302030,0x3678302064663132,0x2038633730313030,
0x3031783009090a0d,0x3020313130383130,0x3030303030303078,0x3030303178302033,
0x3078302031313866,0x2030383263333034,0x3033783009090a0d,0x3020646639306337,
0x6337383030633678,0x3131306278302061,0x6178302031313032,0x2030303530303030,
0x3031783009090a0d,0x3020313136303030,0x3832633330343078,0x3030306278302030,
0x3078302031343630,0x2032383734303038,0x3063783009090a0d,0x3020383432316330,
0x3130323031306378,0x6330306578302034,0x3078302035313432,0x2030383734313038,
0x3063783009090a0d,0x3020343138313530,0x3138313530306378,0x3030303078302034,
0x6378302035306531,0x2030383730303030,0x3065783009090a0d,0x3020353236316430,
0x3837633030303078,0x6530306578302030,0x3078302031323631,0x2030383734303030,
0x3062783009090a0d,0x3020646662306337,0x6337303130303678,0x3030343078302038,
0x6578302031306132,0x2030383730313234,0x3061783009090a0d,0x3020333030636232,
0x3030303030303078,0x3930306278302030,0x3678302064663131,0x2038653734303030,
0x3031783009090a0d,0x3020333030306232,0x3031303030303078,0x6530306378302030,
0x3078302064306331,0x2030383730303030,0x3065783009090a0d,0x3020643038316330,
0x3837633030303078,0x3030306278302030,0x3078302035346331,0x2030383738333030,
0x3065783009090a0d,0x3020353361316430,0x3837633030343078,0x6330306378302030,
0x6378302063303232,0x2030313831323130,0x3063783009090a0d,0x3020393463313030,
0x3030303830343078,0x3030306278302033,0x3078302031353831,0x2030383730333030,
0x3062783009090a0d,0x3020646637303138,0x6337303135303678,0x3031306578302038,
0x3078302031313032,0x2030383730313038,0x3063783009090a0d,0x3020633463313231,
0x3463313431306378,0x3838306378302038,0x3078302035336131,0x2030383630303430,
0x3063783009090a0d,0x3020643036303838,0x3836303034303078,0x3331306378302030,
0x3978302063346130,0x2063303630303030,0x3063783009090a0d,0x3020633430323331,
0x3361313330306378,0x3331306378302034,0x3078302064303032,0x2030383730303030,
0x3165783009090a0d,0x3020643461316430,0x3837383034343078,0x3330306378302030,
0x6378302063303632,0x2038346131323130,0x3039783009090a0d,0x3020643436303030,
0x3837303030303478,0x3530306278302030,0x6378302063306130,0x2034313830323130,
0x3039783009090a0d,0x3020393436323030,0x3837303030303078,0x3138306278302030,
0x3678302064663730,0x2038633730313530,0x3031783009090a0d,0x3020303136383230,
0x3461383231306278,0x3838306378302063,0x3078302064343632,0x2030383630303430,
0x3063783009090a0d,0x3020643036303838,0x3836303034303078,0x3030303978302030,
0x6378302063303630,0x2063303632333030,0x3062783009090a0d,0x3020646637306337,
0x6337383130303678,0x3030306278302038,0x3078302035316130,0x2030383738343030,
0x3062783009090a0d,0x3020646637303238,0x6332633034303678,0x3332306178302038,
0x3078302033303030,0x2030303030303030,0x3061783009090a0d,0x3020353161303030,
0x3837343030346578,0x3232303178302030,0x3078302033303066,0x2030303130303030,
0x3063783009090a0d,0x3020383436306330,0x3434323231306378,0x3131306378302063,
0x3078302031353432,0x2030383730303030,0x3065783009090a0d,0x3020393463316530,
0x3837633430303078,0x3431306578302030,0x3078302039346131,0x2030383738343034,
0x3039783009090a0d,0x3020393434323030,0x3837303030303478,0x3031306578302030,
0x3078302064303630,0x2030383734303030,0x3039783009090a0d,0x3020393434323030,
0x3837303030303078,0x3231306578302030,0x3078302064303631,0x2030383763303030,
0x3031783009090a0d,0x3020333030303332,0x3837303030303078,0x3030303178302030,
0x3078302064303038,0x2062363938316234,0x3062783009090a0d,0x3020646639303138,
0x6337303135303678,0x3838306378302061,0x3078302035316130,0x2030383630303430,
0x3063783009090a0d,0x3020313138303838,0x3836303034303078,0x3030303978302030,
0x6378302030313830,0x2030316130343030,0x3062783009090a0d,0x3020646639306337,
0x6337383130303678,0x3238306278302038,0x3678302064663930,0x2038633263303430,
0x3061783009090a0d,0x3020333030323432,0x3030303030303078,0x3432303178302030,
0x3078302033303031,0x2030303130303030,0x3063783009090a0d,0x3020343138306330,
0x3361303530306378,0x3131306378302030,0x3078302035346130,0x2030383730303030,
0x3065783009090a0d,0x3020353163316530,0x3837303330303078,0x3131306578302030,
0x3078302035316131,0x2030383734313034,0x3039783009090a0d,0x3020353161303030,
0x3837303030303478,0x3031306578302030,0x3078302031313830,0x2030383734303030,
0x3039783009090a0d,0x3020353061303030,0x3837303030303078,0x3130306578302030,
0x3078302035303631,0x2030383730313030,0x3031783009090a0d,0x3020333030323432,
0x3837303030303078,0x3030303178302030,0x3078302035303038,0x2062363938316234,
0x3066783009090a0d,0x3020313030303030,0x3030303030306578,0x3432306178302032,
0x3078302033303063,0x2030303030303030,0x3031783009090a0d,0x3020333030393432,
0x3031323030303078,0x3330306278302030,0x3678302064663131,0x2038633730313030,
0x3031783009090a0d,0x3020313130383130,0x3030303030303078,0x3030303178302033,
0x3078302031313866,0x2030383263333034,0x3031783009090a0d,0x3020333030633432,
0x3837303030303078,0x3330306278302030,0x3678302064663331,0x2038633730313030,
0x3031783009090a0d,0x3020313130383130,0x3030303030303078,0x3030303178302033,
0x3078302031313866,0x2030383263333034,0x3033783009090a0d,0x3020646639306337,
0x6337383030633678,0x3532306178302061,0x3078302033303064,0x2030303030303030,
0x3031783009090a0d,0x3020333030613532,0x3832303030303078,0x3532306178302030,
0x3078302033303038,0x2030303030303030,0x3031783009090a0d,0x3020333030353532,
0x3031323030303078,0x3130306278302030,0x3678302064663131,0x2038633730313030,
0x3031783009090a0d,0x3020313130383130,0x3030303030303078,0x3030303178302033,
0x3078302031313866,0x2030383263333034,0x3031783009090a0d,0x3020333030383532,
0x3837303030303078,0x3130306278302030,0x3678302064663331,0x2038633730313030,
0x3031783009090a0d,0x3020313130383130,0x3030303030303078,0x3030303178302033,
0x3078302031313866,0x2030383263333034,0x3066783009090a0d,0x3020313030303030,
0x3030303030306578,0x3532303178302032,0x3078302033303064,0x2030383730303030,
0x3062783009090a0d,0x3020646633303330,0x6337343030303678,0x3130303178302038,
0x3078302031313038,0x2033303030303030,0x3031783009090a0d,0x3020313138663030,
0x3832633330343078,0x6337303378302030,0x3678302064663930,0x2061633738303063,
0x3061783009090a0d,0x3020333030663732,0x3030303030303078,0x3732303178302030,
0x3078302033303063,0x2030383230303030,0x3061783009090a0d,0x3020333030393632,
0x3030303030303078,0x3632303178302030,0x3078302033303036,0x2030303132303030,
0x3062783009090a0d,0x3020646631313330,0x6337303130303678,0x3130303178302038,
0x3078302031313038,0x2033303030303030,0x3031783009090a0d,0x3020313138663030,
0x3832633330343078,0x3632303178302030,0x3078302033303039,0x2030383730303030,
0x3062783009090a0d,0x3020646633313330,0x6337303130303678,0x3130303178302038,
0x3078302031313038,0x2033303030303030,0x3031783009090a0d,0x3020313138663030,
0x3832633330343078,0x6337303378302030,0x3678302064663930,0x2061633738303063,
0x3061783009090a0d,0x3020333030613732,0x3030303030303078,0x3732303178302030,
0x3078302033303037,0x2030383230303030,0x3061783009090a0d,0x3020333030353732,
0x3030303030303078,0x3732303178302030,0x3078302033303032,0x2030303132303030,
0x3062783009090a0d,0x3020646631313230,0x6337303130303678,0x3130303178302038,
0x3078302031313038,0x2033303030303030,0x3031783009090a0d,0x3020313138663030,
0x3832633330343078,0x3732303178302030,0x3078302033303035,0x2030383730303030,
0x3062783009090a0d,0x3020646633313230,0x6337303130303678,0x3130303178302038,
0x3078302031313038,0x2033303030303030,0x3031783009090a0d,0x3020313138663030,
0x3832633330343078,0x3030306678302030,0x6578302031303030,0x2032303030303030,
0x3031783009090a0d,0x3020333030613732,0x3837303030303078,0x3330306278302030,
0x3678302064663530,0x2038633734303030,0x3031783009090a0d,0x3020313130383130,
0x3030303030303078,0x3030303178302033,0x3078302031313866,0x2030383263333034,
0x3066783009090a0d,0x3020313030303030,0x3030303030306578,0x3732303178302032,
0x3078302033303066,0x2030383730303030,0x3062783009090a0d,0x3020646635303130,
0x6337343030303678,0x3130303178302038,0x3078302031313038,0x2033303030303030,
0x3031783009090a0d,0x3020313138663030,0x3832633330343078,0x6337303378302030,
0x3678302064663930,0x2061633738303063,0x3061783009090a0d,0x3020333030656132,
0x3030303030303078,0x6132303178302030,0x3078302033303064,0x2030383230303030,
0x3061783009090a0d,0x3020333030623832,0x3030303030303078,0x3832303178302030,
0x3078302033303038,0x2030303132303030,0x3062783009090a0d,0x3020646631313330,
0x6337303130303678,0x3130303178302038,0x3078302039303038,0x2033303030303030,
0x3031783009090a0d,0x3020393038663030,0x3832633330343078,0x3832303178302030,
0x3078302033303062,0x2030383730303030,0x3062783009090a0d,0x3020646633313330,
0x6337303130303678,0x3130303178302038,0x3078302039303038,0x2033303030303030,
0x3031783009090a0d,0x3020393038663030,0x3832633330343078,0x6337303378302030,
0x3678302064663530,0x2061633738303063,0x3061783009090a0d,0x3020333030633932,
0x3030303030303078,0x3932303178302030,0x3078302033303039,0x2030383230303030,
0x3061783009090a0d,0x3020333030373932,0x3030303030303078,0x3932303178302030,
0x3078302033303034,0x2030303132303030,0x3062783009090a0d,0x3020646631313130,
0x6337303130303678,0x3130303178302038,0x3078302039303038,0x2033303030303030,
0x3031783009090a0d,0x3020393038663030,0x3832633330343078,0x3932303178302030,
0x3078302033303037,0x2030383730303030,0x3062783009090a0d,0x3020646633313130,
0x6337303130303678,0x3130303178302038,0x3078302039303038,0x2033303030303030,
0x3031783009090a0d,0x3020393038663030,0x3832633330343078,0x3030306678302030,
0x6578302031303030,0x2032303030303030,0x3031783009090a0d,0x3020333030633932,
0x3837303030303078,0x3330306278302030,0x3678302064663330,0x2038633734303030,
0x3031783009090a0d,0x3020393030383130,0x3030303030303078,0x3030303178302033,
0x3078302039303866,0x2030383263333034,0x3033783009090a0d,0x3020646635306337,
0x6337383030633678,0x6132306178302061,0x3078302033303062,0x2030303030303030,
0x3031783009090a0d,0x3020333030626132,0x3832303030303078,0x6132306178302030,
0x3078302033303038,0x2030303030303030,0x3031783009090a0d,0x3020333030356132,
0x3031323030303078,0x3330306278302030,0x3678302064663131,0x2038633730313030,
0x3031783009090a0d,0x3020353030383130,0x3030303030303078,0x3030303178302033,
0x3078302035303866,0x2030383263333034,0x3031783009090a0d,0x3020333030386132,
0x3837303030303078,0x3330306278302030,0x3678302064663331,0x2038633730313030,
0x3031783009090a0d,0x3020353030383130,0x3030303030303078,0x3030303178302033,
0x3078302035303866,0x2030383263333034,0x3033783009090a0d,0x3020646633306337,
0x6337383030633678,0x3930306278302061,0x6178302064303031,0x2030303530303030,
0x3031783009090a0d,0x3020353036303030,0x3837633330343078,0x3030306678302030,
0x6578302031303030,0x2032303030303030,0x3031783009090a0d,0x3020333030656132,
0x3837303030303078,0x3030303178302030,0x3078302035303430,0x2030383763333036,
0x3066783009090a0d,0x3020313030303030,0x3030303030306578,0x6232303178302032,
0x3078302033303063,0x2030383730303030,0x3061783009090a0d,0x3020333030396232,
0x3030303030303078,0x6232303178302030,0x3078302033303036,0x2030303132303030,
0x3062783009090a0d,0x3020646631313230,0x6337303130303678,0x3130303178302038,
0x3078302035303038,0x2033303030303030,0x3031783009090a0d,0x3020353038663030,
0x3832633330343078,0x6232303178302030,0x3078302033303039,0x2030383730303030,
0x3062783009090a0d,0x3020646633313230,0x6337303130303678,0x3130303178302038,
0x3078302035303038,0x2033303030303030,0x3031783009090a0d,0x3020353038663030,
0x3832633330343078,0x6337303378302030,0x3678302064663330,0x2061633738303063,
0x3062783009090a0d,0x3020353030313930,0x3035303030306178,0x3030303178302030,
0x3078302035303430,0x2030383263333034,0x3030783009090a0d,0x3020353065313030,
0x3837303030306378,0x3030343078302032,0x6578302031306332,0x2030383734303234,
0x3066783009090a0d,0x3020313030303030,0x3030303030306578,0x6631363878302032,
0x3078302033306566,0x2030303030303030,0x3061783009090a0d,0x3020333030656532,
0x3030303030303078,0x6532303178302030,0x3078302033303064,0x2030303131303030,
0x3034783009090a0d,0x3020333030386432,0x3030303030303078,0x3030303178302030,
0x3078302039303866,0x2030383763333036,0x3031783009090a0d,0x3020353030383030,
0x3639383162343078,0x3338303378302062,0x3678302064663530,0x2038633730313463,
0x3035783009090a0d,0x3020333030303030,0x3832303030303078,0x3330303378302030,
0x6378302031313065,0x2030383730303334,0x3033783009090a0d,0x3020353130653230,
0x3837303033346378,0x3438303678302030,0x3678302064303431,0x2030383738303430,
0x3032783009090a0d,0x3020313138303030,0x3837343130343078,0x3130303378302030,
0x6378302035313630,0x2030383730303134,0x3032783009090a0d,0x3020643038383031,
0x3030303030303078,0x3030303278302037,0x3078302064303630,0x2030383734313034,
0x3030783009090a0d,0x3020353036303030,0x3837303030306378,0x3030346178302030,
0x3078302064303038,0x2030383730313263,0x3033783009090a0d,0x3020646637303538,
0x6337633034633678,0x3030303578302038,0x3078302033303030,0x2030383230303030,
0x3461783009090a0d,0x3020643030383030,0x3837303132633078,0x3230303078302030,
0x6378302035303630,0x2030383730303030,0x3462783009090a0d,0x3020646639653130,
0x6337303132303678,0x3030343178302038,0x3478302035303832,0x2030303163303034,
0x3032783009090a0d,0x3020393034383130,0x3030303030303078,0x6332303178302033,
0x3078302033303035,0x2030383730303030,0x3034783009090a0d,0x3020333030656532,
0x3030303030303078,0x3030303178302030,0x3078302039303230,0x2030383763333034,
0x3031783009090a0d,0x3020643038663030,0x3837633330363078,0x3338303378302030,
0x3678302064663730,0x2038633730313463,0x3035783009090a0d,0x3020333030303030,
0x3832303030303078,0x3330303378302030,0x6378302035313065,0x2030383730303334,
0x3033783009090a0d,0x3020313230653230,0x3837303033346378,0x3438303678302030,
0x3678302031313431,0x2030383763303430,0x3032783009090a0d,0x3020353161303030,
0x3837303230343078,0x3130303378302030,0x6378302031323830,0x2030383730303134,
0x3032783009090a0d,0x3020313161383031,0x3030303030303078,0x3030303278302037,
0x3078302031313830,0x2030383730323034,0x3030783009090a0d,0x3020353038303030,
0x3837303030306378,0x3030346178302030,0x3078302031313038,0x2030383730313263,
0x3033783009090a0d,0x3020646639303538,0x6337633034633678,0x3030303578302038,
0x3078302033303030,0x2030383230303030,0x3461783009090a0d,0x3020313130383030,
0x3837303132633078,0x3230303078302030,0x6378302035303830,0x2030383730303030,
0x3032783009090a0d,0x3020643036383130,0x3030303030303078,0x3030343078302033,
0x6578302031303832,0x2030383734303234,0x3031783009090a0d,0x3020333030626432,
0x3837303030303078,0x3030303178302030,0x3078302039303038,0x2062363938316234,
0x3066783009090a0d,0x3020313030303030,0x3030303030306578,0x6631363878302032,
0x3078302033306566,0x2030303030303030,0x3031783009090a0d,0x3020333030353233,
0x3031313030303078,0x3630303378302030,0x6378302035306330,0x2030383730303134,
0x3062783009090a0d,0x3020303030303234,0x3034393130303278,0x3638306278302034,
0x3678302031303030,0x2030383734303430,0x3033783009090a0d,0x3020353032303230,
0x3837303031346378,0x3030306178302030,0x3278302031303030,0x2030383734313063,
0x3032783009090a0d,0x3020353061643030,0x3837343032343078,0x6530306478302030,
0x6178302031303230,0x2030383730306330,0x3034783009090a0d,0x3020333030663033,
0x3030303030303078,0x3030303178302030,0x3078302031303866,0x2030383763333034,
0x3033783009090a0d,0x3020646631303338,0x6337303134633678,0x3030303578302038,
0x3078302033303030,0x2030383230303030,0x3033783009090a0d,0x3020643030653330,
0x3837303033346378,0x3230303378302030,0x6378302031313065,0x2030383730303334,
0x3036783009090a0d,0x3020353034313438,0x3837303034303678,0x3030303278302030,
0x3078302064303630,0x2030383730313034,0x3033783009090a0d,0x3020313132303130,
0x3837303031346378,0x3031303278302030,0x3078302035303638,0x2037303030303030,
0x3032783009090a0d,0x3020353032303030,0x3837303130343078,0x3030303078302030,
0x6378302035303230,0x2030383730303030,0x3461783009090a0d,0x3020353030383030,
0x3837303132633078,0x3538303378302030,0x3678302064663330,0x2038633763303463,
0x3035783009090a0d,0x3020333030303030,0x3832303030303078,0x3130303378302030,
0x6378302064306530,0x2030383730303134,0x3461783009090a0d,0x3020353030383030,
0x3837303132633078,0x3730303278302030,0x3278302063303638,0x2034303238333030,
0x3033783009090a0d,0x3020353032303230,0x3837303031346378,0x3030303278302030,
0x3078302035306163,0x2030383734303234,0x3064783009090a0d,0x3020393032306530,
0x3837303063306178,0x3130303278302030,0x3078302031303038,0x2033303030303030,
0x3031783009090a0d,0x3020333030616632,0x3837303030303078,0x3030303178302030,
0x3078302035303866,0x2030383763333034,0x3033783009090a0d,0x3020646633303338,
0x6337303134633678,0x3030303378302038,0x3078302033303030,0x2030383230303030,
0x3031783009090a0d,0x3020313032323030,0x3837633030343478,0x3130303478302030,
0x3078302064303831,0x2030383730303030,0x3036783009090a0d,0x3020643061313030,
0x3837633030303078,0x3031303378302030,0x6378302064303630,0x2030383730303134,
0x3036783009090a0d,0x3020313038313030,0x3837633030303078,0x3030303278302030,
0x3078302031303030,0x2030383738323034,0x3033783009090a0d,0x3020643030303230,
0x3837303031346378,0x3130303378302030,0x6378302031303030,0x2030383730303134,
0x3032783009090a0d,0x3020303036383030,0x3032383030303278,0x3230303378302030,
0x6378302031303030,0x2030383730303134,0x3032783009090a0d,0x3020313065633030,
0x3837303032343078,0x6530306478302030,0x3878302031303030,0x2030383730306330,
0x3033783009090a0d,0x3020646631303538,0x6337633034633678,0x3030303378302038,
0x3078302033303030,0x2030383230303030,0x3033783009090a0d,0x3020313030303230,
0x3837303031346378,0x3030303278302030,0x3078302031306163,0x2030383730303234,
0x3064783009090a0d,0x3020393030306530,0x3837303063306178,0x3130303278302030,
0x3078302035303238,0x2033303030303030,0x3031783009090a0d,0x3020333030303133,
0x3837303030303078,0x3738303378302030,0x3678302064663531,0x2038633730313434,
0x3033783009090a0d,0x3020333030303030,0x3832303030303078,0x3630303378302030,
0x6378302031306330,0x2030383730303134,0x3032783009090a0d,0x3020313034313030,
0x3837303030343078,0x3230303378302030,0x6378302035303030,0x2030383730303134,
0x3031783009090a0d,0x3020313030383130,0x3030303030303078,0x3030303278302033,
0x3078302035306164,0x2030383734303234,0x3064783009090a0d,0x3020313032306530,
0x3837303063306178,0x0a0d7d090a0d2031,0x2065646f630a0d7d,0x656d616e090a0d7b,
0x4946375a5f203d20,0x536650616475434d,0x5f535f305369505f,0x30535f535f535f53,
0x695f30535f30535f,0x6d6c090a0d666969,0x0a0d30203d206d65,0x203d206d656d7309,
0x676572090a0d3038,0x0a0d3732203d2020,0x203d202072616209,0x736e6f63090a0d31,
0x0909090a0d7b2074,0x20656d616e676573,0x0d74736e6f63203d,0x6e6765730909090a,
0x0d31203d20206d75,0x7366666f0909090a,0x0d30203d20207465,0x657479620909090a,
0x3233203d20202073,0x206d656d09090a0d,0x78300909090a0d7b,0x3030303030386537,
0x3030386633783020,0x3030783020303030,0x3020353030303030,0x3030303030303078,
0x300909090a0d2036,0x6666666666666678,0x3638353378302066,0x3078302064623733,
0x2066333030303030,0x3030303865337830,0x7d09090a0d203030,0x62090a0d7d090a0d,
0x7b2065646f636e69,0x3031783009090a0d,0x3020393030303030,0x3837633330343078,
0x3030306178302030,0x3078302064306334,0x2030383730303234,0x3031783009090a0d,
0x3020353165303030,0x3837343030303478,0x3530303678302030,0x3078302064303834,
0x2030383763303230,0x3033783009090a0d,0x3020643036303230,0x3837303031346378,
0x3030303278302030,0x3078302064306364,0x2030383763303234,0x3064783009090a0d,
0x3020393136306530,0x3837303063303878,0x3030303178302030,0x3478302064303032,
0x2030383763303034,0x3034783009090a0d,0x3020313138313730,0x3837303030303078,
0x3630303678302030,0x3078302031316131,0x2030383730313030,0x3033783009090a0d,
0x3020313138303031,0x3837303031346378,0x3630303678302030,0x3078302064313831,
0x2030383730313030,0x3061783009090a0d,0x3020313338303030,0x3837303030343078,
0x3030303278302030,0x3078302064306530,0x2030383730333034,0x3033783009090a0d,
0x3020393036303330,0x3837303031346378,0x3230303378302030,0x6378302031313630,
0x2030383730303134,0x3032783009090a0d,0x3020313134303030,0x3837303130343078,
0x6334303478302030,0x3078302035333831,0x2033303030303030,0x3033783009090a0d,
0x3020393063303230,0x3837303031346378,0x3030303278302030,0x3078302035323863,
0x2030383730313234,0x3064783009090a0d,0x3020313232316530,0x3837303063303878,
0x3030303078302030,0x6378302035306131,0x2030383730303030,0x3032783009090a0d,
0x3020393038643030,0x3837383032343078,0x6530306478302030,0x3878302031313430,
0x2030383730306330,0x3032783009090a0d,0x3020393032393430,0x3030303030303078,
0x6530306478302033,0x3878302035313430,0x2030383730306330,0x3032783009090a0d,
0x3020393032393830,0x3030303030303078,0x6530306478302033,0x3878302039303430,
0x2030383730306330,0x3430783009090a0d,0x3020313038323030,0x3837303232346578,
0x3330303378302030,0x6378302031323065,0x2030383730303334,0x3033783009090a0d,
0x3020353230653230,0x3837303033346378,0x3030343078302030,0x6578302031306132,
0x2030383734313234,0x3032783009090a0d,0x3020353130313030,0x3837343230343078,
0x6330303378302030,0x3678302064663365,0x2038633763303234,0x3430783009090a0d,
0x3020313063323030,0x3837383032346578,0x3430306178302030,0x3078302033303061,
0x2030303030303030,0x3032783009090a0d,0x3020393361383031,0x3030303030303078,
0x3430303178302037,0x3078302033303061,0x2030383230303030,0x3031783009090a0d,
0x3020393032323030,0x3837633030343478,0x3530303478302030,0x3078302035313831,
0x2030383730303030,0x3036783009090a0d,0x3020353161313430,0x3837343130303078,
0x3031303378302030,0x6378302035316130,0x2030383730303134,0x3036783009090a0d,
0x3020393038313430,0x3837343130303078,0x3030303278302030,0x3078302039303430,
0x2030383730333034,0x3033783009090a0d,0x3020353134303430,0x3837303031346378,
0x3330303378302030,0x6378302039303430,0x2030383730303134,0x3032783009090a0d,
0x3020343161383230,0x3061396530303278,0x3130303378302038,0x6378302039326530,
0x2030383730303134,0x3032783009090a0d,0x3020353263633030,0x3837343132343078,
0x6530306478302030,0x3878302031323231,0x2030383730303430,0x3030783009090a0d,
0x3020353034303030,0x3837303030306378,0x3030303278302030,0x3078302039323431,
0x2030383763313034,0x3032783009090a0d,0x3020393032393430,0x3030303030303078,
0x6530306478302033,0x3878302035313430,0x2030383730303430,0x3032783009090a0d,
0x3020393032393830,0x3030303030303078,0x6530306478302033,0x3878302039303430,
0x2030383730303430,0x3032783009090a0d,0x3020313230313034,0x3837383230343078,
0x3030343078302030,0x6578302031303030,0x2030383730343030,0x3033783009090a0d,
0x3020353134313030,0x3837343130343078,0x3030343078302030,0x6578302031303230,
0x2030383738323030,0x3033783009090a0d,0x3020393034313030,0x3837383030343078,
0x6330303278302030,0x3078302035313239,0x2033303030303030,0x3064783009090a0d,
0x3020313261306530,0x3837303034303878,0x3030343078302030,0x6578302031303430,
0x2030383730313030,0x3032783009090a0d,0x3020393032393031,0x3030303030303078,
0x6530306478302033,0x3878302035313430,0x2030383730303430,0x3032783009090a0d,
0x3020393032393431,0x3030303030303078,0x6530306478302033,0x3878302039303430,
0x2030383730303430,0x3033783009090a0d,0x3020313234313030,0x3837303230343078,
0x3030343078302030,0x6578302031303630,0x2030383730343030,0x3033783009090a0d,
0x3020353134313030,0x3837343130343078,0x3030303378302030,0x3078302039303431,
0x2030383738303034,0x3430783009090a0d,0x3020313038303030,0x3837383230306578,
0x3030343078302030,0x6578302031306130,0x2030383730313030,0x3066783009090a0d,
0x3020313030303030,0x3030303030306578,0x6631363878302032,0x3078302033306566,
0x2030303030303030,0x3033783009090a0d,0x3020393036303230,0x3837303031346378,
0x6330303378302030,0x3678302064663930,0x2038643730313034,0x3031783009090a0d,
0x3020643438663030,0x3837633330363078,0x3030303278302030,0x3078302064303664,
0x2030383738303234,0x3064783009090a0d,0x3020643336306530,0x3837303063303878,
0x3030303278302030,0x3078302064303064,0x2030383738303234,0x3064783009090a0d,
0x3020313436306530,0x3837303063303878,0x3030303278302030,0x3078302064303264,
0x2030383738303234,0x3064783009090a0d,0x3020353436306530,0x3837303063303878,
0x3030303278302030,0x3078302039303464,0x2030383738303234,0x3064783009090a0d,
0x3020393434306530,0x3837303063303878,0x3030303278302030,0x3078302031306131,
0x2030383639333034,0x3030783009090a0d,0x3020353030303030,0x3836313030306378,
0x3030346178302030,0x3078302031303038,0x2030383631313234,0x3030783009090a0d,
0x3020353030303230,0x3836313030306378,0x3030343178302030,0x3478302031303832,
0x2030383664303034,0x3638783009090a0d,0x3020333065666631,0x3030303030303078,
0x3030303078302030,0x6378302035306131,0x2030383730303030,0x3431783009090a0d,
0x3020393038323030,0x3837633030343478,0x3030303178302030,0x3078302031313038,
0x2033303030303030,0x3031783009090a0d,0x3020353130383031,0x3231333631343078,
0x3030306178302066,0x6378302039303430,0x2030383730303434,0x3065783009090a0d,
0x3020646635303430,0x6337383130306578,0x6232306178302038,0x3078302033303061,
0x2030303030303030,0x3431783009090a0d,0x3020393038323030,0x3837633030343478,
0x3030343178302030,0x3478302031316132,0x2030383763303034,0x3431783009090a0d,
0x3020643063323030,0x3837633030343478,0x3730303178302030,0x3078302033303038,
0x2030303130303030,0x3030783009090a0d,0x3020353061313030,0x3837303030306378,
0x3030343178302030,0x3478302031316132,0x2030383763303034,0x3031783009090a0d,
0x3020313230383030,0x3030303030303078,0x3031303178302033,0x3078302035323038,
0x2066323133363134,0x3061783009090a0d,0x3020313138303030,0x3837303034346378,
0x3830306578302030,0x6578302064663930,0x2038633738313030,0x3431783009090a0d,
0x3020313161323030,0x3837633030343478,0x3730303178302030,0x3078302033303038,
0x2030303130303030,0x3030783009090a0d,0x3020353061313030,0x3837303030306378,
0x3030343178302030,0x3478302064306332,0x2030383763303034,0x3031783009090a0d,
0x3020393230383030,0x3030303030303078,0x3031303178302033,0x3078302064323038,
0x2066323133363134,0x3061783009090a0d,0x3020313236303030,0x3837303034346378,
0x6130306578302030,0x6578302064663131,0x2038633738313030,0x3431783009090a0d,
0x3020643063323030,0x3837633030343478,0x6232303178302030,0x3078302033303061,
0x2030383230303030,0x3062783009090a0d,0x3020343536303434,0x3265316630306378,
0x3531306378302038,0x6378302034316132,0x2030323431313130,0x3065783009090a0d,
0x3020353130313131,0x3837343130383078,0x3530306378302030,0x6378302034313232,
0x2034313232353030,0x3065783009090a0d,0x3020643265313031,0x3837303130303078,
0x3231306578302030,0x3078302031356531,0x2030383763303030,0x3062783009090a0d,
0x3020646662306337,0x6337303130303678,0x3331306178302038,0x3078302033303037,
0x2030303030303030,0x3062783009090a0d,0x3020646637313431,0x6537343030303678,
0x3231303178302038,0x3078302033303062,0x2030303130303030,0x3062783009090a0d,
0x3020383530323031,0x3232323830306378,0x3131306278302030,0x6378302030363232,
0x2034363232313130,0x3063783009090a0d,0x3020353263323131,0x3837303030303078,
0x3030306378302030,0x3078302064353032,0x2033303030383034,0x3065783009090a0d,
0x3020313261323531,0x3837303230383078,0x3031306578302030,0x3078302039363032,
0x2030383734363030,0x3062783009090a0d,0x3020646633313038,0x6337303135303678,
0x3831306378302038,0x6378302034363032,0x2030363032373130,0x3065783009090a0d,
0x3020643534323231,0x3837383630343078,0x3738306378302030,0x3078302064356532,
0x2030383630303430,0x3063783009090a0d,0x3020353232313738,0x3836303034303078,
0x3030303978302030,0x6378302034323231,0x2063356532393030,0x3063783009090a0d,
0x3020343265323931,0x3230313930306378,0x3831306378302034,0x6378302030326130,
0x2030326132383030,0x3063783009090a0d,0x3020313261323830,0x3837303030303078,
0x3731316578302030,0x3078302031366532,0x2030383734303434,0x3063783009090a0d,
0x3020313230333830,0x3837303030303078,0x3030303978302030,0x3478302031323031,
0x2030383730303030,0x3062783009090a0d,0x3020343161303530,0x3630313030303978,
0x3038306278302030,0x3678302064666230,0x2038633730313530,0x3031783009090a0d,
0x3020303261383030,0x3632393831306278,0x3738306378302034,0x3078302035363233,
0x2030383630303430,0x3063783009090a0d,0x3020353161303738,0x3836303034303078,
0x3030303978302030,0x6378302034316130,0x2034313233353030,0x3062783009090a0d,
0x3020353232313030,0x3837303630303078,0x6337306278302030,0x3678302064666230,
0x2038633738313030,0x3062783009090a0d,0x3020646662303138,0x6332633034303678,
0x6130306178302038,0x3078302033303061,0x2030303030303030,0x3061783009090a0d,
0x3020353232313030,0x3837343030346578,0x6130303178302030,0x3078302033303039,
0x2030303130303030,0x3063783009090a0d,0x3020303661303131,0x3630323031306378,
0x3831306578302034,0x3078302035363033,0x2030383734363030,0x3063783009090a0d,
0x3020313630333631,0x3837303030303078,0x3831306578302030,0x3078302031366532,
0x2030383734363034,0x3039783009090a0d,0x3020313630333030,0x3837303030303478,
0x3531306578302030,0x3078302035316130,0x2030383730313030,0x3039783009090a0d,
0x3020313630333030,0x3837303030303078,0x3831306578302030,0x3078302035316531,
0x2030383734313030,0x3031783009090a0d,0x3020333030616130,0x3837303030303078,
0x3030303178302030,0x3078302035313038,0x2062363938316234,0x3062783009090a0d,
0x3020646631313038,0x6337303135303678,0x3738306378302061,0x3078302035323231,
0x2030383630303430,0x3063783009090a0d,0x3020313230313738,0x3836303034303078,
0x3030303978302030,0x6378302030323031,0x2034323231383030,0x3062783009090a0d,
0x3020646633316337,0x6337383130303678,0x3138306278302038,0x3678302064663331,
0x2038633263303430,0x3061783009090a0d,0x3020333030636230,0x3030303030303078,
0x6230303178302030,0x3078302033303062,0x2030303130303030,0x3065783009090a0d,
0x3020313232313531,0x3837303130303078,0x3131306378302030,0x6378302034323231,
0x2034353032303130,0x3063783009090a0d,0x3020393532313631,0x3837303030303078,
0x3930306578302030,0x3078302035323231,0x2030383734353030,0x3065783009090a0d,
0x3020353265323631,0x3837343230343078,0x3030303978302030,0x3478302035323231,
0x2030383730303030,0x3039783009090a0d,0x3020353232313030,0x3837303030303078,
0x3930306578302030,0x3078302031326531,0x2030383730323030,0x3031783009090a0d,
0x3020333030636230,0x3837303030303078,0x3030303178302030,0x3078302031323038,
0x2062363938316234,0x3066783009090a0d,0x3020313030303030,0x3030303030306578,
0x6330306178302032,0x3078302033303036,0x2030303030303030,0x3031783009090a0d,
0x3020333030336330,0x3031323030303078,0x3530306278302030,0x3678302064663731,
0x2038633730313030,0x3031783009090a0d,0x3020353230383130,0x3030303030303078,
0x3030303178302033,0x3078302035323866,0x2030383263333034,0x3031783009090a0d,
0x3020333030366330,0x3837303030303078,0x3530306278302030,0x3678302064663932,
0x2038633730313030,0x3031783009090a0d,0x3020353230383130,0x3030303030303078,
0x3030303178302033,0x3078302035323866,0x2030383263333034,0x3033783009090a0d,
0x3020646633316337,0x6337383030633678,0x6430306178302061,0x3078302033303037,
0x2030303030303030,0x3031783009090a0d,0x3020333030346430,0x3832303030303078,
0x6430306178302030,0x3078302033303032,0x2030303030303030,0x3031783009090a0d,
0x3020333030666330,0x3031323030303078,0x3830306278302030,0x3678302064663731,
0x2038633730313030,0x3031783009090a0d,0x3020353230383130,0x3030303030303078,
0x3030303178302033,0x3078302035323866,0x2030383263333034,0x3031783009090a0d,
0x3020333030326430,0x3837303030303078,0x3830306278302030,0x3678302064663932,
0x2038633730313030,0x3031783009090a0d,0x3020353230383130,0x3030303030303078,
0x3030303178302033,0x3078302035323866,0x2030383263333034,0x3066783009090a0d,
0x3020313030303030,0x3030303030306578,0x6430303178302032,0x3078302033303037,
0x2030383730303030,0x3062783009090a0d,0x3020646631313530,0x6337343030303678,
0x3130303178302038,0x3078302035323038,0x2033303030303030,0x3031783009090a0d,
0x3020353238663030,0x3832633330343078,0x6337303378302030,0x3678302064663331,
0x2061633738303063,0x3061783009090a0d,0x3020333030396630,0x3030303030303078,
0x6630303178302030,0x3078302033303036,0x2030383230303030,0x3061783009090a0d,
0x3020333030336530,0x3030303030303078,0x6530303178302030,0x3078302033303030,
0x2030303132303030,0x3062783009090a0d,0x3020646637313530,0x6337303130303678,
0x3130303178302038,0x3078302035323038,0x2033303030303030,0x3031783009090a0d,
0x3020353238663030,0x3832633330343078,0x6530303178302030,0x3078302033303033,
0x2030383730303030,0x3062783009090a0d,0x3020646639323530,0x6337303130303678,
0x3130303178302038,0x3078302035323038,0x2033303030303030,0x3031783009090a0d,
0x3020353238663030,0x3832633330343078,0x6337303378302030,0x3678302064663331,
0x2061633738303063,0x3061783009090a0d,0x3020333030346630,0x3030303030303078,
0x6630303178302030,0x3078302033303031,0x2030383230303030,0x3061783009090a0d,
0x3020333030666530,0x3030303030303078,0x6530303178302030,0x3078302033303063,
0x2030303132303030,0x3062783009090a0d,0x3020646637313230,0x6337303130303678,
0x3130303178302038,0x3078302035323038,0x2033303030303030,0x3031783009090a0d,
0x3020353238663030,0x3832633330343078,0x6530303178302030,0x3078302033303066,
0x2030383730303030,0x3062783009090a0d,0x3020646639323230,0x6337303130303678,
0x3130303178302038,0x3078302035323038,0x2033303030303030,0x3031783009090a0d,
0x3020353238663030,0x3832633330343078,0x3030306678302030,0x6578302031303030,
0x2032303030303030,0x3031783009090a0d,0x3020333030346630,0x3837303030303078,
0x3530306278302030,0x3678302064663530,0x2038633734303030,0x3031783009090a0d,
0x3020353230383130,0x3030303030303078,0x3030303178302033,0x3078302035323866,
0x2030383263333034,0x3066783009090a0d,0x3020313030303030,0x3030303030306578,
0x6630303178302032,0x3078302033303039,0x2030383730303030,0x3062783009090a0d,
0x3020646635303830,0x6337343030303678,0x3130303178302038,0x3078302035323038,
0x2033303030303030,0x3031783009090a0d,0x3020353238663030,0x3832633330343078,
0x6337303378302030,0x3678302064663331,0x2061633738303063,0x3061783009090a0d,
0x3020333030393231,0x3030303030303078,0x3231303178302030,0x3078302033303038,
0x2030383230303030,0x3061783009090a0d,0x3020333030353031,0x3030303030303078,
0x3031303178302030,0x3078302033303032,0x2030303132303030,0x3062783009090a0d,
0x3020646637313530,0x6337303130303678,0x3130303178302038,0x3078302035323038,
0x2033303030303030,0x3031783009090a0d,0x3020353238663030,0x3832633330343078,
0x3031303178302030,0x3078302033303035,0x2030383730303030,0x3062783009090a0d,
0x3020646639323530,0x6337303130303678,0x3130303178302038,0x3078302035323038,
0x2033303030303030,0x3031783009090a0d,0x3020353238663030,0x3832633330343078,
0x6337303378302030,0x3678302064663331,0x2061633738303063,0x3061783009090a0d,
0x3020333030363131,0x3030303030303078,0x3131303178302030,0x3078302033303033,
0x2030383230303030,0x3061783009090a0d,0x3020333030313131,0x3030303030303078,
0x3031303178302030,0x3078302033303065,0x2030303132303030,0x3062783009090a0d,
0x3020646637313830,0x6337303130303678,0x3130303178302038,0x3078302035323038,
0x2033303030303030,0x3031783009090a0d,0x3020353238663030,0x3832633330343078,
0x3131303178302030,0x3078302033303031,0x2030383730303030,0x3062783009090a0d,
0x3020646639323830,0x6337303130303678,0x3130303178302038,0x3078302035323038,
0x2033303030303030,0x3031783009090a0d,0x3020353238663030,0x3832633330343078,
0x3030306678302030,0x6578302031303030,0x2032303030303030,0x3031783009090a0d,
0x3020333030363131,0x3837303030303078,0x3530306278302030,0x3678302064663131,
0x2038633734303030,0x3031783009090a0d,0x3020353230383130,0x3030303030303078,
0x3030303178302033,0x3078302035323866,0x2030383263333034,0x3033783009090a0d,
0x3020646633316337,0x6337383030633678,0x3231306178302061,0x3078302033303036,
0x2030303030303030,0x3031783009090a0d,0x3020333030353231,0x3832303030303078,
0x3231306178302030,0x3078302033303032,0x2030303030303030,0x3031783009090a0d,
0x3020333030663131,0x3031323030303078,0x3530306278302030,0x3678302064663731,
0x2038633730313030,0x3031783009090a0d,0x3020313230383130,0x3030303030303078,
0x3030303178302033,0x3078302031323866,0x2030383263333034,0x3031783009090a0d,
0x3020333030323231,0x3837303030303078,0x3530306278302030,0x3678302064663932,
0x2038633730313030,0x3031783009090a0d,0x3020313230383130,0x3030303030303078,
0x3030303178302033,0x3078302031323866,0x2030383263333034,0x3033783009090a0d,
0x3020646631316337,0x6337383030633678,0x3431306278302061,0x6178302035313631,
0x2030303530303030,0x3031783009090a0d,0x3020333030363231,0x3837303030303078,
0x3030303178302030,0x3078302035313031,0x2030383763333036,0x3066783009090a0d,
0x3020313030303030,0x3030303030306578,0x3231303178302032,0x3078302033303039,
0x2030383730303030,0x3031783009090a0d,0x3020353134303030,0x3837633330343078,
0x3030306678302030,0x6578302031303030,0x2032303030303030,0x3031783009090a0d,
0x3020333030373331,0x3837303030303078,0x3331306178302030,0x3078302033303034,
0x2030303030303030,0x3031783009090a0d,0x3020333030313331,0x3031323030303078,
0x3230306278302030,0x3678302064663731,0x2038633730313030,0x3031783009090a0d,
0x3020353130383130,0x3030303030303078,0x3030303178302033,0x3078302035313866,
0x2030383263333034,0x3031783009090a0d,0x3020333030343331,0x3837303030303078,
0x3230306278302030,0x3678302064663932,0x2038633730313030,0x3031783009090a0d,
0x3020353130383130,0x3030303030303078,0x3030303178302033,0x3078302035313866,
0x2030383263333034,0x3033783009090a0d,0x3020646662306337,0x6337383030633678,
0x3431306278302061,0x6178302035313631,0x2030303530303030,0x3031783009090a0d,
0x3020353134303030,0x3832633330363078,0x3030306278302030,0x3078302035353430,
0x2032383763303038,0x3063783009090a0d,0x3020343234313231,0x3261323531306378,
0x3231306578302030,0x3078302031323231,0x2030383730323038,0x3063783009090a0d,
0x3020303234323830,0x3234323830306378,0x3030303078302030,0x6378302035306131,
0x2030383730303030,0x3065783009090a0d,0x3020643265313131,0x3837633030303078,
0x3031306578302030,0x3078302031356531,0x2030383738303030,0x3062783009090a0d,
0x3020646631316337,0x6337303130303678,0x3030343078302038,0x6578302031303832,
0x2030383734313234,0x3061783009090a0d,0x3020333030386631,0x3030303030303078,
0x3431306278302030,0x3678302064663731,0x2038653734303030,0x3031783009090a0d,
0x3020333030636531,0x3031303030303078,0x3131306278302030,0x6378302038353232,
0x2034313432393030,0x3063783009090a0d,0x3020303634323231,0x3634323231306278,
0x3231306378302034,0x3078302035326332,0x2030383730303030,0x3063783009090a0d,
0x3020643532323030,0x3030303830343078,0x3531306578302033,0x3078302035316132,
0x2030383734313038,0x3065783009090a0d,0x3020393632323131,0x3837303630303078,
0x3038306278302030,0x3678302064663331,0x2038633730313530,0x3063783009090a0d,
0x3020343632323931,0x3632323731306378,0x3031306578302030,0x3078302064353032,
0x2030383738363034,0x3063783009090a0d,0x3020643565323738,0x3836303034303078,
0x3738306378302030,0x3078302035323231,0x2030383630303430,0x3039783009090a0d,
0x3020343232313030,0x3565323930306378,0x3931306378302063,0x6378302034326532,
0x2034326130393030,0x3063783009090a0d,0x3020343130313831,0x3161323530306378,
0x3530306378302034,0x3078302035316132,0x2030383730303030,0x3165783009090a0d,
0x3020313665323731,0x3837343034343078,0x3530306378302030,0x3078302035313033,
0x2030383730303030,0x3039783009090a0d,0x3020313661303030,0x3837303030303478,
0x3830306278302030,0x3978302034313031,0x2030363033303030,0x3062783009090a0d,
0x3020646662303038,0x6337303135303678,0x3030303178302038,0x6278302030326138,
0x2034363239383130,0x3063783009090a0d,0x3020353632333738,0x3836303034303078,
0x3738306378302030,0x3078302035316130,0x2030383630303430,0x3039783009090a0d,
0x3020343161303030,0x3132333530306378,0x3030306278302034,0x3078302035323231,
0x2030383730363030,0x3062783009090a0d,0x3020646662306337,0x6337383130303678,
0x3138306278302038,0x3678302064666230,0x2038633263303430,0x3061783009090a0d,
0x3020333030623631,0x3030303030303078,0x3030306178302030,0x6578302035323231,
0x2030383734303034,0x3031783009090a0d,0x3020333030613631,0x3031303030303078,
0x3231306378302030,0x6378302030366130,0x2034363232313130,0x3065783009090a0d,
0x3020353630333831,0x3837343630303078,0x3631306378302030,0x3078302031363033,
0x2030383730303030,0x3065783009090a0d,0x3020313665323831,0x3837343630343078,
0x3030303978302030,0x3478302031363033,0x2030383730303030,0x3065783009090a0d,
0x3020353161303531,0x3837633030303078,0x3030303978302030,0x3078302031363033,
0x2030383730303030,0x3065783009090a0d,0x3020353165313831,0x3837343130303078,
0x3631303178302030,0x3078302033303062,0x2030383730303030,0x3031783009090a0d,
0x3020353130383030,0x3639383162343078,0x3038306278302062,0x3678302064663131,
0x2061633730313530,0x3063783009090a0d,0x3020353232313738,0x3836303034303078,
0x3738306378302030,0x3078302031323031,0x2030383630303430,0x3039783009090a0d,
0x3020303230313030,0x3232313830306378,0x6337306278302034,0x3678302064663331,
0x2038633738313030,0x3062783009090a0d,0x3020646633313138,0x6332633034303678,
0x3731306178302038,0x3078302033303064,0x2030303030303030,0x3031783009090a0d,
0x3020333030633731,0x3031303030303078,0x3531306578302030,0x3078302031323231,
0x2030383763303030,0x3063783009090a0d,0x3020343232313231,0x3532323131306378,
0x3631306378302034,0x3078302039353231,0x2030383730303030,0x3065783009090a0d,
0x3020353232313930,0x3837343530303078,0x3631306578302030,0x3078302035326532,
0x2030383734323034,0x3039783009090a0d,0x3020353232313030,0x3837303030303478,
0x3030303978302030,0x3078302035323231,0x2030383730303030,0x3065783009090a0d,
0x3020313265313930,0x3837303230303078,0x3731303178302030,0x3078302033303064,
0x2030383730303030,0x3031783009090a0d,0x3020313230383030,0x3639383162343078,
0x3030306678302062,0x6578302031303030,0x2032303030303030,0x3061783009090a0d,
0x3020333030373831,0x3030303030303078,0x3831303178302030,0x3078302033303034,
0x2030303132303030,0x3062783009090a0d,0x3020646637313530,0x6337303130303678,
0x3130303178302038,0x3078302035323038,0x2033303030303030,0x3031783009090a0d,
0x3020353238663030,0x3832633330343078,0x3831303178302030,0x3078302033303037,
0x2030383730303030,0x3062783009090a0d,0x3020646639323530,0x6337303130303678,
0x3130303178302038,0x3078302035323038,0x2033303030303030,0x3031783009090a0d,
0x3020353238663030,0x3832633330343078,0x6337303378302030,0x3678302064663331,
0x2061633738303063,0x3061783009090a0d,0x3020333030383931,0x3030303030303078,
0x3931303178302030,0x3078302033303035,0x2030383230303030,0x3061783009090a0d,
0x3020333030333931,0x3030303030303078,0x3931303178302030,0x3078302033303030,
0x2030303132303030,0x3062783009090a0d,0x3020646637313830,0x6337303130303678,
0x3130303178302038,0x3078302035323038,0x2033303030303030,0x3031783009090a0d,
0x3020353238663030,0x3832633330343078,0x3931303178302030,0x3078302033303033,
0x2030383730303030,0x3062783009090a0d,0x3020646639323830,0x6337303130303678,
0x3130303178302038,0x3078302035323038,0x2033303030303030,0x3031783009090a0d,
0x3020353238663030,0x3832633330343078,0x3030306678302030,0x6578302031303030,
0x2032303030303030,0x3031783009090a0d,0x3020333030383931,0x3837303030303078,
0x3530306278302030,0x3678302064663131,0x2038633734303030,0x3031783009090a0d,
0x3020353230383130,0x3030303030303078,0x3030303178302033,0x3078302035323866,
0x2030383263333034,0x3033783009090a0d,0x3020646633316337,0x6337383030633678,
0x6231306178302061,0x3078302033303061,0x2030303030303030,0x3031783009090a0d,
0x3020333030376231,0x3832303030303078,0x6131306178302030,0x3078302033303034,
0x2030303030303030,0x3031783009090a0d,0x3020333030316131,0x3031323030303078,
0x3530306278302030,0x3678302064663731,0x2038633730313030,0x3031783009090a0d,
0x3020353230383130,0x3030303030303078,0x3030303178302033,0x3078302035323866,
0x2030383263333034,0x3031783009090a0d,0x3020333030346131,0x3837303030303078,
0x3530306278302030,0x3678302064663932,0x2038633730313030,0x3031783009090a0d,
0x3020353230383130,0x3030303030303078,0x3030303178302033,0x3078302035323866,
0x2030383263333034,0x3033783009090a0d,0x3020646633316337,0x6337383030633678,
0x6231306178302061,0x3078302033303035,0x2030303030303030,0x3031783009090a0d,
0x3020333030326231,0x3832303030303078,0x6231306178302030,0x3078302033303030,
0x2030303030303030,0x3031783009090a0d,0x3020333030646131,0x3031323030303078,
0x3430306278302030,0x3678302064663731,0x2038633730313030,0x3031783009090a0d,
0x3020353230383130,0x3030303030303078,0x3030303178302033,0x3078302035323866,
0x2030383263333034,0x3031783009090a0d,0x3020333030306231,0x3837303030303078,
0x3430306278302030,0x3678302064663932,0x2038633730313030,0x3031783009090a0d,
0x3020353230383130,0x3030303030303078,0x3030303178302033,0x3078302035323866,
0x2030383263333034,0x3066783009090a0d,0x3020313030303030,0x3030303030306578,
0x6231303178302032,0x3078302033303035,0x2030383730303030,0x3062783009090a0d,
0x3020646639303530,0x6337343030303678,0x3130303178302038,0x3078302035323038,
0x2033303030303030,0x3031783009090a0d,0x3020353238663030,0x3832633330343078,
0x3030306678302030,0x6578302031303030,0x2032303030303030,0x3031783009090a0d,
0x3020333030616231,0x3837303030303078,0x3830306278302030,0x3678302064663930,
0x2038633734303030,0x3031783009090a0d,0x3020353230383130,0x3030303030303078,
0x3030303178302033,0x3078302035323866,0x2030383263333034,0x3033783009090a0d,
0x3020646633316337,0x6337383030633678,0x6531306178302061,0x3078302033303061,
0x2030303030303030,0x3031783009090a0d,0x3020333030396531,0x3832303030303078,
0x6331306178302030,0x3078302033303036,0x2030303030303030,0x3031783009090a0d,
0x3020333030336331,0x3031323030303078,0x3530306278302030,0x3678302064663731,
0x2038633730313030,0x3031783009090a0d,0x3020353230383130,0x3030303030303078,
0x3030303178302033,0x3078302035323866,0x2030383263333034,0x3031783009090a0d,
0x3020333030366331,0x3837303030303078,0x3530306278302030,0x3678302064663932,
0x2038633730313030,0x3031783009090a0d,0x3020353230383130,0x3030303030303078,
0x3030303178302033,0x3078302035323866,0x2030383263333034,0x3033783009090a0d,
0x3020646633316337,0x6337383030633678,0x6431306178302061,0x3078302033303037,
0x2030303030303030,0x3031783009090a0d,0x3020333030346431,0x3832303030303078,
0x6431306178302030,0x3078302033303032,0x2030303030303030,0x3031783009090a0d,
0x3020333030666331,0x3031323030303078,0x3830306278302030,0x3678302064663731,
0x2038633730313030,0x3031783009090a0d,0x3020353230383130,0x3030303030303078,
0x3030303178302033,0x3078302035323866,0x2030383263333034,0x3031783009090a0d,
0x3020333030326431,0x3837303030303078,0x3830306278302030,0x3678302064663932,
0x2038633730313030,0x3031783009090a0d,0x3020353230383130,0x3030303030303078,
0x3030303178302033,0x3078302035323866,0x2030383263333034,0x3066783009090a0d,
0x3020313030303030,0x3030303030306578,0x6431303178302032,0x3078302033303037,
0x2030383730303030,0x3062783009090a0d,0x3020646631313530,0x6337343030303678,
0x3130303178302038,0x3078302035323038,0x2033303030303030,0x3031783009090a0d,
0x3020353238663030,0x3832633330343078,0x6337303378302030,0x3678302064663331,
0x2061633738303063,0x3061783009090a0d,0x3020333030376531,0x3030303030303078,
0x6531303178302030,0x3078302033303036,0x2030383230303030,0x3061783009090a0d,
0x3020333030336531,0x3030303030303078,0x6531303178302030,0x3078302033303030,
0x2030303132303030,0x3062783009090a0d,0x3020646637313530,0x6337303130303678,
0x3130303178302038,0x3078302031323038,0x2033303030303030,0x3031783009090a0d,
0x3020313238663030,0x3832633330343078,0x6531303178302030,0x3078302033303033,
0x2030383730303030,0x3062783009090a0d,0x3020646639323530,0x6337303130303678,
0x3130303178302038,0x3078302031323038,0x2033303030303030,0x3031783009090a0d,
0x3020313238663030,0x3832633330343078,0x6337303378302030,0x3678302064663131,
0x2061633738303063,0x3062783009090a0d,0x3020353136313431,0x3035303030306178,
0x6531303178302030,0x3078302033303037,0x2030383730303030,0x3031783009090a0d,
0x3020353130313030,0x3837633330363078,0x3030306678302030,0x6578302031303030,
0x2032303030303030,0x3031783009090a0d,0x3020333030616531,0x3837303030303078,
0x3030303178302030,0x3078302035313830,0x2030383763333034,0x3066783009090a0d,
0x3020313030303030,0x3030303030306578,0x6631303178302032,0x3078302033303038,
0x2030383730303030,0x3061783009090a0d,0x3020333030356631,0x3030303030303078,
0x6631303178302030,0x3078302033303032,0x2030303132303030,0x3062783009090a0d,
0x3020646637313430,0x6337303130303678,0x3130303178302038,0x3078302035313038,
0x2033303030303030,0x3031783009090a0d,0x3020353138663030,0x3832633330343078,
0x6631303178302030,0x3078302033303035,0x2030383730303030,0x3062783009090a0d,
0x3020646639323430,0x6337303130303678,0x3130303178302038,0x3078302035313038,
0x2033303030303030,0x3031783009090a0d,0x3020353138663030,0x3832633330343078,
0x6337303378302030,0x3678302064666230,0x2061633738303063,0x3062783009090a0d,
0x3020353136313431,0x3035303030306178,0x3030303178302030,0x3078302035313830,
0x2030383263333036,0x3062783009090a0d,0x3020643238303030,0x3837383030383078,
0x3031306378302032,0x6378302030353431,0x2030323631623030,0x3065783009090a0d,
0x3020313238323031,0x3837303230383078,0x3830306378302030,0x6378302030323032,
0x2030323032383030,0x3030783009090a0d,0x3020353061313030,0x3837303030306378,
0x3131306578302030,0x3078302039326531,0x2030383730313030,0x3065783009090a0d,
0x3020353265313231,0x3837383030303078,0x6337306278302030,0x3678302064663131,
0x2038633730313030,0x3430783009090a0d,0x3020313061323030,0x3837343132346578,
0x6232306178302030,0x3078302033303038,0x2030303030303030,0x3062783009090a0d,
0x3020646633316130,0x6537343030303678,0x6132303178302038,0x3078302033303063,
0x2030303130303030,0x3062783009090a0d,0x3020343534323231,0x3130323431306378,
0x3030306378302030,0x3078302039353432,0x2033303030383034,0x3063783009090a0d,
0x3020303534323231,0x3161323031306378,0x3030306278302034,0x3078302031363032,
0x2030383730343030,0x3065783009090a0d,0x3020313136316230,0x3837303130383078,
0x3031306578302030,0x3078302035363032,0x2030383730353030,0x3062783009090a0d,
0x3020646662303038,0x6337303135303678,0x3631306378302038,0x6378302063353432,
0x2030363432383130,0x3065783009090a0d,0x3020393532323131,0x3837343630343078,
0x3738306378302030,0x3078302039356332,0x2030383630303430,0x3063783009090a0d,
0x3020353161303738,0x3836303034303078,0x3030303978302030,0x6378302034316130,
0x2038356332353030,0x3063783009090a0d,0x3020633530313731,0x3163323831306378,
0x3731306378302034,0x6378302030363631,0x2063353830353030,0x3063783009090a0d,
0x3020313136313831,0x3837303030303078,0x3631316578302030,0x3078302035316332,
0x2030383734303434,0x3063783009090a0d,0x3020313161303430,0x3837303030303078,
0x3030303978302030,0x3478302035313830,0x2030383730303030,0x3062783009090a0d,
0x3020303130313830,0x3261303030303978,0x3038306278302030,0x3678302064663930,
0x2038633730313530,0x3031783009090a0d,0x3020343138383030,0x3665613830306278,
0x3738306378302030,0x3078302031363033,0x2030383630303430,0x3063783009090a0d,
0x3020313138303738,0x3836303034303078,0x3030303978302030,0x6378302030313830,
0x2030313033343030,0x3062783009090a0d,0x3020646639306337,0x6337383130303678,
0x3030306278302038,0x3078302031326532,0x2030383730323030,0x3062783009090a0d,
0x3020646639303138,0x6332633034303678,0x3232306178302038,0x3078302033303063,
0x2030303030303030,0x3061783009090a0d,0x3020313230313030,0x3837343030346578,
0x3232303178302030,0x3078302033303062,0x2030303130303030,0x3063783009090a0d,
0x3020643538303031,0x3837303030303078,0x3731306578302030,0x3078302031366532,
0x2030383730353030,0x3063783009090a0d,0x3020643565323531,0x3837303030303078,
0x3731306578302030,0x3078302064356332,0x2030383730363034,0x3039783009090a0d,
0x3020643565323030,0x3837303030303478,0x6230306578302030,0x3078302031313830,
0x2030383738303030,0x3039783009090a0d,0x3020643565323030,0x3837303030303078,
0x3731306578302030,0x3078302031316531,0x2030383730313030,0x3031783009090a0d,
0x3020333030633232,0x3837303030303078,0x3030303178302030,0x3078302031313038,
0x2062363938316234,0x3062783009090a0d,0x3020646662303038,0x6337303135303678,
0x3738306378302061,0x3078302031323031,0x2030383630303430,0x3063783009090a0d,
0x3020353161303738,0x3836303034303078,0x3030303978302030,0x6378302034316130,
0x2034313031353030,0x3062783009090a0d,0x3020646662306337,0x6337383130303678,
0x3138306278302038,0x3678302064666230,0x2038633263303430,0x3061783009090a0d,
0x3020333030653332,0x3030303030303078,0x3332303178302030,0x3078302033303064,
0x2030303130303030,0x3063783009090a0d,0x3020313261303031,0x3837303030303078,
0x3830306578302030,0x3078302031353031,0x2030383730353030,0x3063783009090a0d,
0x3020313230313531,0x3837303030303078,0x3830306578302030,0x3078302031326332,
0x2030383730353034,0x3039783009090a0d,0x3020313230313030,0x3837303030303478,
0x6230306578302030,0x3078302039306130,0x2030383738303030,0x3039783009090a0d,
0x3020353130313030,0x3837303030303078,0x3530306578302030,0x3078302039306531,
0x2030383738303030,0x3031783009090a0d,0x3020333030653332,0x3837303030303078,
0x3030303178302030,0x3078302039303038,0x2062363938316234,0x3066783009090a0d,
0x3020313030303030,0x3030303030306578,0x3432306178302032,0x3078302033303038,
0x2030303030303030,0x3031783009090a0d,0x3020333030353432,0x3031323030303078,
0x3430306278302030,0x3678302064663331,0x2038633730313030,0x3031783009090a0d,
0x3020353130383130,0x3030303030303078,0x3030303178302033,0x3078302035313866,
0x2030383263333034,0x3031783009090a0d,0x3020333030383432,0x3837303030303078,
0x3430306278302030,0x3678302064663531,0x2038633730313030,0x3031783009090a0d,
0x3020353130383130,0x3030303030303078,0x3030303178302033,0x3078302035313866,
0x2030383263333034,0x3033783009090a0d,0x3020646662306337,0x6337383030633678,
0x3532306178302061,0x3078302033303039,0x2030303030303030,0x3031783009090a0d,
0x3020333030363532,0x3832303030303078,0x3532306178302030,0x3078302033303034,
0x2030303030303030,0x3031783009090a0d,0x3020333030313532,0x3031323030303078,
0x3230306278302030,0x3678302064663331,0x2038633730313030,0x3031783009090a0d,
0x3020353130383130,0x3030303030303078,0x3030303178302033,0x3078302035313866,
0x2030383263333034,0x3031783009090a0d,0x3020333030343532,0x3837303030303078,
0x3230306278302030,0x3678302064663531,0x2038633730313030,0x3031783009090a0d,
0x3020353130383130,0x3030303030303078,0x3030303178302033,0x3078302035313866,
0x2030383263333034,0x3066783009090a0d,0x3020313030303030,0x3030303030306578,
0x3532303178302032,0x3078302033303039,0x2030383730303030,0x3062783009090a0d,
0x3020646635303430,0x6337343030303678,0x3130303178302038,0x3078302035313038,
0x2033303030303030,0x3031783009090a0d,0x3020353138663030,0x3832633330343078,
0x6337303378302030,0x3678302064666230,0x2061633738303063,0x3061783009090a0d,
0x3020333030623732,0x3030303030303078,0x3732303178302030,0x3078302033303038,
0x2030383230303030,0x3061783009090a0d,0x3020333030353632,0x3030303030303078,
0x3632303178302030,0x3078302033303032,0x2030303132303030,0x3062783009090a0d,
0x3020646633313430,0x6337303130303678,0x3130303178302038,0x3078302035313038,
0x2033303030303030,0x3031783009090a0d,0x3020353138663030,0x3832633330343078,
0x3632303178302030,0x3078302033303035,0x2030383730303030,0x3062783009090a0d,
0x3020646635313430,0x6337303130303678,0x3130303178302038,0x3078302035313038,
0x2033303030303030,0x3031783009090a0d,0x3020353138663030,0x3832633330343078,
0x6337303378302030,0x3678302064666230,0x2061633738303063,0x3061783009090a0d,
0x3020333030363732,0x3030303030303078,0x3732303178302030,0x3078302033303033,
0x2030383230303030,0x3061783009090a0d,0x3020333030313732,0x3030303030303078,
0x3632303178302030,0x3078302033303065,0x2030303132303030,0x3062783009090a0d,
0x3020646633313330,0x6337303130303678,0x3130303178302038,0x3078302035313038,
0x2033303030303030,0x3031783009090a0d,0x3020353138663030,0x3832633330343078,
0x3732303178302030,0x3078302033303031,0x2030383730303030,0x3062783009090a0d,
0x3020646635313330,0x6337303130303678,0x3130303178302038,0x3078302035313038,
0x2033303030303030,0x3031783009090a0d,0x3020353138663030,0x3832633330343078,
0x3030306678302030,0x6578302031303030,0x2032303030303030,0x3031783009090a0d,
0x3020333030363732,0x3837303030303078,0x3430306278302030,0x3678302064663730,
0x2038633734303030,0x3031783009090a0d,0x3020353130383130,0x3030303030303078,
0x3030303178302033,0x3078302035313866,0x2030383263333034,0x3066783009090a0d,
0x3020313030303030,0x3030303030306578,0x3732303178302032,0x3078302033303062,
0x2030383730303030,0x3062783009090a0d,0x3020646637303230,0x6337343030303678,
0x3130303178302038,0x3078302035313038,0x2033303030303030,0x3031783009090a0d,
0x3020353138663030,0x3832633330343078,0x6337303378302030,0x3678302064666230,
0x2061633738303063,0x3061783009090a0d,0x3020333030616132,0x3030303030303078,
0x6132303178302030,0x3078302033303039,0x2030383230303030,0x3061783009090a0d,
0x3020333030373832,0x3030303030303078,0x3832303178302030,0x3078302033303034,
0x2030303132303030,0x3062783009090a0d,0x3020646633313430,0x6337303130303678,
0x3130303178302038,0x3078302064303038,0x2033303030303030,0x3031783009090a0d,
0x3020643038663030,0x3832633330343078,0x3832303178302030,0x3078302033303037,
0x2030383730303030,0x3062783009090a0d,0x3020646635313430,0x6337303130303678,
0x3130303178302038,0x3078302064303038,0x2033303030303030,0x3031783009090a0d,
0x3020643038663030,0x3832633330343078,0x6337303378302030,0x3678302064663730,
0x2061633738303063,0x3061783009090a0d,0x3020333030383932,0x3030303030303078,
0x3932303178302030,0x3078302033303035,0x2030383230303030,0x3061783009090a0d,
0x3020333030333932,0x3030303030303078,0x3932303178302030,0x3078302033303030,
0x2030303132303030,0x3062783009090a0d,0x3020646633313230,0x6337303130303678,
0x3130303178302038,0x3078302064303038,0x2033303030303030,0x3031783009090a0d,
0x3020643038663030,0x3832633330343078,0x3932303178302030,0x3078302033303033,
0x2030383730303030,0x3062783009090a0d,0x3020646635313230,0x6337303130303678,
0x3130303178302038,0x3078302064303038,0x2033303030303030,0x3031783009090a0d,
0x3020643038663030,0x3832633330343078,0x3030306678302030,0x6578302031303030,
0x2032303030303030,0x3031783009090a0d,0x3020333030383932,0x3837303030303078,
0x3430306278302030,0x3678302064663530,0x2038633734303030,0x3031783009090a0d,
0x3020643030383130,0x3030303030303078,0x3030303178302033,0x3078302064303866,
0x2030383263333034,0x3033783009090a0d,0x3020646637306337,0x6337383030633678,
0x6132306178302061,0x3078302033303037,0x2030303030303030,0x3031783009090a0d,
0x3020333030376132,0x3832303030303078,0x6132306178302030,0x3078302033303034,
0x2030303030303030,0x3031783009090a0d,0x3020333030316132,0x3031323030303078,
0x3430306278302030,0x3678302064663331,0x2038633730313030,0x3031783009090a0d,
0x3020393030383130,0x3030303030303078,0x3030303178302033,0x3078302039303866,
0x2030383263333034,0x3031783009090a0d,0x3020333030346132,0x3837303030303078,
0x3430306278302030,0x3678302064663531,0x2038633730313030,0x3031783009090a0d,
0x3020393030383130,0x3030303030303078,0x3030303178302033,0x3078302039303866,
0x2030383263333034,0x3033783009090a0d,0x3020646635306337,0x6337383030633678,
0x6130306278302061,0x6178302031313231,0x2030303530303030,0x3031783009090a0d,
0x3020393038303030,0x3837633330363078,0x3030306678302030,0x6578302031303030,
0x2032303030303030,0x3031783009090a0d,0x3020333030616132,0x3837303030303078,
0x3030303178302030,0x3078302039303630,0x2030383763333034,0x3066783009090a0d,
0x3020313030303030,0x3030303030306578,0x6232303178302032,0x3078302033303038,
0x2030383730303030,0x3061783009090a0d,0x3020333030356232,0x3030303030303078,
0x6232303178302030,0x3078302033303032,0x2030303132303030,0x3062783009090a0d,
0x3020646633313330,0x6337303130303678,0x3130303178302038,0x3078302039303038,
0x2033303030303030,0x3031783009090a0d,0x3020393038663030,0x3832633330343078,
0x6232303178302030,0x3078302033303035,0x2030383730303030,0x3062783009090a0d,
0x3020646635313330,0x6337303130303678,0x3130303178302038,0x3078302039303038,
0x2033303030303030,0x3031783009090a0d,0x3020393038663030,0x3832633330343078,
0x6337303378302030,0x3678302064663530,0x2061633738303063,0x3062783009090a0d,
0x3020393032316130,0x3035303030306178,0x3030303178302030,0x3078302039303630,
0x2030383263333036,0x3030783009090a0d,0x3020353061313030,0x3837303030306378,
0x3030343078302032,0x6578302031306332,0x2030383738303234,0x3066783009090a0d,
0x3020313030303030,0x3030303030306578,0x6631363878302032,0x3078302033306566,
0x2030303030303030,0x3061783009090a0d,0x3020333030306532,0x3030303030303078,
0x6532303178302030,0x3078302033303030,0x2030303131303030,0x3034783009090a0d,
0x3020333030306432,0x3030303030303078,0x3030303178302030,0x3078302039303866,
0x2030383763333034,0x3031783009090a0d,0x3020353030383030,0x3639383162343078,
0x3238303378302062,0x3678302064663530,0x2038633730313463,0x3035783009090a0d,
0x3020333030303030,0x3832303030303078,0x3338303678302030,0x3678302064303831,
0x2030383738303430,0x3033783009090a0d,0x3020643036303130,0x3837303031346378,
0x3030303278302030,0x3078302064306331,0x2030383763303034,0x3030783009090a0d,
0x3020353036303030,0x3837303030306378,0x3030346178302030,0x3078302064303038,
0x2030383730313263,0x3033783009090a0d,0x3020646637303438,0x6337633034633678,
0x3030303578302038,0x3078302033303030,0x2030383230303030,0x3461783009090a0d,
0x3020643030383030,0x3837303132633078,0x3230303078302030,0x6378302035303630,
0x2030383730303030,0x3462783009090a0d,0x3020646639653130,0x6337303132303678,
0x3030343178302038,0x3478302035303832,0x2030303163303034,0x3032783009090a0d,
0x3020393034383130,0x3030303030303078,0x6332303178302033,0x3078302033303031,
0x2030383730303030,0x3034783009090a0d,0x3020333030306532,0x3030303030303078,
0x3030303178302030,0x3078302039303866,0x2030383763333036,0x3033783009090a0d,
0x3020646635303238,0x6337303134633678,0x3030303578302038,0x3078302033303030,
0x2030383230303030,0x3036783009090a0d,0x3020643038313338,0x3837383034303678,
0x3130303378302030,0x6378302064303630,0x2030383730303134,0x3032783009090a0d,
0x3020643063313030,0x3837633030343078,0x3030303078302030,0x6378302035303630,
0x2030383730303030,0x3461783009090a0d,0x3020643030383030,0x3837303132633078,
0x3438303378302030,0x3678302064663730,0x2038633763303463,0x3035783009090a0d,
0x3020333030303030,0x3832303030303078,0x3030346178302030,0x3078302064303038,
0x2030383730313263,0x3030783009090a0d,0x3020353036303230,0x3837303030306378,
0x3130303278302030,0x3078302039303438,0x2033303030303030,0x3430783009090a0d,
0x3020313038323030,0x3837343032346578,0x6432303178302030,0x3078302033303032,
0x2030383730303030,0x3066783009090a0d,0x3020313030303030,0x3030303030306578,
0x6631363878302032,0x3078302033306566,0x2030303030303030,0x3032783009090a0d,
0x3020643436613130,0x3030303030303078,0x3338303378302033,0x3678302064663732,
0x2038633734313463,0x3031783009090a0d,0x3020333030373530,0x3832303030303078,
0x3133303178302030,0x3078302033303037,0x2030303131303030,0x3033783009090a0d,
0x3020393063303630,0x3837303031346378,0x3030306278302030,0x3278302030303238,
0x2038303839323030,0x3062783009090a0d,0x3020313030303538,0x3837343034303678,
0x3230303378302030,0x6378302039303430,0x2030383730303134,0x3061783009090a0d,
0x3020313030303030,0x3837343130633278,0x3030303278302030,0x3078302039306164,
0x2030383738303234,0x3064783009090a0d,0x3020313034306530,0x3837303063306178,
0x3033303478302030,0x3078302033303031,0x2030303030303030,0x3031783009090a0d,
0x3020393038663030,0x3837633330343078,0x3030303178302030,0x3078302031303230,
0x2030383763333036,0x3033783009090a0d,0x3020646635303238,0x6337303134633678,
0x3030303578302038,0x3078302033303030,0x2030383230303030,0x3036783009090a0d,
0x3020353038313338,0x3837383034303678,0x3130303378302030,0x6378302035303230,
0x2030383730303134,0x3032783009090a0d,0x3020353063313030,0x3837343030343078,
0x3030303078302030,0x6378302035303230,0x2030383730303030,0x3461783009090a0d,
0x3020353030383030,0x3837303132633078,0x3438303378302030,0x3678302064663330,
0x2038633763303463,0x3035783009090a0d,0x3020333030303030,0x3832303030303078,
0x3130303378302030,0x6378302064306530,0x2030383730303134,0x3461783009090a0d,
0x3020353030383030,0x3837303132633078,0x3730303278302030,0x3278302063303638,
0x2034303238333030,0x3033783009090a0d,0x3020353032303230,0x3837303031346378,
0x3030303278302030,0x3078302035306163,0x2030383734303234,0x3064783009090a0d,
0x3020313032306530,0x3837303063306178,0x3130303278302030,0x3078302039303438,
0x2033303030303030,0x3031783009090a0d,0x3020333030306632,0x3837303030303078,
0x3030303178302030,0x3078302039303866,0x2030383763333034,0x3033783009090a0d,
0x3020646635303238,0x6337303134633678,0x3030303378302038,0x3078302033303030,
0x2030383230303030,0x3031783009090a0d,0x3020353032323030,0x3837633030343478,
0x3330303478302030,0x3078302064303831,0x2030383730303030,0x3036783009090a0d,
0x3020643061313230,0x3837633030303078,0x3031303378302030,0x6378302064303630,
0x2030383730303134,0x3036783009090a0d,0x3020353038313230,0x3837633030303078,
0x3030303278302030,0x3078302035303230,0x2030383730333034,0x3033783009090a0d,
0x3020643032303230,0x3837303031346378,0x3130303378302030,0x6378302035303230,
0x2030383730303134,0x3032783009090a0d,0x3020343036383130,0x3034383130303278,
0x3230303378302034,0x6378302035303230,0x2030383730303134,0x3032783009090a0d,
0x3020353065633030,0x3837343032343078,0x6530306478302030,0x3878302035303230,
0x2030383730306330,0x3033783009090a0d,0x3020646633303438,0x6337633034633678,
0x3030303378302038,0x3078302033303030,0x2030383230303030,0x3033783009090a0d,
0x3020353032303230,0x3837303031346378,0x3030303278302030,0x3078302035306163,
0x2030383734303234,0x3064783009090a0d,0x3020313032306530,0x3837303063306178,
0x3130303278302030,0x3078302039303438,0x2033303030303030,0x3031783009090a0d,
0x3020333030323033,0x3837303030303078,0x3638303378302030,0x3678302064663931,
0x2038633730313434,0x3033783009090a0d,0x3020333030303030,0x3832303030303078,
0x3630303378302030,0x6378302031306330,0x2030383730303134,0x3032783009090a0d,
0x3020313038313030,0x3837303030343078,0x3230303378302030,0x6378302035303030,
0x2030383730303134,0x3031783009090a0d,0x3020313030383130,0x3030303030303078,
0x3030303278302033,0x3078302035306164,0x2030383734303234,0x3064783009090a0d,
0x3020313032306530,0x3837303063306178,0x0a0d7d090a0d2031,0x2065646f630a0d7d,
0x656d616e090a0d7b,0x7233315a5f203d20,0x63756465725f6e75,0x5f5369506e6f6974,
0x090a0d5f53695f53,0x30203d206d656d6c,0x206d656d73090a0d,0x090a0d343033203d,
0x36203d2020676572,0x2020726162090a0d,0x6962090a0d31203d,0x0d7b2065646f636e,
0x303061783009090a,0x7830203930633430,0x3038373030323430,0x3030303031783020,
0x3034783020393065,0x0d20303837343030,0x303036783009090a,0x7830203530383432,
0x3038373830323030,0x6331303033783020,0x6336783020646666,0x0d20386337633032,
0x303033783009090a,0x7830203330303030,0x3038323030303030,0x3032303033783020,
0x3463783020353032,0x0d20303837303031,0x303061783009090a,0x7830203930303030,
0x3038373030303430,0x6330303032783020,0x3430783020353063,0x0d20303837343032,
0x303061783009090a,0x7830203130323430,0x3038373030323430,0x3032303030783020,
0x3063783020353034,0x0d20303837303030,0x303064783009090a,0x7830203530323065,
0x3038373030633038,0x3030303034783020,0x3030783020643036,0x0d20303837303030,
0x313033783009090a,0x7830206430363030,0x3038373030313463,0x3030303036783020,
0x3030783020643034,0x0d20303837633030,0x303033783009090a,0x7830206430363031,
0x3038373030313463,0x3833303032783020,0x3032783020633034,0x0d20303130383330,
0x303033783009090a,0x7830206430363032,0x3038373030313463,0x3032303033783020,
0x3463783020313138,0x0d20303837303031,0x303132783009090a,0x7830206330386533,
0x3431386534303132,0x3065303064783020,0x3038783020313136,0x0d20303837303063,
0x303064783009090a,0x7830206430613065,0x3038373030633038,0x3030303032783020,
0x3430783020353130,0x0d20303837383030,0x303430783009090a,0x7830203130323130,
0x3038373031323465,0x3032303030783020,0x3063783020353061,0x0d20303837303030,
0x303430783009090a,0x7830203130323130,0x3038376330323465,0x6666313638783020,
0x3030783020333065,0x0d20303030303030,0x373033783009090a,0x7830206466313063,
0x3863373830303436,0x6232303031783020,0x3030783020333030,0x0d20303832303030,
0x303033783009090a,0x7830206466313032,0x3863376330303436,0x3732303061783020,
0x3030783020333030,0x0d20303030303030,0x303031783009090a,0x7830203330303732,
0x3038323030303030,0x3030303032783020,0x3430783020643034,0x0d20303837303030,
0x303030783009090a,0x7830203530343032,0x3038373030303063,0x3032303030783020,
0x3063783020393036,0x0d20303837303030,0x373433783009090a,0x7830206430326463,
0x3038373431326336,0x6463373833783020,0x6336783020313132,0x0d20303837343132,
0x303064783009090a,0x7830206430363034,0x3038373030303430,0x3030303061783020,
0x6332783020643036,0x0d20303837343130,0x303430783009090a,0x7830203130323130,
0x3038376330323465,0x3030303066783020,0x3065783020313030,0x0d20323030303030,
0x313638783009090a,0x7830203330656666,0x3030303030303030,0x3031303033783020,
0x3465783020313030,0x0d20306337303031,0x303031783009090a,0x7830203330306331,
0x3038323030303030,0x3063373033783020,0x3436783020646635,0x0d20386337343130,
0x303033783009090a,0x7830203330303030,0x3038323030303030,0x3032303033783020,
0x3463783020353032,0x0d20303837303031,0x303131783009090a,0x7830203030326630,
0x3430616531303132,0x3065303064783020,0x3061783020313032,0x0d20313837303063,
0x0a0d7d0a0d7d090a,0x0000000000000000
};


}
#line 1287 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.fatbin.c"

static __cudaFatPtxEntry   __ptxEntries  [] = {{0,0}};
static __cudaFatCubinEntry __cubinEntries[] = {{(char*)"sm_13",(char*)__deviceText_$sm_13$},{0,0}};
static __cudaFatDebugEntry __debugEntries0 = {0, 0, 0, 0} ;


#pragma data_seg(".nvFatBinSegment")
#pragma data_seg()

__declspec(allocate(".nvFatBinSegment")) static __cudaFatCudaBinary __fatDeviceText= {0x1ee55a01,0x00000003,0x8ecc680c,(char*)"0f33a26fe5dec6e9",(char*)"d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu",(char*)"",__ptxEntries,__cubinEntries,&__debugEntries0,0,0,0,0,0,0x653e42e6};

#line 5 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"
#line 1 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"













































































































#line 111 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"

#line 1 "C:\\CUDA\\bin64/../include\\host_defines.h"




































































































































#line 134 "C:\\CUDA\\bin64/../include\\host_defines.h"
#line 113 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"


























extern "C" {
#line 141 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"

extern void** __stdcall __cudaRegisterFatBinary(
  void *fatCubin
);

extern void __stdcall __cudaUnregisterFatBinary(
  void **fatCubinHandle
);

extern void __stdcall __cudaRegisterVar(
        void **fatCubinHandle,
        char  *hostVar,
        char  *deviceAddress,
  const char  *deviceName,
        int    ext,
        int    size,
        int    constant,
        int    global
);

extern void __stdcall __cudaRegisterTexture(
        void                    **fatCubinHandle,
  const struct textureReference  *hostVar,
  const void                    **deviceAddress,
  const char                     *deviceName,
        int                       dim,       
        int                       norm,      
        int                       ext        
);

extern void __stdcall __cudaRegisterSurface(
        void                    **fatCubinHandle,
  const struct surfaceReference  *hostVar,
  const void                    **deviceAddress,
  const char                     *deviceName,
        int                       dim,       
        int                       ext        
);

extern void __stdcall __cudaRegisterShared(
  void **fatCubinHandle,
  void **devicePtr
);

extern void __stdcall __cudaRegisterSharedVar(
  void   **fatCubinHandle,
  void   **devicePtr,
  size_t   size,
  size_t   alignment,
  int      storage
);

extern void __stdcall __cudaRegisterFunction(
        void   **fatCubinHandle,
  const char    *hostFun,
        char    *deviceFun,
  const char    *deviceName,
        int      thread_limit,
        uint3   *tid,
        uint3   *bid,
        dim3    *bDim,
        dim3    *gDim,
        int     *wSize
);


}
#line 209 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"





#line 215 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"

extern int atexit(void(*)(void));

#line 219 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"

static void **__cudaFatCubinHandle;

static void __cudaUnregisterBinaryUtil(void)
{
  __cudaUnregisterFatBinary(__cudaFatCubinHandle);
}



































#line 262 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"












#line 1 "C:\\CUDA\\bin64/../include\\common_functions.h"

































































#line 67 "C:\\CUDA\\bin64/../include\\common_functions.h"

#line 1 "c:\\cuda\\include\\crt/func_macro.h"













































#line 47 "c:\\cuda\\include\\crt/func_macro.h"





#line 53 "c:\\cuda\\include\\crt/func_macro.h"










#line 64 "c:\\cuda\\include\\crt/func_macro.h"






#line 71 "c:\\cuda\\include\\crt/func_macro.h"








#line 80 "c:\\cuda\\include\\crt/func_macro.h"






#line 87 "c:\\cuda\\include\\crt/func_macro.h"






#line 94 "c:\\cuda\\include\\crt/func_macro.h"

#line 96 "c:\\cuda\\include\\crt/func_macro.h"

#line 98 "c:\\cuda\\include\\crt/func_macro.h"
#line 69 "C:\\CUDA\\bin64/../include\\common_functions.h"

static clock_t __cuda_clock(void)
{
  return clock();
}

static void *__cuda_memset(void *s, int c, size_t n)
{
  return memset(s, c, n);
}

static void *__cuda_memcpy(void *d, const void *s, size_t n)
{
  return memcpy(d, s, n);
}

#line 86 "C:\\CUDA\\bin64/../include\\common_functions.h"







#line 1 "c:\\cuda\\include\\math_functions.h"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 904 "c:\\cuda\\include\\math_functions.h"

#line 1 "c:\\cuda\\include\\crt/func_macro.h"
































































































#line 98 "c:\\cuda\\include\\crt/func_macro.h"
#line 906 "c:\\cuda\\include\\math_functions.h"



























#line 934 "c:\\cuda\\include\\math_functions.h"







static double log2(double a)
{
  return log(a) / log(2.0);
}

static float log2f(float a)
{
  return (float)log2((double)a);
}

static double exp2(double a)
{
  return pow(2.0, a);
}

static float exp2f(float a)
{
  return (float)exp2((double)a);
}

static long long int llabs(long long int a)
{
  return a < 0ll ? -a : a;
}



#line 969 "c:\\cuda\\include\\math_functions.h"

#line 971 "c:\\cuda\\include\\math_functions.h"

static int __cuda_abs(int a)
{
  return abs(a);
}

static float __cuda_fabsf(float a)
{
  return fabsf(a);
}

static long long int __cuda_llabs(long long int a)
{

  return ::llabs(a);


#line 989 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_exp2f(float a)
{
  return exp2f(a);
}

#line 1 "c:\\cuda\\include\\device_functions.h"




















































































































































































































































































































































































































































#line 438 "c:\\cuda\\include\\device_functions.h"

#line 1 "c:\\cuda\\include\\crt/func_macro.h"
































































































#line 98 "c:\\cuda\\include\\crt/func_macro.h"
#line 440 "c:\\cuda\\include\\device_functions.h"

#line 1 "c:\\cuda\\include\\host_defines.h"




































































































































#line 134 "c:\\cuda\\include\\host_defines.h"
#line 442 "c:\\cuda\\include\\device_functions.h"
#line 1 "c:\\cuda\\include\\math_constants.h"























































































#line 89 "c:\\cuda\\include\\math_constants.h"



















































#line 141 "c:\\cuda\\include\\math_constants.h"
#line 443 "c:\\cuda\\include\\device_functions.h"



















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 2383 "c:\\cuda\\include\\device_functions.h"

#line 1 "c:\\cuda\\include\\common_types.h"




































union __cudart_FloatUintCvt {
    float f;
    unsigned int i;
};
 
union __cudart_FloatIntCvt {
    float f;
    int i;
};

union __cudart_DoubleUlonglongCvt {
    double d;
    unsigned long long int i;
};

union __cudart_DoubleLonglongCvt {
    double d;
    long long int i;
};

union __cudart_DoubleInthiloCvt {
    double     d;
    signed int i[2];
};

struct __cudart_UintUint {
    unsigned int lo;
    unsigned int hi;
};

#line 68 "c:\\cuda\\include\\common_types.h"
#line 2385 "c:\\cuda\\include\\device_functions.h"

static  const unsigned char __internal_rcpTab[128] = 
{
  0xff, 0xfd, 0xfb, 0xf9, 0xf7, 0xf5, 0xf4, 0xf2, 
  0xf0, 0xee, 0xed, 0xeb, 0xe9, 0xe8, 0xe6, 0xe4,
  0xe3, 0xe1, 0xe0, 0xde, 0xdd, 0xdb, 0xda, 0xd8, 
  0xd7, 0xd5, 0xd4, 0xd3, 0xd1, 0xd0, 0xcf, 0xcd,
  0xcc, 0xcb, 0xca, 0xc8, 0xc7, 0xc6, 0xc5, 0xc4, 
  0xc2, 0xc1, 0xc0, 0xbf, 0xbe, 0xbd, 0xbc, 0xbb,
  0xba, 0xb9, 0xb8, 0xb7, 0xb6, 0xb5, 0xb4, 0xb3, 
  0xb2, 0xb1, 0xb0, 0xaf, 0xae, 0xad, 0xac, 0xab,
  0xaa, 0xa9, 0xa8, 0xa8, 0xa7, 0xa6, 0xa5, 0xa4, 
  0xa3, 0xa3, 0xa2, 0xa1, 0xa0, 0x9f, 0x9f, 0x9e,
  0x9d, 0x9c, 0x9c, 0x9b, 0x9a, 0x99, 0x99, 0x98, 
  0x97, 0x97, 0x96, 0x95, 0x95, 0x94, 0x93, 0x93,
  0x92, 0x91, 0x91, 0x90, 0x8f, 0x8f, 0x8e, 0x8e, 
  0x8d, 0x8c, 0x8c, 0x8b, 0x8b, 0x8a, 0x89, 0x89,
  0x88, 0x88, 0x87, 0x87, 0x86, 0x85, 0x85, 0x84, 
  0x84, 0x83, 0x83, 0x82, 0x82, 0x81, 0x81, 0x80
};

static  const unsigned int __internal_invSqrtCubeTab[96] =
{ 
  0xfa0bf8fe, 0xee6b28fa, 0xe5f024f7, 0xdaf268f3,
  0xd2f000f0, 0xc890c0ec, 0xc10378e9, 0xb9a758e6,
  0xb4da40e4, 0xadcea0e1, 0xa6f278de, 0xa279c0dc,
  0x9beb48d9, 0x97a5c4d7, 0x916340d4, 0x8d4fc8d2,
  0x895000d0, 0x8563b8ce, 0x818ac0cc, 0x7dc4e8ca,
  0x7a1200c8, 0x7671d8c6, 0x72e440c4, 0x6f6908c2,
  0x6db240c1, 0x6a523cbf, 0x670424bd, 0x6563c0bc,
  0x623028ba, 0x609ce8b9, 0x5d8364b7, 0x5bfd18b6,
  0x58fd40b4, 0x5783a8b3, 0x560e48b2, 0x533000b0,
  0x51c70caf, 0x506238ae, 0x4da4c0ac, 0x4c4c10ab,
  0x4af768aa, 0x49a6b8a9, 0x485a00a8, 0x471134a7,
  0x45cc58a6, 0x434e40a4, 0x4214f8a3, 0x40df88a2,
  0x3fade0a1, 0x3e8000a0, 0x3d55dc9f, 0x3c2f789e,
  0x3c2f789e, 0x3b0cc49d, 0x39edc09c, 0x38d2609b,
  0x37baa89a, 0x36a68899, 0x35960098, 0x34890497,
  0x34890497, 0x337f9896, 0x3279ac95, 0x31774094,
  0x30784893, 0x30784893, 0x2f7cc892, 0x2e84b091,
  0x2d900090, 0x2d900090, 0x2c9eac8f, 0x2bb0b88e,
  0x2bb0b88e, 0x2ac6148d, 0x29dec08c, 0x29dec08c,
  0x28fab08b, 0x2819e88a, 0x2819e88a, 0x273c5889,
  0x273c5889, 0x26620088, 0x258ad487, 0x258ad487,
  0x24b6d886, 0x24b6d886, 0x23e5fc85, 0x23184084,
  0x23184084, 0x224d9883, 0x224d9883, 0x21860882,
  0x21860882, 0x20c18081, 0x20c18081, 0x20000080
};

static float __internal_frcp_kernel (float x,enum cudaRoundMode mode)
{
  unsigned long long prod;
  volatile union __cudart_FloatUintCvt arg;
  unsigned int expo;
  unsigned int sign;
  unsigned f, y;
    
  arg.f = x;
  sign = arg.i & 0x80000000;
  expo = (arg.i >> 23);
  expo = expo & 0xff;
  f = expo - 1;
    
  if (f <= 0xFD) {
    y = (arg.i << 8);
    y = y | 0x80000000;
    
    arg.i = __internal_rcpTab[(y >> 24) - 128];
    
    f = arg.i * arg.i;
    f = f << 16;
    prod = ((unsigned long long)y) * f;
    arg.i = (arg.i << 24) - (unsigned)(prod >> 32);
      
    f = arg.i + arg.i;
    prod = ((unsigned long long)y) * f;
    f = (unsigned)(-(int)(prod >> 32));
    prod = ((unsigned long long)arg.i) * f;
    y = y >> 8;
    
    expo = (2 * 127) - expo - 2;
    arg.i = (unsigned)(prod >> 32);
    if (mode == cudaRoundNearest) {
      arg.i = arg.i >> 6;
    } else {
      arg.i = (arg.i + 32) >> 6;
    }
    if ((int)expo >= 0) {
      f = y * arg.i;
      arg.i = ((expo << 23) + arg.i) | sign;
    } else {
      
      expo = -(int)expo;
      arg.i = arg.i >> expo;
      f = y * arg.i;
      arg.i = arg.i | sign;
    }
    if (mode == cudaRoundNearest) {
      expo = f + y;
      if ((int)f < 0) f = (unsigned)(-(int)f);
      if ((int)expo < 0) expo = (unsigned)(-(int)expo);
      if (expo < f) arg.i++;
    } else if (mode == cudaRoundZero) {
      if ((int)f > 0) arg.i = arg.i - 1;
    } else if (mode == cudaRoundPosInf) {
      if (((int)f > 0) &&  sign) arg.i = arg.i - 1;
      if (((int)f < 0) && !sign) arg.i = arg.i + 1;
    } else { 
      if (((int)f > 0) && !sign) arg.i = arg.i - 1;
      if (((int)f < 0) &&  sign) arg.i = arg.i + 1;
    }
    return arg.f;
  } else {
    
    if (!(arg.i << 1)) {
      arg.i = 0x7F800000 | arg.i;
      return arg.f;
    } 
    
    if ((arg.i << 1) == 0xff000000) {
      arg.i &= 0x80000000;
      return arg.f;
    }
    
    if ((arg.i << 1) > 0xff000000) {
      arg.i |= 0x00400000;
      return arg.f;
    }
    
    f = 0;
    arg.i <<= 8;
    do {
      f++;
      arg.i <<= 1;
    } while ((int)arg.i > 0);
    arg.i >>= 8;
    arg.i |= sign;
    arg.f = __internal_frcp_kernel (arg.f, mode);
    expo = ((arg.i << 1) >> 24);
    if ((expo + f) < 255) {
      arg.i = (arg.i + (f << 23));
      return arg.f;
    } 
    if (mode == cudaRoundNearest) {
      arg.i = (arg.i & 0x80000000) | 0x7f800000;
    } else if (mode == cudaRoundZero) {
      arg.i = (arg.i & 0x80000000) | 0x7f7fffff;
    } else if (mode == cudaRoundPosInf) {
      arg.i = (arg.i & 0x80000000) | ((sign) ? 0x7f7fffff : 0x7f800000);
    } else { 
      arg.i = (arg.i & 0x80000000) | ((sign) ? 0x7f800000 : 0x7f7fffff);
    }
    return arg.f;
  }
}

static float __internal_fsqrt_kernel (float radicand, enum cudaRoundMode mode)
#line 2543 "c:\\cuda\\include\\device_functions.h"
{
  unsigned long long prod;
  volatile union __cudart_FloatUintCvt arg;
  unsigned int expo;
  unsigned int s, f, x;

  arg.f = radicand;
  expo = arg.i >> 23;
  expo = expo & 0xff;
  f = expo - 1;

  if ((arg.i <= 0x80000000) && (f <= 0xFD)) {
    
    x = (arg.i << 8) | 0x80000000;
    x = x >> (expo & 1);
    
    arg.i = f = __internal_invSqrtCubeTab[((unsigned)x >> 25) - 32];
    
    prod = ((unsigned long long)x) * f;
    arg.i = ((arg.i * 3) << 22) - (unsigned)(prod >> 32);
    
    prod = ((unsigned long long)arg.i) * arg.i;
    s = (unsigned)(prod >> 32);
    prod = ((unsigned long long)x) * s;
    f = 0x30000000 - (unsigned)(prod >> 32);
    prod = ((unsigned long long)f) * arg.i; 
    arg.i = (unsigned)(prod >> 32);
    
    prod = ((unsigned long long)x) * arg.i;
    arg.i = (unsigned)(prod >> 32);
    if (mode == cudaRoundNearest) {
      arg.i = arg.i >> 3;
    } else {
      arg.i = (arg.i + 4) >> 3;
    }
    x = (x << 16) - (arg.i * arg.i);
    
    if (mode == cudaRoundNearest) {
      f = x - (2 * arg.i + 1);
      if ((int)f < 0) f = (unsigned)(-(int)f);
      if ((int)x < 0) x = (unsigned)(-(int)x);
      if (f < x) arg.i ++;
    } else if ((mode == cudaRoundZero) || (mode == cudaRoundMinInf)) {
      if ((int)x < 0) arg.i--;
    } else if (mode == cudaRoundPosInf) {
      if ((int)x > 0) arg.i++;
    }
    arg.i = arg.i + (((expo + 125) & ~0x1) << 22);
    return arg.f;
  } else {
    
    if (!(arg.i << 1) || (arg.i == 0x7F800000)) {
      return arg.f;
    } 
    
    if ((arg.i << 1) > 0xFF000000) {
      arg.i |= 0x00400000;
      return arg.f;
    }
    
    if (arg.i & 0x80000000) {
      arg.i = 0xFFC00000;
      return arg.f;
    } 
    
    x = 0;
    arg.i <<= 8;
    do {
      x++;
      arg.i <<= 1;
    } while ((int)arg.i > 0);
    arg.i >>= 8;
    arg.i += (x & 1) << 23;
    x     += (x & 1);
    arg.f = __internal_fsqrt_kernel (arg.f, mode);
    arg.i -= ((x >> 1) << 23);
    return arg.f;
  }
}

static float __internal_fdiv_kernel (float dividend, float divisor, enum cudaRoundMode mode)
#line 2625 "c:\\cuda\\include\\device_functions.h"
{
  unsigned long long prod;
  unsigned r, f, x, y, expox, expoy, sign;
  volatile union __cudart_FloatUintCvt cvtx, cvty, res;

  cvtx.f = dividend;
  cvty.f = divisor;
  expox = ((cvtx.i >> 23) & 0xff) - 1;
  expoy = ((cvty.i >> 23) & 0xff) - 1;
  sign  = ((cvtx.i ^ cvty.i) & 0x80000000);

  if ((expox <= 0xFD) && (expoy <= 0xFD)) {
divide:
    expox = expox - expoy + 127 - 1;
    expoy = expox;
    
    y = (cvty.i << 8) | 0x80000000;
    x = (cvtx.i & 0x00ffffff) | 0x00800000;
    
    r = __internal_rcpTab[(y >> 24) - 128];
    
    f = r * r;
    prod = ((unsigned long long)y) * (f << 16);
    r = (r << 24) - (unsigned)(prod >> 32);
    
    prod = ((unsigned long long)y) * (r << 1);
    f = (unsigned)-(int)(prod >> 32);
    prod = ((unsigned long long)f) * (r << 1);
    r = (unsigned)(prod >> 32);
    
    prod = ((unsigned long long)x) * (r << 1);
    
    if (((int)((prod >> 32) << 8)) > 0) {
      expox--;
      prod = prod + prod;
    }
    if (mode == cudaRoundNearest) {
      
      r = (unsigned)(prod >> 32);
      y = y >> 8;
      
      if (expox <= 0xFD) {
        int rem0, rem1, inc;
        
        prod = ((unsigned long long)y) * r;
        x = x << (23 + ((prod >> 32) >> 15));
        rem1 = x - (unsigned)(prod & 0xffffffff);
        rem0 = rem1 - y;
        inc = abs(rem0) < abs(rem1);
        
        res.i = sign | ((expox << 23) + r + inc);
        return res.f;
      } else if ((int)expox >= 254) {
        
        res.i = sign | 0x7f800000;
        return res.f;
      } else {
        
        int shift = -(int)expox;
        if (shift > 23) {
          
          r = (shift < 25) && ((x != y) || (r > 0x00ff0000));
          res.i = sign | r;
          return res.f;
        } 
        if (x == y) {
          
          shift = -(int)expoy;
          r = 0x00800000 >> shift;
          res.i = sign | r;
          return res.f;
        }
        {
          unsigned long long tempx;
          long long remlo, remhi;
          
          r = r >> shift;
          prod  = ((unsigned long long)y) * r;
          tempx = ((unsigned long long)x) << (23 - shift);
          remlo = 2 * tempx - 2 * prod - y;
          remhi = remlo + 2 * tempx;
          if (remlo < 0) remlo = -remlo;
          if (remhi < 0) remhi = -remhi;
          if (remhi < remlo) tempx = 2 * tempx;
          remlo = tempx - prod;
          remhi = remlo - y;
          if (remlo < 0) remlo = -remlo;
          if (remhi < 0) remhi = -remhi;
          if ((remhi < remlo) || ((remhi == remlo) && (r & 1))) r++;
          res.i = sign | r;
          return res.f;
        }
      }
    } else if (mode == cudaRoundZero) {
      
      prod += 0x0000000080000000ULL;
      r = (unsigned)(prod >> 32);
      y = y >> 8;
      
      if (expox <= 0xFD) {
        int rem1;
        prod = ((unsigned long long)y) * r;
        x = x << (23 + ((prod >> 32) >> 15));
        rem1 = x - (unsigned)(prod & 0xffffffff);
        if (rem1 < 0) r--;
        r = (expox << 23) + r;
        if (r == 0x7f800000) r = 0x7f7fffff;
        res.i = sign | r;
        return res.f;
      } else if ((int)expox >= 254) {
        
        res.i = sign | 0x7f7fffff;
        return res.f;
      } else {
        
        int shift = -(int)expox;
        if ((x == y) && (shift < 31)) {
          shift = -(int)expoy;
          r = 0x00800000 >> shift;
          res.i = sign | r;
          return res.f;
        }
        if (shift > 23) {
          r = 0;
          res.i = sign | r;
          return res.f;
        } 
        {
          unsigned long long tempx;
          long long remlo, remhi;
          
          r = r >> shift;
          prod  = ((unsigned long long)y) * r;
          tempx = ((unsigned long long)x) << (23 - shift);
          remlo = 2 * tempx - 2 * prod - y;
          remhi = remlo + 2 * tempx;
          if (remlo < 0) remlo = -remlo;
          if (remhi < 0) remhi = -remhi;
          if (remhi < remlo) tempx = 2 * tempx;
          remlo = tempx - prod;
          if ((remlo < 0) & (r != 0)) r--;
          res.i = sign | r;
          return res.f;
        }
      }
    } else if (mode == cudaRoundPosInf) {
      
      prod += 0x0000000080000000ULL;
      r = (unsigned)(prod >> 32);
      y = y >> 8;
      
      if (expox <= 0xFD) {
        int rem1;
        prod = ((unsigned long long)y) * r;
        x = x << (23 + ((prod >> 32) >> 15));
        rem1 = x - (unsigned)(prod & 0xffffffff);
        if ((rem1 < 0) &&  (sign)) r--;
        if ((rem1 > 0) && (!sign)) r++;
        r = (expox << 23) + r;
        if ((r == 0x7f800000) && (sign)) r = 0x7f7fffff;
        res.i = sign | r;
        return res.f;
      } else if ((int)expox >= 254) {
        
        r = sign ? 0x7f7fffff : 0x7f800000;
        res.i = sign | r;
        return res.f;
      } else {
        
        int shift = -(int)expox;
        if ((x == y) && (shift <= 24)) {
          shift = -(int)expoy;
          r = 0x00800000 >> shift;
          if (r == 0) r = !sign; 
          res.i = sign | r;
          return res.f;
        }
        if (shift > 23) {
          r = !sign; 
          res.i = sign | r;
          return res.f;
        } 
        {
          unsigned long long tempx;
          long long remlo, remhi;
          
          r = r >> shift;
          prod  = ((unsigned long long)y) * r;
          tempx = ((unsigned long long)x) << (23 - shift);
          remlo = 2 * tempx - 2 * prod - y;
          remhi = remlo + 2 * tempx;
          if (remlo < 0) remlo = -remlo;
          if (remhi < 0) remhi = -remhi;
          if (remhi < remlo) tempx = 2 * tempx;
          remlo = tempx - prod;
          if ((remlo < 0) && (r != 0) &&  (sign)) r--;
          if ((remlo > 0) &&             (!sign)) r++;
          res.i = sign | r;
          return res.f;
        }
      }
    } else if (mode == cudaRoundMinInf) {
      
      prod += 0x0000000080000000ULL;
      r = (unsigned)(prod >> 32);
      y = y >> 8;
      
      if (expox <= 0xFD) {
        int rem1;
        prod = ((unsigned long long)y) * r;
        x = x << (23 + ((prod >> 32) >> 15));
        rem1 = x - (unsigned)(prod & 0xffffffff);
        if ((rem1 < 0) && (!sign)) r--;
        if ((rem1 > 0) &&  (sign)) r++;
        r = (expox << 23) + r;
        if ((r == 0x7f800000) && (!sign)) r = 0x7f7fffff;
        res.i = sign | r;
        return res.f;
      } else if ((int)expox >= 254) {
        
        r = sign ? 0x7f800000 : 0x7f7fffff;
        res.i = sign | r;
        return res.f;
      } else {
        
        int shift = -(int)expox;
        if ((x == y) && (shift <= 24)) {
          shift = -(int)expoy;
          r = 0x00800000 >> shift;
          if (r == 0) r = !!sign; 
          res.i = sign | r;
          return res.f;
        }
        if (shift > 23) {
          r = !!sign; 
          res.i = sign | r;
          return res.f;
        } 
        {
          unsigned long long tempx;
          long long remlo, remhi;
          
          r = r >> shift;
          prod  = ((unsigned long long)y) * r;
          tempx = ((unsigned long long)x) << (23 - shift);
          remlo = 2 * tempx - 2 * prod - y;
          remhi = remlo + 2 * tempx;
          if (remlo < 0) remlo = -remlo;
          if (remhi < 0) remhi = -remhi;
          if (remhi < remlo) tempx = 2 * tempx;
          remlo = tempx - prod;
          if ((remlo < 0) && (r != 0) && (!sign)) r--;
          if ((remlo > 0) &&              (sign)) r++;
          res.i = sign | r;
          return res.f;
        }
      }
    }
  }
  {
    int xzero, yzero, xinf, yinf, xnan, ynan;
    
    xnan = (cvtx.i << 1) > 0xff000000;
    ynan = (cvty.i << 1) > 0xff000000;
    
    if (xnan) {
      res.i = cvtx.i | 0x00400000;
      return res.f;
    }
    if (ynan) {
      res.i = cvty.i | 0x00400000;
      return res.f;
    }
    xzero = (cvtx.i << 1) == 0x00000000;
    yzero = (cvty.i << 1) == 0x00000000;
    xinf  = (cvtx.i << 1) == 0xff000000;
    yinf  = (cvty.i << 1) == 0xff000000;
    
    if ((xzero & yzero) | (xinf & yinf)) {
      res.i = 0xffc00000;
      return res.f;
    }
    
    if (xzero | yinf) {
      res.i = sign;
      return res.f;
    }
    
    if (yzero | xinf) {
      res.i = sign | 0x7f800000;
      return res.f;
    }
    
    if ((int)expox < 0) {
      cvtx.i = cvtx.i << 9;
      while ((int)cvtx.i >= 0) {
        expox--;
        cvtx.i = cvtx.i + cvtx.i;
      }
      cvtx.i = cvtx.i >> 8;
    }
    if ((int)expoy < 0) {
      cvty.i = cvty.i << 9;
      while ((int)cvty.i >= 0) {
        expoy--;
        cvty.i = cvty.i + cvty.i;
      }
      cvty.i = cvty.i >> 8;
    }
    goto divide;
  }
}

static float __internal_fmul_kernel (float a, float b, enum cudaRoundMode mode)
#line 2940 "c:\\cuda\\include\\device_functions.h"
{
  unsigned long long product;
  volatile union __cudart_FloatUintCvt xx, yy;
  unsigned expo_x, expo_y;
    
  xx.f = a;
  yy.f = b;

  expo_y = 0xFF;
  expo_x = expo_y & (xx.i >> 23);
  expo_x = expo_x - 1;
  expo_y = expo_y & (yy.i >> 23);
  expo_y = expo_y - 1;
    
  if ((expo_x <= 0xFD) && 
      (expo_y <= 0xFD)) {
multiply:
    expo_x = expo_x + expo_y;
    expo_y = xx.i ^ yy.i;
    xx.i = xx.i & 0x00ffffff;
    yy.i = yy.i << 8;
    xx.i = xx.i | 0x00800000;
    yy.i = yy.i | 0x80000000;
    
    product = ((unsigned long long)xx.i) * yy.i;
    expo_x = expo_x - 127 + 2;
    expo_y = expo_y & 0x80000000;
    xx.i = (unsigned int)(product >> 32);
    yy.i = (unsigned int)(product & 0xffffffff);
    
    if (xx.i < 0x00800000) {
      xx.i = (xx.i << 1) | (yy.i >> 31);
      yy.i = (yy.i << 1);
      expo_x--;
    }
    if (expo_x <= 0xFD) {
      xx.i = xx.i | expo_y;          
      xx.i = xx.i + (expo_x << 23);  
      
      if (mode == cudaRoundNearest) {
        if (yy.i < 0x80000000) return xx.f;
        xx.i += ((yy.i == 0x80000000) ? (xx.i & 1) : (yy.i >> 31));
      } else if (mode == cudaRoundZero) {          
      } else if (mode == cudaRoundPosInf) {
        xx.i += (yy.i && !expo_y);
      } else if (mode == cudaRoundMinInf) {
        xx.i += (yy.i && expo_y);
      }
      return xx.f;    
    } else if ((int)expo_x >= 254) {
      
      if (mode == cudaRoundNearest) {
         xx.i = expo_y | 0x7F800000;
      } else if (mode == cudaRoundZero) {
         xx.i = expo_y | 0x7F7FFFFF;
      } else if (mode == cudaRoundPosInf) {
         xx.i = (expo_y ? 0xff7fffff : 0x7F800000);
      } else { 
         xx.i = (expo_y ? 0xFF800000 : 0x7f7fffff);
      }
      return xx.f;
    } else {
      
      expo_x = ((unsigned int)-((int)expo_x));
      if (mode == cudaRoundNearest) {
        if (expo_x > 25) {
          
          xx.i = expo_y;
          return xx.f;
        } else {
          yy.i = (xx.i << (32 - expo_x)) | ((yy.i) ? 1 : 0);
          xx.i = expo_y + (xx.i >> expo_x);
          xx.i += ((yy.i == 0x80000000) ? (xx.i & 1) : (yy.i >> 31));
          return xx.f;
        }
      } else if (mode == cudaRoundZero) {
        if (expo_x > 25) expo_x = 25; 
        xx.i = expo_y + (xx.i >> expo_x);
        return xx.f;
      } else if (mode == cudaRoundPosInf) {
        if (expo_x > 25) expo_x = 25;
        yy.i = (xx.i << (32 - expo_x)) | ((yy.i) ? 1 : 0);
        xx.i = expo_y + (xx.i >> expo_x);
        xx.i += (yy.i && !expo_y);
        return xx.f;
      } else { 
        if (expo_x > 25) expo_x = 25;
        yy.i = (xx.i << (32 - expo_x)) | ((yy.i) ? 1 : 0);
        xx.i = expo_y + (xx.i >> expo_x);
        xx.i += (yy.i && expo_y);
        return xx.f;
      } 
    }
  } else {
    product = xx.i ^ yy.i;
    product = product & 0x80000000;
    if (!(xx.i & 0x7fffffff)) {
      if (expo_y != 254) {
        xx.i = (unsigned int)product;
        return xx.f;
      }
      expo_y = yy.i << 1;
      if (expo_y == 0xFF000000) {
        xx.i = expo_y | 0x00C00000;
      } else {
        xx.i = yy.i | 0x00400000;
      }
      return xx.f;
    }
    if (!(yy.i & 0x7fffffff)) {
      if (expo_x != 254) {
        xx.i = (unsigned int)product;
        return xx.f;
      }
      expo_x = xx.i << 1;
      if (expo_x == 0xFF000000) {
        xx.i = expo_x | 0x00C00000;
      } else {
        xx.i = xx.i | 0x00400000;
      }
      return xx.f;
    }
    if ((expo_y != 254) && (expo_x != 254)) {
      expo_y++;
      expo_x++;
      if (expo_x == 0) {
        expo_y |= xx.i & 0x80000000;
        



        xx.i = xx.i << 8;
        while (!(xx.i & 0x80000000)) {
          xx.i <<= 1;
          expo_x--;
        }
        xx.i = (xx.i >> 8) | (expo_y & 0x80000000);
        expo_y &= ~0x80000000;
        expo_y--;
        goto multiply;
      }
      if (expo_y == 0) {
        expo_x |= yy.i & 0x80000000;
        yy.i = yy.i << 8;
        while (!(yy.i & 0x80000000)) {
          yy.i <<= 1;
          expo_y--;
        }
        yy.i = (yy.i >> 8) | (expo_x & 0x80000000);
        expo_x &= ~0x80000000;
        expo_x--;
        goto multiply;
      }
    }
    expo_x = xx.i << 1;
    expo_y = yy.i << 1;
    
    if (expo_x > 0xFF000000) {
      
      xx.i = xx.i | 0x00400000;
      return xx.f;
    }
    
    if (expo_y > 0xFF000000) {
      
      xx.i = yy.i | 0x00400000;
      return xx.f;
    } 
    xx.i = (unsigned int)product | 0x7f800000;
    return xx.f;
  }
}

static float __internal_fmaf_kernel (float a, float b, float c, enum cudaRoundMode mode)
#line 3115 "c:\\cuda\\include\\device_functions.h"
{
  unsigned long long product;
  unsigned int xx, yy, zz, ww;
  unsigned int temp, s, u;
  unsigned int expo_x, expo_y, expo_z;
  volatile union __cudart_FloatUintCvt cvt;
  
  cvt.f = a;
  xx = cvt.i;
  cvt.f = b;
  yy = cvt.i;
  cvt.f = c;
  zz = cvt.i;

  temp = 0xff;
  expo_x = temp & (xx >> 23);
  expo_x = expo_x - 1;
  expo_y = temp & (yy >> 23);
  expo_y = expo_y - 1;
  expo_z = temp & (zz >> 23);
  expo_z = expo_z - 1;

  if (!((expo_x <= 0xFD) && 
        (expo_y <= 0xFD) &&
        (expo_z <= 0xFD))) {
    



    if ((yy << 1) > 0xff000000) {
      return b + b;
    }
    if ((zz << 1) > 0xff000000) {
      return c + c;
    }
    if ((xx << 1) > 0xff000000) {
      return a + a;
    }
    










    if ((((xx << 1) == 0) && ((yy << 1) == 0xff000000)) ||
        (((yy << 1) == 0) && ((xx << 1) == 0xff000000))) {
      cvt.i = 0xffc00000;
      return cvt.f;
    }
    if ((zz << 1) == 0xff000000) {
      if (((yy << 1) == 0xff000000) || ((xx << 1) == 0xff000000)) {
        if ((int)(xx ^ yy ^ zz) < 0) {
          cvt.i = 0xffc00000;
          return cvt.f;
        }
      }
    }
    



    if ((xx << 1) == 0xff000000) {
      xx = xx ^ (yy & 0x80000000);
      cvt.i = xx;
      return cvt.f;
    }
    if ((yy << 1) == 0xff000000) {
      yy = yy ^ (xx & 0x80000000);
      cvt.i = yy;
      return cvt.f;
    }
    if ((zz << 1) == 0xff000000) {
      cvt.i = zz;
      return cvt.f;
    }
    




    if (zz == 0x80000000) {
      if (((xx << 1) == 0) || ((yy << 1) == 0)) {
        if ((int)(xx ^ yy) < 0) {
          cvt.i = zz;
          return cvt.f;
        }
      }
    }
    


    if (((zz << 1) == 0) && 
        (((xx << 1) == 0) || ((yy << 1) == 0))) {
      if (mode == cudaRoundMinInf) {
        zz = 0x80000000 & (xx ^ yy ^ zz);
      } else {
        zz &= 0x7fffffff;
      }
      cvt.i = zz;
      return cvt.f;
    }
    


    if (((xx << 1) == 0) || ((yy << 1) == 0)) {
      cvt.i = zz;
      return cvt.f;
    }
    
    if (expo_x == (unsigned)-1) {
      temp = xx & 0x80000000;
      xx = xx << 8;
      while (!(xx & 0x80000000)) {
        xx <<= 1;
        expo_x--;
      }
      expo_x++;
      xx = (xx >> 8) | temp;
    }
    
    if (expo_y == (unsigned)-1) {
      temp = yy & 0x80000000;
      yy = yy << 8;
      while (!(yy & 0x80000000)) {
        yy <<= 1;
        expo_y--;
      }
      expo_y++;
      yy = (yy >> 8) | temp;
    }
    
    if ((expo_z == (unsigned)-1) && ((zz << 1) != 0)) {
      temp = zz & 0x80000000;
      zz = zz << 8;
      while (!(zz & 0x80000000)) {
        zz <<= 1;
        expo_z--;
      }
      expo_z++;
      zz = (zz >> 8) | temp;
    }
  }
    
  expo_x = expo_x + expo_y;
  expo_y = xx ^ yy;
  xx = xx & 0x00ffffff;
  yy = yy << 8;
  xx = xx | 0x00800000;
  yy = yy | 0x80000000;

  product = ((unsigned long long)xx) * yy;
  xx = (unsigned)(product >> 32);
  yy = (unsigned)(product & 0xffffffff);

  expo_x = expo_x - 127 + 2;
  expo_y = expo_y & 0x80000000;
  
  if (xx < 0x00800000) {
    xx = (xx << 1) | (yy >> 31);
    yy = (yy << 1);
    expo_x--;
  }
  temp = 0;

  if ((zz << 1) != 0) { 
    s = zz & 0x80000000;
    zz &= 0x00ffffff;
    zz |= 0x00800000;
    ww = 0;
    
    if ((int)expo_z > (int)expo_x) {
      temp = expo_z;
      expo_z = expo_x;
      expo_x = temp;
      temp = zz;
      zz = xx;
      xx = temp;
      temp = ww;
      ww = yy;
      yy = temp;
      temp = expo_y;
      expo_y = s;
      s = temp;
    }
    
    
    expo_z = expo_x - expo_z;
    u = expo_y ^ s;
    if (expo_z <= 49) {
      
      temp = 0;
      while (expo_z >= 32) {
        temp = ww | (temp != 0);
        ww = zz;
        zz = 0;
        expo_z -= 32;
      }
      if (expo_z) {
        temp = ((temp >> expo_z) | (ww << (32 - expo_z)) | 
                ((temp << (32 - expo_z)) != 0));
        ww = (ww >> expo_z) | (zz << (32 - expo_z));
        zz = (zz >> expo_z);
      }
      
    } else {
      temp = 1;
      ww = 0;
      zz = 0;
    }            
    if ((int)u < 0) {
      
      temp = (unsigned)(-(int)temp);
      s = (temp != 0);
      u = yy - s;
      s = u > yy;
      yy = u - ww;
      s += yy > u;
      xx = (xx - zz) - s;
      if (!(xx | yy | temp)) {
        
        if (mode == cudaRoundMinInf) {
          xx = 0x80000000;
        }
        cvt.i = xx;
        return cvt.f;
      }
      if ((int)xx < 0) {
        

        temp = ~temp;
        yy = ~yy;
        xx = ~xx;
        if (++temp == 0) {
          if (++yy == 0) {
            ++xx;
          }
        }
        expo_y ^= 0x80000000;
      }
      
      while (!(xx & 0x00800000)) {
        xx = (xx << 1) | (yy >> 31);
        yy = (yy << 1);
        expo_x--;
      }
    } else {
      
      yy = yy + ww;
      s =  yy < ww;
      xx = xx + zz + s;
      if (xx & 0x01000000) {
        temp = temp | (yy << 31);
        yy = (yy >> 1) | (xx << 31);
        xx = ((xx & 0x80000000) | (xx >> 1)) & ~0x40000000;
        expo_x++;
      }
    }
  }
  temp = yy | (temp != 0);
  if (expo_x <= 0xFD) {
    
    xx |= expo_y; 
    if (mode == cudaRoundNearest) {
      s = xx & 1; 
      xx += (temp == 0x80000000) ? s : (temp >> 31);
    } else if (mode == cudaRoundPosInf) {
      xx += temp && !expo_y;
    } else if (mode == cudaRoundMinInf) {
      xx += temp && expo_y;
    }
    xx = xx + (expo_x << 23); 
    cvt.i = xx;
    return cvt.f;
  } else if ((int)expo_x >= 126) {
    
    if (mode == cudaRoundNearest) {  
      xx = expo_y | 0x7f800000;
    } else if (mode == cudaRoundZero) {
      xx = expo_y | 0x7F7FFFFF;
    } else if (mode == cudaRoundPosInf) {
      xx = expo_y ? 0xFF7FFFFF : 0x7f800000;
    } else if (mode == cudaRoundMinInf) {
      xx = expo_y ? 0xff800000 : 0x7f7fffff;
    }
    cvt.i = xx;
    return cvt.f;
  }
  
  expo_x = (unsigned int)(-(int)expo_x);
  if (expo_x > 25) {
    
    xx = 0;
    if (mode == cudaRoundPosInf) {
      xx += !expo_y;
    } else if (mode == cudaRoundMinInf) {
      xx += !!expo_y;
    }
    cvt.i = expo_y | xx;
    return cvt.f;
  }
  temp = (xx << (32 - expo_x)) | ((temp) ? 1 : 0);
  xx = xx >> expo_x;
  if (mode == cudaRoundNearest) {
    xx = xx + ((temp == 0x80000000) ? (xx & 1) : (temp >> 31));
  } else if (mode == cudaRoundPosInf) {
    xx = xx + (!expo_y && temp);
  } else if (mode == cudaRoundMinInf) {
    xx = xx + (expo_y && temp);
  }
  xx = expo_y + xx; 
  cvt.i = xx;
  return cvt.f;
}

static float __internal_fadd_kernel (float a, float b, enum cudaRoundMode mode)
#line 3436 "c:\\cuda\\include\\device_functions.h"
{
  volatile union __cudart_FloatUintCvt xx, yy;
  unsigned int expo_x;
  unsigned int expo_y;
  unsigned int temp;

  xx.f = a;
  yy.f = b;

  
  expo_y = yy.i << 1;
  if (expo_y > (xx.i << 1)) {
    expo_y = xx.i;
    xx.i   = yy.i;
    yy.i   = expo_y;
  }
    
  temp = 0xff;
  expo_x = temp & (xx.i >> 23);
  expo_x = expo_x - 1;
  expo_y = temp & (yy.i >> 23);
  expo_y = expo_y - 1;

  if ((expo_x <= 0xFD) && 
      (expo_y <= 0xFD)) {
add:
    expo_y = expo_x - expo_y;
    if (expo_y > 25) {
      expo_y = 31;
    }
    temp = xx.i ^ yy.i;
    xx.i = xx.i & ~0x7f000000;
    xx.i = xx.i |  0x00800000;
    yy.i = yy.i & ~0xff000000;
    yy.i = yy.i |  0x00800000;

    if ((int)temp < 0) {
      
      temp = 32 - expo_y;
      temp = (expo_y) ? (yy.i << temp) : 0;
      temp = (unsigned)(-((int)temp));
      xx.i = xx.i - (yy.i >> expo_y) - (temp ? 1 : 0);
      if (xx.i & 0x00800000) {
        if (expo_x <= 0xFD) {
          xx.i = xx.i + (expo_x << 23);
          if (mode == cudaRoundNearest) {
            if (temp < 0x80000000) return xx.f;
            xx.i += ((temp == 0x80000000) ? (xx.i & 1) : (temp >> 31));
          } else if (mode == cudaRoundZero) {              
          } else if (mode == cudaRoundPosInf) {
            xx.i += (temp && !(xx.i & 0x80000000));
          } else if (mode == cudaRoundMinInf) {
            xx.i += (temp && (xx.i & 0x80000000));
          }
          return xx.f;
        }
      } else {
        if ((temp | (xx.i << 1)) == 0) {
          
          if (mode == cudaRoundMinInf) {
            xx.i = 0x80000000;
          } else {
            xx.i = 0;
          }
          return xx.f;
        }
        
        yy.i = xx.i & 0x80000000;
        do {
          xx.i = (xx.i << 1) | (temp >> 31);
          temp <<= 1;
          expo_x--;
        } while (!(xx.i & 0x00800000));
        xx.i = xx.i | yy.i;
      }
    } else {
      
      temp = 32 - expo_y;
      temp = (expo_y) ? (yy.i << temp) : 0;
      xx.i = xx.i + (yy.i >> expo_y);
      if (!(xx.i & 0x01000000)) {
        if (expo_x <= 0xFD) {
          xx.i = xx.i + (expo_x << 23);
          if (mode == cudaRoundNearest) {
            if (temp < 0x80000000) return xx.f;
            xx.i += ((temp == 0x80000000) ? (xx.i & 1) : (temp >> 31));
          } else if (mode == cudaRoundZero) {
          } else if (mode == cudaRoundPosInf) {
            xx.i += (temp && !(xx.i & 0x80000000));
          } else if (mode == cudaRoundMinInf) {
            xx.i += (temp && (xx.i & 0x80000000));
          }
          return xx.f;
        }
      } else {
        
        temp = (xx.i << 31) | (temp >> 1);
        xx.i = ((xx.i & 0x80000000) | (xx.i >> 1)) & ~0x40000000;
        expo_x++;
      }
    }
    if (expo_x <= 0xFD) {
      xx.i = xx.i + (expo_x << 23);
      if (mode == cudaRoundNearest) {
        if (temp < 0x80000000) return xx.f;
        xx.i += ((temp == 0x80000000) ? (xx.i & 1) : (temp >> 31));
      } else if (mode == cudaRoundZero) {
      } else if (mode == cudaRoundPosInf) {
        xx.i += (temp && !(xx.i & 0x80000000));
      } else if (mode == cudaRoundMinInf) {
        xx.i += (temp && (xx.i & 0x80000000));
      }
      return xx.f;
    }
    if ((int)expo_x >= 254) {
      
      temp = xx.i & 0x80000000;
      if (mode == cudaRoundNearest) {
        xx.i = (temp) | 0x7f800000;
      } else if (mode == cudaRoundZero) {
        xx.i = (temp) | 0x7f7fffff;
      } else if (mode == cudaRoundMinInf) {
        xx.i = (temp ? 0xFF800000 : 0x7f7fffff);
      } else if (mode == cudaRoundPosInf) {
        xx.i = (temp ? 0xff7fffff : 0x7F800000);
      }
      return xx.f;
    }
    
    expo_y = expo_x + 32;
    yy.i = xx.i &  0x80000000;
    xx.i = xx.i & ~0xff000000;
    expo_x = (unsigned)(-((int)expo_x));
    temp = xx.i << expo_y | ((temp) ? 1 : 0);
    xx.i = yy.i | (xx.i >> expo_x);
    if (mode == cudaRoundNearest) {
      xx.i += (temp == 0x80000000) ? (xx.i & 1) : (temp >> 31);
    } else if (mode == cudaRoundZero) {
    } else if (mode == cudaRoundPosInf) {
      xx.i += (temp && !yy.i);
    } else if (mode == cudaRoundMinInf) {
      xx.i += (temp && yy.i);
    }
    return xx.f;
  } else {
    
    if (!(yy.i << 1)) {
      if (mode == cudaRoundMinInf) {
        if (!(xx.i << 1)) {
          xx.i = xx.i | yy.i;
        }
      } else {
        if (xx.i == 0x80000000) {
          xx.i = yy.i;
        }
      }
      if ((xx.i << 1) > 0xff000000) {
        xx.i |= 0x00400000;
      }
      return xx.f;
    }
    if ((expo_y != 254) && (expo_x != 254)) {
      
      if (expo_x == (unsigned int) -1) {
        temp = xx.i & 0x80000000;
        xx.i = xx.i << 8;
        while (!(xx.i & 0x80000000)) {
          xx.i <<= 1;
          expo_x--;
        }
        expo_x++;
        xx.i = (xx.i >> 8) | temp;
      }
      if (expo_y == (unsigned int) -1) {
        temp = yy.i & 0x80000000;
        yy.i = yy.i << 8;
        while (!(yy.i & 0x80000000)) {
          yy.i <<= 1;
          expo_y--;
        }
        expo_y++;
        yy.i = (yy.i >> 8) | temp;
      }
      goto add;
    }
    expo_x = xx.i << 1;
    expo_y = yy.i << 1;
    
    if (expo_x > 0xff000000) {
      
      xx.i = xx.i | 0x00400000;
      return xx.f;
    }
    
    if (expo_y > 0xff000000) {
      
      xx.i = yy.i | 0x00400000;
      return xx.f;
    }
    if ((expo_x == 0xff000000) && (expo_y == 0xff000000)) {
      



      expo_x = xx.i ^ yy.i;
      xx.i = xx.i | ((expo_x) ? 0xffc00000 : 0);
      return xx.f;
    }
    
    if (expo_y == 0xff000000) {
      xx.i = yy.i;
    }
    return xx.f;
  }
}

static float __frcp_rn (float a)
{
  return __internal_frcp_kernel (a, cudaRoundNearest);
}

static float __frcp_rz (float a)
{
  return __internal_frcp_kernel (a, cudaRoundZero);
}

static float __frcp_rd (float a)
{
  return __internal_frcp_kernel (a, cudaRoundMinInf);
}

static float __frcp_ru (float a)
{
  return __internal_frcp_kernel (a, cudaRoundPosInf);
}

static float __fsqrt_rn (float a)
{
  return __internal_fsqrt_kernel (a, cudaRoundNearest);
}

static float __fsqrt_rz (float a)
{
  return __internal_fsqrt_kernel (a, cudaRoundZero);
}

static float __fsqrt_rd (float a)
{
  return __internal_fsqrt_kernel (a, cudaRoundMinInf);
}

static float __fsqrt_ru (float a)
{
  return __internal_fsqrt_kernel (a, cudaRoundPosInf);
}

static float __fdiv_rn (float a, float b)
{
  return __internal_fdiv_kernel (a, b, cudaRoundNearest);
}

static float __fdiv_rz (float a, float b)
{
  return __internal_fdiv_kernel (a, b, cudaRoundZero);
}

static float __fdiv_rd (float a, float b)
{
  return __internal_fdiv_kernel (a, b, cudaRoundMinInf);
}

static float __fdiv_ru (float a, float b)
{
  return __internal_fdiv_kernel (a, b, cudaRoundPosInf);
}

static float __fadd_rd (float a, float b)
{
  return __internal_fadd_kernel (a, b, cudaRoundMinInf);
}

static float __fadd_ru (float a, float b)
{
  return __internal_fadd_kernel (a, b, cudaRoundPosInf);
}

static float __fmul_rd (float a, float b)
{
  return __internal_fmul_kernel (a, b, cudaRoundMinInf);
}

static float __fmul_ru (float a, float b)
{
  return __internal_fmul_kernel (a, b, cudaRoundPosInf);
}

static float __fmaf_rn (float a, float b, float c)
{
  return __internal_fmaf_kernel (a, b, c, cudaRoundNearest);
}

static float __fmaf_rz (float a, float b, float c)
{
  return __internal_fmaf_kernel (a, b, c, cudaRoundZero);
}

static float __fmaf_ru (float a, float b, float c)
{
  return __internal_fmaf_kernel (a, b, c, cudaRoundPosInf);
}

static float __fmaf_rd (float a, float b, float c)
{
  return __internal_fmaf_kernel (a, b, c, cudaRoundMinInf);
}

static int __cuda___isnan(double a);
static int __cuda___isnanf(float a);
static int __double2int_rz(double);
static unsigned int __double2uint_rz(double);
static long long int __double2ll_rz(double);
static unsigned long long int __double2ull_rz(double);













static int __mulhi(int a, int b)
{
  long long int c = (long long int)a * (long long int)b;

  return (int)(c >> 32);
}

static unsigned int __umulhi(unsigned int a, unsigned int b)
{
  unsigned long long int c = (unsigned long long int)a * (unsigned long long int)b;

  return (unsigned int)(c >> 32);
}

static unsigned long long int __umul64hi(unsigned long long int a, unsigned long long int b)
{
  unsigned int           a_lo = (unsigned int)a;
  unsigned long long int a_hi = a >> 32;
  unsigned int           b_lo = (unsigned int)b;
  unsigned long long int b_hi = b >> 32;
  unsigned long long int m1 = a_lo * b_hi;
  unsigned long long int m2 = a_hi * b_lo;
  unsigned int           carry;

  carry = (0ULL + __umulhi(a_lo, b_lo) + (unsigned int)m1 + (unsigned int)m2) >> 32;

  return a_hi * b_hi + (m1 >> 32) + (m2 >> 32) + carry;
}

static long long int __mul64hi(long long int a, long long int b)
{
  long long int res;
  res = __umul64hi(a, b);
  if (a < 0LL) res = res - b;
  if (b < 0LL) res = res - a;
  return res;
}

static float __saturatef(float a)
{
  if (__cuda___isnanf(a)) return 0.0f; 
  return a >= 1.0f ? 1.0f : a <= 0.0f ? 0.0f : a;
}

static unsigned int __sad(int a, int b, unsigned int c)
{
  long long int diff = (long long int)a - (long long int)b;

  return (unsigned int)(__cuda_llabs(diff) + (long long int)c);
}

static unsigned int __usad(unsigned int a, unsigned int b, unsigned int c)
{
  long long int diff = (long long int)a - (long long int)b;

  return (unsigned int)(__cuda_llabs(diff) + (long long int)c);
}

static int __mul24(int a, int b)
{

  a &= 0xffffff;
  a = (a & 0x800000) != 0 ? a | ~0xffffff : a;
  b &= 0xffffff;
  b = (b & 0x800000) != 0 ? b | ~0xffffff : b;
#line 3837 "c:\\cuda\\include\\device_functions.h"

  return a * b;
}

static unsigned int __umul24(unsigned int a, unsigned int b)
{

  a &= 0xffffff;
  b &= 0xffffff;
#line 3847 "c:\\cuda\\include\\device_functions.h"

  return a * b;
}

static float __int_as_float(int a)
{
  volatile union __cudart_FloatIntCvt u;

  u.i = a;
  return u.f;
}

static int __float_as_int(float a)
{
  volatile union __cudart_FloatIntCvt u;

  u.f = a;
  return u.i;
}

static long long int __internal_float2ll_kernel(float a, long long int max, long long int min, long long int nan, enum cudaRoundMode rndMode)
{
  unsigned long long int res, t = 0ULL;
  int shift;
  unsigned int ia;

  if (sizeof(a) == sizeof(double) && __cuda___isnan((double)a)) return nan; if (sizeof(a) == sizeof(float) && __cuda___isnanf((float)a)) return nan; if (a >= max) return max; if (a <= min) return min;
  ia = __float_as_int(a);
  shift = 189 - ((ia >> 23) & 0xff);
  res = (unsigned long long int)(((ia << 8) | 0x80000000) >> 1) << 32;
  if (shift >= 64) {
    t = res;
    res = 0;
  } else if (shift) {
    t = res << (64 - shift);
    res = res >> shift;
  }
  if (rndMode == cudaRoundNearest && (long long int)t < 0LL) {
    res += t == 0x8000000000000000ULL ? res & 1ULL : 1ULL;
  }
  else if (rndMode == cudaRoundMinInf && t != 0ULL && ia > 0x80000000) {
    res++;
  }
  else if (rndMode == cudaRoundPosInf && t != 0ULL && (int)ia > 0) {
    res++;
  }
  if ((int)ia < 0) res = (unsigned long long int)-(long long int)res;
  return (long long int)res;
}

static int __internal_float2int(float a, enum cudaRoundMode rndMode)
{
  return (int)__internal_float2ll_kernel(a, 2147483647LL, -2147483648LL, 0LL, rndMode);
}

static int __float2int_rz(float a)
{


#line 3907 "c:\\cuda\\include\\device_functions.h"
  return __internal_float2int(a, cudaRoundZero);
#line 3909 "c:\\cuda\\include\\device_functions.h"
}

static int __float2int_ru(float a)
{
  return __internal_float2int(a, cudaRoundPosInf);
}

static int __float2int_rd(float a)
{
  return __internal_float2int(a, cudaRoundMinInf);
}

static int __float2int_rn(float a)
{
  return __internal_float2int(a, cudaRoundNearest);
}

static long long int __internal_float2ll(float a, enum cudaRoundMode rndMode)
{
  return __internal_float2ll_kernel(a, 9223372036854775807LL, -9223372036854775807LL -1LL, -9223372036854775807LL -1LL, rndMode);
}

static long long int __float2ll_rz(float a)
{


#line 3936 "c:\\cuda\\include\\device_functions.h"
  return __internal_float2ll(a, cudaRoundZero);
#line 3938 "c:\\cuda\\include\\device_functions.h"
}

static long long int __float2ll_ru(float a)
{
  return __internal_float2ll(a, cudaRoundPosInf);
}

static long long int __float2ll_rd(float a)
{
  return __internal_float2ll(a, cudaRoundMinInf);
}

static long long int __float2ll_rn(float a)
{
  return __internal_float2ll(a, cudaRoundNearest);
}

static unsigned long long int __internal_float2ull_kernel(float a, unsigned long long int max, unsigned long long int nan, enum cudaRoundMode rndMode)
{
  unsigned long long int res, t = 0ULL;
  int shift;
  unsigned int ia;

  if (sizeof(a) == sizeof(double) && __cuda___isnan((double)a)) return nan; if (sizeof(a) == sizeof(float) && __cuda___isnanf((float)a)) return nan; if (a >= max) return max; if (a <= 0LL) return 0LL;
  ia = __float_as_int(a);
  shift = 190 - ((ia >> 23) & 0xff);
  res = (unsigned long long int)((ia << 8) | 0x80000000) << 32;
  if (shift >= 64) {
    t = res >> (int)(shift > 64);
    res = 0;
  } else if (shift) {
    t = res << (64 - shift);
    res = res >> shift;
  }
  if (rndMode == cudaRoundNearest && (long long int)t < 0LL) {
    res += t == 0x8000000000000000ULL ? res & 1ULL : 1ULL;
  }
  else if (rndMode == cudaRoundPosInf && t != 0ULL) {
    res++;
  }
  return res;
}

static unsigned int __internal_float2uint(float a, enum cudaRoundMode rndMode)
{
  return (unsigned int)__internal_float2ull_kernel(a, 4294967295U, 0U, rndMode);
}

static unsigned int __float2uint_rz(float a)
{


#line 3991 "c:\\cuda\\include\\device_functions.h"
  return __internal_float2uint(a, cudaRoundZero);
#line 3993 "c:\\cuda\\include\\device_functions.h"
}

static unsigned int __float2uint_ru(float a)
{
  return __internal_float2uint(a, cudaRoundPosInf);
}

static unsigned int __float2uint_rd(float a)
{
  return __internal_float2uint(a, cudaRoundMinInf);
}

static unsigned int __float2uint_rn(float a)
{
  return __internal_float2uint(a, cudaRoundNearest);
}

static unsigned long long int __internal_float2ull(float a, enum cudaRoundMode rndMode)
{
  return __internal_float2ull_kernel(a, 18446744073709551615ULL, 9223372036854775808ULL, rndMode);
}

static unsigned long long int __float2ull_rz(float a)
{


#line 4020 "c:\\cuda\\include\\device_functions.h"
  return __internal_float2ull(a, cudaRoundZero);
#line 4022 "c:\\cuda\\include\\device_functions.h"
}

static unsigned long long int __float2ull_ru(float a)
{
  return __internal_float2ull(a, cudaRoundPosInf);
}

static unsigned long long int __float2ull_rd(float a)
{
  return __internal_float2ull(a, cudaRoundMinInf);
}

static unsigned long long int __float2ull_rn(float a)
{
  return __internal_float2ull(a, cudaRoundNearest);
}

static int __internal_normalize64(unsigned long long int *a)
{
  int lz = 0;

  if ((*a & 0xffffffff00000000ULL) == 0ULL) {
    *a <<= 32;
    lz += 32;
  }
  if ((*a & 0xffff000000000000ULL) == 0ULL) {
    *a <<= 16;
    lz += 16;
  }
  if ((*a & 0xff00000000000000ULL) == 0ULL) {
    *a <<= 8;
    lz += 8;
  }
  if ((*a & 0xf000000000000000ULL) == 0ULL) {
    *a <<= 4;
    lz += 4;
  }
  if ((*a & 0xC000000000000000ULL) == 0ULL) {
    *a <<= 2;
    lz += 2;
  }
  if ((*a & 0x8000000000000000ULL) == 0ULL) {
    *a <<= 1;
    lz += 1;
  }
  return lz;
}

static int __internal_normalize(unsigned int *a)
{
  unsigned long long int t = (unsigned long long int)*a;
  int lz = __internal_normalize64(&t);
  
  *a = (unsigned int)(t >> 32);

  return lz - 32;
}

static float __internal_int2float_kernel(int a, enum cudaRoundMode rndMode)
{
  volatile union __cudart_FloatUintCvt res;
  int shift;
  unsigned int t;
  res.i = a;
  if (a == 0) return res.f;
  if (a < 0) res.i = (unsigned int)-a;
  shift = __internal_normalize((unsigned int*)&res.i);
  t = res.i << 24;
  res.i = (res.i >> 8);
  res.i += (127 + 30 - shift) << 23;
  if (a < 0) res.i |= 0x80000000;
  if ((rndMode == cudaRoundNearest) && (t >= 0x80000000)) {
    res.i += (t == 0x80000000) ? (res.i & 1) : (t >> 31);
  }
  else if ((rndMode == cudaRoundMinInf) && t && (a < 0)) {
    res.i++;
  }
  else if ((rndMode == cudaRoundPosInf) && t && (a > 0)) {
    res.i++;
  }
  return res.f;
}

static float __int2float_rz(int a)
{
  return __internal_int2float_kernel(a, cudaRoundZero);
}

static float __int2float_ru(int a)
{
  return __internal_int2float_kernel(a, cudaRoundPosInf);
}

static float __int2float_rd(int a)
{
  return __internal_int2float_kernel(a, cudaRoundMinInf);
}

static float __int2float_rn(int a)
{


#line 4125 "c:\\cuda\\include\\device_functions.h"
  return __internal_int2float_kernel(a, cudaRoundNearest);
#line 4127 "c:\\cuda\\include\\device_functions.h"
}

static float __internal_uint2float_kernel(unsigned int a, enum cudaRoundMode rndMode)
{
  volatile union __cudart_FloatUintCvt res;
  int shift;
  unsigned int t;
  res.i = a;
  if (a == 0) return res.f;
  shift = __internal_normalize((unsigned int*)&res.i);
  t = res.i << 24;
  res.i = (res.i >> 8);
  res.i += (127 + 30 - shift) << 23;
  if (rndMode == cudaRoundNearest) {
    res.i += (t == 0x80000000) ? (res.i & 1) : (t >> 31);
  }
  else if ((rndMode == cudaRoundPosInf) && t) {
    res.i++;
  }
  return res.f;
}

static float __uint2float_rz(unsigned int a)
{
  return __internal_uint2float_kernel(a, cudaRoundZero);
}

static float __uint2float_ru(unsigned int a)
{
  return __internal_uint2float_kernel(a, cudaRoundPosInf);
}

static float __uint2float_rd(unsigned int a)
{
  return __internal_uint2float_kernel(a, cudaRoundMinInf);
}

static float __uint2float_rn(unsigned int a)
{


#line 4169 "c:\\cuda\\include\\device_functions.h"
  return __internal_uint2float_kernel(a, cudaRoundNearest);
#line 4171 "c:\\cuda\\include\\device_functions.h"
}

static float __ll2float_rn(long long int a)
{
  return (float)a;
}      

static float __internal_ull2float_kernel(unsigned long long int a, enum cudaRoundMode rndMode)
{
  unsigned long long int temp;
  unsigned int res, t;
  int shift;
  if (a == 0ULL) return 0.0f;
  temp = a;
  shift = __internal_normalize64(&temp);
  temp = (temp >> 8) | ((temp & 0xffULL) ? 1ULL : 0ULL);
  res = (unsigned int)(temp >> 32);
  t = (unsigned int)temp;
  res += (127 + 62 - shift) << 23; 
  if (rndMode == cudaRoundNearest) {
    res += (t == 0x80000000) ? (res & 1) : (t >> 31);
  } else if (rndMode == cudaRoundPosInf) {
    res += (t != 0);
  }
  return __int_as_float(res);
}

static float __ull2float_rn(unsigned long long int a)
{


#line 4203 "c:\\cuda\\include\\device_functions.h"
  return __internal_ull2float_kernel(a, cudaRoundNearest);
#line 4205 "c:\\cuda\\include\\device_functions.h"
}   

static unsigned short __float2half_rn(float f)
{
  unsigned int x = __float_as_int (f);
  unsigned int u = (x & 0x7fffffff), remainder, shift, lsb, lsb_s1, lsb_m1;
  unsigned int sign, exponent, mantissa;

  
  if (u > 0x7f800000) {
    return 0x7fff;
  }
  
  sign = ((x >> 16) & 0x8000);
  
  
  if (u > 0x477fefff) {
    return sign | 0x7c00;
  }
  if (u < 0x33000001) {
    return sign | 0x0000;
  }

  exponent = ((u >> 23) & 0xff);
  mantissa = (u & 0x7fffff);

  if (exponent > 0x70) {
    shift = 13;
    exponent -= 0x70;
  } else {
    shift = 0x7e - exponent;
    exponent = 0;
    mantissa |= 0x800000;
  }
  lsb = (1 << shift);
  lsb_s1 = (lsb >> 1);
  lsb_m1 = (lsb - 1);
  
  
  remainder = (mantissa & lsb_m1);
  mantissa >>= shift;
  if (remainder > lsb_s1 || (remainder == lsb_s1 && (mantissa & 0x1))) {
    ++mantissa;
    if (!(mantissa & 0x3ff)) {
      ++exponent;
      mantissa = 0;
    }
  }  

  return sign | (exponent << 10) | mantissa;  
}

static float __half2float(unsigned short h)
{
  unsigned int sign = ((h >> 15) & 1);
  unsigned int exponent = ((h >> 10) & 0x1f);
  unsigned int mantissa = ((h & 0x3ff) << 13);

  if (exponent == 0x1f) {  
    mantissa = (mantissa
                ? (sign = 0, 0x7fffff)
                : 0);
    exponent = 0xff;
  } else if (!exponent) {  
    if (mantissa) {
      unsigned int msb;
      exponent = 0x71;
      do {
        msb = (mantissa & 0x400000);
        mantissa <<= 1;  
        --exponent;
      } while (!msb);
      mantissa &= 0x7fffff;  
    }
  } else {
    exponent += 0x70;
  }

  return __int_as_float ((sign << 31) | (exponent << 23) | mantissa);
}

static float __fadd_rz(float a, float b)
{
  return __internal_fadd_kernel(a, b, cudaRoundZero);
}

static float __fmul_rz(float a, float b)
{
  return __internal_fmul_kernel(a, b, cudaRoundZero);
}

static float __fadd_rn(float a, float b)
{
  return __internal_fadd_kernel(a, b, cudaRoundNearest);
}

static float __fmul_rn(float a, float b)
{
  return __internal_fmul_kernel(a, b, cudaRoundNearest);
}

static void __brkpt(int c)
{
  
}






#line 4317 "c:\\cuda\\include\\device_functions.h"

extern int __stdcall __cudaSynchronizeThreads(void**, void*);









#line 4329 "c:\\cuda\\include\\device_functions.h"




#line 4334 "c:\\cuda\\include\\device_functions.h"

#line 4336 "c:\\cuda\\include\\device_functions.h"

static void __prof_trigger(int a)
{
}

static void __threadfence(void)
{
  (void)__cudaSynchronizeThreads((void**)0, (void*)0);
}

static void __threadfence_block(void)
{
  (void)__cudaSynchronizeThreads((void**)0, (void*)0);
}








#line 4359 "c:\\cuda\\include\\device_functions.h"

static void __trap(void)
{
  __debugbreak();
}

#line 4366 "c:\\cuda\\include\\device_functions.h"

#line 4368 "c:\\cuda\\include\\device_functions.h"







static float __fdividef(float a, float b)
{


#line 4380 "c:\\cuda\\include\\device_functions.h"
  volatile float aa = a;
  volatile float bb = b;
  
  if (__cuda_fabsf(bb) > 8.507059173e37f) {
    if (__cuda_fabsf(aa) <= 3.402823466e38f) {
      return ((aa / bb) / 3.402823466e38f) / 3.402823466e38f;
    } else {
      bb = 1.0f / bb;
      bb = bb / 3.402823466e38f;
      return aa * bb;
    }
  } else {
    return aa / bb;
  }
#line 4395 "c:\\cuda\\include\\device_functions.h"
}
#line 4397 "c:\\cuda\\include\\device_functions.h"

static float __sinf(float a)
{

  if ((__float_as_int(a) << 1) == 0xff000000) {
    return __fadd_rn (a, -a); 
  }
#line 4405 "c:\\cuda\\include\\device_functions.h"
  return sinf(a);
}

static float __cosf(float a)
{

  if ((__float_as_int(a) << 1) == 0xff000000) {
    return __fadd_rn (a, -a); 
  }
#line 4415 "c:\\cuda\\include\\device_functions.h"
  return cosf(a);
}

static float __log2f(float a)
{
  return log2f(a);
}







static float __internal_accurate_fdividef(float a, float b)
{
  return a / b;
}

static float __tanf(float a)
{


#line 4439 "c:\\cuda\\include\\device_functions.h"
  return __fdividef (__sinf(a), __cosf(a));
#line 4441 "c:\\cuda\\include\\device_functions.h"
}

static void __sincosf(float a, float *sptr, float *cptr)
{


#line 4448 "c:\\cuda\\include\\device_functions.h"
  *sptr = __sinf(a);
  *cptr = __cosf(a);
#line 4451 "c:\\cuda\\include\\device_functions.h"
}

static float __expf(float a)
{


#line 4458 "c:\\cuda\\include\\device_functions.h"
  return __cuda_exp2f(a * 1.442695041f);
#line 4460 "c:\\cuda\\include\\device_functions.h"
}

static float __exp10f(float a)
{


#line 4467 "c:\\cuda\\include\\device_functions.h"
  return __cuda_exp2f(a * 3.321928094f);
#line 4469 "c:\\cuda\\include\\device_functions.h"
}

static float __log10f(float a)
{


#line 4476 "c:\\cuda\\include\\device_functions.h"
  return 0.301029996f * __log2f(a);
#line 4478 "c:\\cuda\\include\\device_functions.h"
}

static float __logf(float a)
{


#line 4485 "c:\\cuda\\include\\device_functions.h"
  return 0.693147181f * __log2f(a);
#line 4487 "c:\\cuda\\include\\device_functions.h"
}

static float __powf(float a, float b)
{


#line 4494 "c:\\cuda\\include\\device_functions.h"
  return __cuda_exp2f(b * __log2f(a));
#line 4496 "c:\\cuda\\include\\device_functions.h"
}

static float fdividef(float a, float b)
{


#line 4503 "c:\\cuda\\include\\device_functions.h"

#line 4505 "c:\\cuda\\include\\device_functions.h"
  return __internal_accurate_fdividef(a, b);
#line 4507 "c:\\cuda\\include\\device_functions.h"
}

static int __clz(int a)
{
  return (a)?(158-(__float_as_int(__uint2float_rz((unsigned int)a))>>23)):32;
}

static int __clzll(long long int a)
{
  int ahi = ((int)((unsigned long long)a >> 32));
  int alo = ((int)((unsigned long long)a & 0xffffffffULL));
  int res;
  if (ahi) {
    res = 0;
  } else {
    res = 32;
    ahi = alo;
  }
  res = res + __clz(ahi);
  return res;
}

static int __popc(unsigned int a)
{
  a = a - ((a >> 1) & 0x55555555);
  a = (a & 0x33333333) + ((a >> 2) & 0x33333333);
  a = (a + (a >> 4)) & 0x0f0f0f0f;
  a = ((__umul24(a, 0x808080) << 1) + a) >> 24;
  return a;
}

static int __popcll(unsigned long long int a)
{
  unsigned int ahi = ((unsigned int)(a >> 32));
  unsigned int alo = ((unsigned int)(a & 0xffffffffULL));
  alo = alo - ((alo >> 1) & 0x55555555);
  alo = (alo & 0x33333333) + ((alo >> 2) & 0x33333333);
  ahi = ahi - ((ahi >> 1) & 0x55555555);
  ahi = (ahi & 0x33333333) + ((ahi >> 2) & 0x33333333);
  alo = alo + ahi;
  alo = (alo & 0x0f0f0f0f) + ((alo >> 4) & 0x0f0f0f0f);
  alo = ((__umul24(alo, 0x808080) << 1) + alo) >> 24;
  return alo;
}

static unsigned int __brev(unsigned int a)
{
  a = ((a >>  1) & 0x55555555) + ((a & 0x55555555) <<  1);
  a = ((a >>  2) & 0x33333333) + ((a & 0x33333333) <<  2);
  a = ((a >>  4) & 0x0F0F0F0F) + ((a & 0x0F0F0F0F) <<  4);
  a = ((a >>  8) & 0x00FF00FF) + ((a & 0x00FF00FF) <<  8);
  a = ( a >> 16              ) + ( a               << 16);
  return a;
}

static unsigned long long int __brevll(unsigned long long int a)
{
  unsigned int hi = (unsigned int)(a >> 32);
  unsigned int lo = (unsigned int)(a & 0xffffffffULL);
  unsigned int t;
  t  = __brev(lo);
  lo = __brev(hi);
  return ((unsigned long long int)t << 32) + (unsigned long long int)lo;
}

static int __ffs(int a)
{
  return 32 - __clz (a & -a);
}

static int __ffsll(long long int a)
{
  return 64 - __clzll (a & -a);
}





#line 4587 "c:\\cuda\\include\\device_functions.h"
































#line 4620 "c:\\cuda\\include\\device_functions.h"



static double fdivide(double a, double b)
{
  return a / b;
}



static int __internal_double2int(double a, enum cudaRoundMode rndMode);
static unsigned int __internal_double2uint(double a, enum cudaRoundMode rndMode);
static long long int __internal_double2ll(double a, enum cudaRoundMode rndMode);
static unsigned long long int __internal_double2ull(double a, enum cudaRoundMode rndMode);

static int __double2int_rz(double a)
{
  return __internal_double2int(a, cudaRoundZero);
}

static unsigned int __double2uint_rz(double a)
{
  return __internal_double2uint(a, cudaRoundZero);
}

static long long int __double2ll_rz(double a)
{
  return __internal_double2ll(a, cudaRoundZero);
}

static unsigned long long int __double2ull_rz(double a)
{
  return __internal_double2ull(a, cudaRoundZero);
}

#line 4656 "c:\\cuda\\include\\device_functions.h"

#line 4658 "c:\\cuda\\include\\device_functions.h"

#line 4660 "c:\\cuda\\include\\device_functions.h"







#line 1 "c:\\cuda\\include\\sm_11_atomic_functions.h"















































































































































































































#line 209 "c:\\cuda\\include\\sm_11_atomic_functions.h"

#line 1 "c:\\cuda\\include\\crt/func_macro.h"
































































































#line 98 "c:\\cuda\\include\\crt/func_macro.h"
#line 211 "c:\\cuda\\include\\sm_11_atomic_functions.h"












































#line 256 "c:\\cuda\\include\\sm_11_atomic_functions.h"

extern void __stdcall __cudaMutexOperation(int lock);






static int __iAtomicAdd(int *address, int val)
{
  int old;

  __cudaMutexOperation(1); old = *address; *address = old + val; __cudaMutexOperation(0);
#line 272 "c:\\cuda\\include\\sm_11_atomic_functions.h"
  return old;
}

static unsigned int __uAtomicAdd(unsigned int *address, unsigned int val)
{
  unsigned int old;

  __cudaMutexOperation(1); old = *address; *address = old + val; __cudaMutexOperation(0);
#line 283 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static int __iAtomicExch(int *address, int val)
{
  int old;

  __cudaMutexOperation(1); old = *address; *address = val; __cudaMutexOperation(0);
#line 295 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static unsigned int __uAtomicExch(unsigned int *address, unsigned int val)
{
  unsigned int old;

  __cudaMutexOperation(1); old = *address; *address = val; __cudaMutexOperation(0);
#line 307 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static float __fAtomicExch(float *address, float val)
{
  float old;

  __cudaMutexOperation(1); old = *address; *address = val; __cudaMutexOperation(0);
#line 319 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static int __iAtomicMin(int *address, int val)
{
  int old;

  __cudaMutexOperation(1); old = *address; *address = old < val ? old : val; __cudaMutexOperation(0);
#line 331 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static unsigned int __uAtomicMin(unsigned int *address, unsigned int val)
{
  unsigned int old;

  __cudaMutexOperation(1); old = *address; *address = old < val ? old : val; __cudaMutexOperation(0);
#line 343 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static int __iAtomicMax(int *address, int val)
{
  int old;

  __cudaMutexOperation(1); old = *address; *address = old > val ? old : val; __cudaMutexOperation(0);
#line 355 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static unsigned int __uAtomicMax(unsigned int *address, unsigned int val)
{
  unsigned int old;

  __cudaMutexOperation(1); old = *address; *address = old > val ? old : val; __cudaMutexOperation(0);
#line 367 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static unsigned int __uAtomicInc(unsigned int *address, unsigned int val)
{
  unsigned int old;

  __cudaMutexOperation(1); old = *address; *address = (old >= val) ? 0 : old + 1; __cudaMutexOperation(0);
#line 379 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static unsigned int __uAtomicDec(unsigned int *address, unsigned int val)
{
  unsigned int old;

  __cudaMutexOperation(1); old = *address; *address = ((old == 0) | (old > val)) ? val : (old - 1); __cudaMutexOperation(0);
#line 391 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static int __iAtomicAnd(int *address, int val)
{
  int old;

  __cudaMutexOperation(1); old = *address; *address = old & val; __cudaMutexOperation(0);
#line 403 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static unsigned int __uAtomicAnd(unsigned int *address, unsigned int val)
{
  unsigned int old;

  __cudaMutexOperation(1); old = *address; *address = old & val; __cudaMutexOperation(0);
#line 415 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static int __iAtomicOr(int *address, int val)
{
  int old;

  __cudaMutexOperation(1); old = *address; *address = old | val; __cudaMutexOperation(0);
#line 427 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static unsigned int __uAtomicOr(unsigned int *address, unsigned int val)
{
  unsigned int old;

  __cudaMutexOperation(1); old = *address; *address = old | val; __cudaMutexOperation(0);
#line 439 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static int __iAtomicXor(int *address, int val)
{
  int old;

  __cudaMutexOperation(1); old = *address; *address = old ^ val; __cudaMutexOperation(0);
#line 451 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static unsigned int __uAtomicXor(unsigned int *address, unsigned int val)
{
  unsigned int old;

  __cudaMutexOperation(1); old = *address; *address = old ^ val; __cudaMutexOperation(0);
#line 463 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static int __iAtomicCAS(int *address, int compare, int val)
{
  int old;

  __cudaMutexOperation(1); old = *address; *address = old == compare ? val : old; __cudaMutexOperation(0);
#line 475 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}

static unsigned int __uAtomicCAS(unsigned int *address, unsigned int compare, unsigned int val)
{
  unsigned int old;

  __cudaMutexOperation(1); old = *address; *address = old == compare ? val : old; __cudaMutexOperation(0);
#line 487 "c:\\cuda\\include\\sm_11_atomic_functions.h"

  return old;
}



#line 494 "c:\\cuda\\include\\sm_11_atomic_functions.h"

#line 496 "c:\\cuda\\include\\sm_11_atomic_functions.h"

#line 498 "c:\\cuda\\include\\sm_11_atomic_functions.h"

#line 500 "c:\\cuda\\include\\sm_11_atomic_functions.h"
#line 4668 "c:\\cuda\\include\\device_functions.h"
#line 1 "c:\\cuda\\include\\sm_12_atomic_functions.h"




































































































#line 102 "c:\\cuda\\include\\sm_12_atomic_functions.h"

#line 1 "c:\\cuda\\include\\crt/func_macro.h"
































































































#line 98 "c:\\cuda\\include\\crt/func_macro.h"
#line 104 "c:\\cuda\\include\\sm_12_atomic_functions.h"












#line 117 "c:\\cuda\\include\\sm_12_atomic_functions.h"

extern void __stdcall __cudaMutexOperation(int lock);






static unsigned long long int __ullAtomicAdd(unsigned long long int *address, unsigned long long int val)
{
  unsigned long long int old;

  __cudaMutexOperation(1); old = *address; *address = old + val; __cudaMutexOperation(0);
#line 133 "c:\\cuda\\include\\sm_12_atomic_functions.h"
  return old;
}

static unsigned long long int __ullAtomicExch(unsigned long long int *address, unsigned long long int val)
{
  unsigned long long int old;

  __cudaMutexOperation(1); old = *address; *address = val; __cudaMutexOperation(0);
#line 144 "c:\\cuda\\include\\sm_12_atomic_functions.h"
  return old;
}

static unsigned long long int __ullAtomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val)
{
  unsigned long long int old;

  __cudaMutexOperation(1); old = *address; *address = old == compare ? val : old; __cudaMutexOperation(0);
#line 155 "c:\\cuda\\include\\sm_12_atomic_functions.h"
  return old;
}



#line 161 "c:\\cuda\\include\\sm_12_atomic_functions.h"

static int __any(int cond)
{
  return cond;
}

static int __all(int cond)
{
  return cond;
}

#line 173 "c:\\cuda\\include\\sm_12_atomic_functions.h"

#line 175 "c:\\cuda\\include\\sm_12_atomic_functions.h"

#line 177 "c:\\cuda\\include\\sm_12_atomic_functions.h"
#line 4669 "c:\\cuda\\include\\device_functions.h"
#line 1 "c:\\cuda\\include\\sm_13_double_functions.h"





























































































































































































































































#line 255 "c:\\cuda\\include\\sm_13_double_functions.h"

#line 1 "c:\\cuda\\include\\crt/func_macro.h"
































































































#line 98 "c:\\cuda\\include\\crt/func_macro.h"
#line 257 "c:\\cuda\\include\\sm_13_double_functions.h"








#line 1 "c:\\cuda\\include\\common_types.h"


































































#line 68 "c:\\cuda\\include\\common_types.h"
#line 266 "c:\\cuda\\include\\sm_13_double_functions.h"

static double __longlong_as_double(long long int a)
{
  volatile union __cudart_DoubleLonglongCvt u;
  u.i = a;
  return u.d;
}

static long long int __double_as_longlong(double a)
{
  volatile union __cudart_DoubleLonglongCvt u;
  u.d = a;
  return u.i;
}

static float __internal_double2float_kernel(double a)
{
  volatile union __cudart_DoubleUlonglongCvt xx;
  volatile union __cudart_FloatUintCvt res;
  
  int shift;
  xx.d = a;
  if (xx.i == 0) return 0.0f;
  res.i = (((unsigned int) (xx.i >> 32)) & 0x80000000);
  if ((xx.i & 0x7ff0000000000000ULL) == 0x7ff0000000000000ULL) {
    if ((xx.i & 0x7fffffffffffffffULL) > 0x7ff0000000000000ULL) {
      
      res.i = ((unsigned int)((xx.i >> 32) & 0x80000000) |
               (255U << 23) | 0x00400000 |
               (unsigned int)((xx.i >> (53 - 24)) & 0x007fffff));
    } else {
      
      res.i |= 0x7f800000;
    }
    return res.f;
  }
  shift = ((int) ((xx.i >> 52) & 0x7ff)) - 1023;
  
  xx.i = (xx.i & 0x000fffffffffffffULL);
  if (shift >= 128) {
    res.i |= 0x7f7fffff;
    return res.f;
  }
  if (shift <= -127) {
    if (shift < -180) {
      
      xx.i = 0;
    } else {
      xx.i |= 0x0010000000000000ULL;
      xx.i >>= -126 - shift;
    }
  } else {
    res.i |= (unsigned int) (127 + shift) << 23;
  }
  res.i |= ((unsigned int) (xx.i >> 29)) & 0x007fffff;
  xx.i &= 0x1fffffff;
  return res.f;
}

static double __internal_ll2double_kernel(long long int a, enum cudaRoundMode rndMode)
{
  volatile union __cudart_DoubleUlonglongCvt res;
  int shift;
  unsigned int t;
  res.i = a;
  if (a == 0) return res.d;
  if (a < 0) res.i = (unsigned long long int)-a;
  shift = __internal_normalize64((unsigned long long int*)&res.i);
  t = ((unsigned int) res.i) << 21;
  res.i >>= 11;
  res.i += ((unsigned long long int)(1023 + 62 - shift)) << 52;
  if (a < 0) res.i |= 0x8000000000000000ULL;
  if ((rndMode == cudaRoundNearest) && (t >= 0x80000000)) {
    res.i += (t == 0x80000000) ? (res.i & 1) : 1;
  }
  else if ((rndMode == cudaRoundMinInf) && t && (a < 0)) {
    res.i++;
  }
  else if ((rndMode == cudaRoundPosInf) && t && (a > 0)) {
    res.i++;
  }
  return res.d;
}

static double __internal_ull2double_kernel(unsigned long long int a, enum cudaRoundMode rndMode)
{
  volatile union __cudart_DoubleUlonglongCvt res;
  int shift;
  unsigned int t;
  res.i = a;
  if (a == 0) return res.d;
  shift = __internal_normalize64((unsigned long long int *)&res.i);
  t = ((unsigned int) res.i) << 21;
  res.i >>= 11;
  res.i += ((unsigned long long int)(1023 + 62 - shift)) << 52;
  if ((rndMode == cudaRoundNearest) && (t >= 0x80000000)) {
    res.i += (t == 0x80000000) ? (res.i & 1) : 1;
  }
  else if ((rndMode == cudaRoundPosInf) && t) {
    res.i++;
  }
  return res.d;
}

static long long int __internal_double2ll_kernel(double a, long long int max, long long int min, long long int nan, enum cudaRoundMode rndMode)
{
  volatile union __cudart_DoubleUlonglongCvt xx, res;
  unsigned long long int t = 0;
  int shift;

  xx.d = a;
  if (sizeof(a) == sizeof(double) && __cuda___isnan((double)a)) return nan; if (sizeof(a) == sizeof(float) && __cuda___isnanf((float)a)) return nan; if (a >= max) return max; if (a <= min) return min;
  shift = (int) (1023 + 62 - ((xx.i >> 52) & 0x7ff));
  res.i = ((xx.i << 11) | 0x8000000000000000ULL) >> 1;
  if (shift >= 64) { 
    t = res.i;
    res.i = 0;
  } else if (shift) {
    t = res.i << (64 - shift);
    res.i = res.i >> shift;
  }
  if ((rndMode == cudaRoundNearest) && (t >= 0x8000000000000000ULL)) {
    res.i += (t == 0x8000000000000000ULL) ? (res.i & 1) : 1;
  }
  else if ((rndMode ==  cudaRoundMinInf) && t && 
          (xx.i > 0x8000000000000000ULL)) {
    res.i++;
  }
  else if ((rndMode == cudaRoundPosInf) && t && ((long long int)xx.i > 0)) {
    res.i++;
  }
  if ((long long int)xx.i < 0) {
    res.i = (unsigned long long int)(-(long long int)res.i);
  }
  return res.i;
}

static unsigned long long int __internal_double2ull_kernel(double a, unsigned long long int max, unsigned long long int nan, enum cudaRoundMode rndMode)
{
  volatile union __cudart_DoubleUlonglongCvt xx, res;
  unsigned long long int t = 0;
  int shift;

  xx.d = a;
  if (sizeof(a) == sizeof(double) && __cuda___isnan((double)a)) return nan; if (sizeof(a) == sizeof(float) && __cuda___isnanf((float)a)) return nan; if (a >= max) return max; if (a <= 0LL) return 0LL;

  if (a == 0.0) return 0LL;
  shift = (int) (1023 + 63 - ((xx.i >> 52) & 0x7ff));
  res.i = ((xx.i << 11) | 0x8000000000000000ULL);
  if (shift >= 64) { 
    t = res.i >> (int)(shift > 64); 
    res.i = 0; 
  } else if (shift) {
    t = res.i << (64 - shift);
    res.i = res.i >> shift;
  }
  if ((rndMode == cudaRoundNearest) && (t >= 0x8000000000000000ULL)) {
    res.i += (t == 0x8000000000000000ULL) ? (res.i & 1) : 1;
  }
  else if ((rndMode == cudaRoundPosInf) && t) {
    res.i++;
  }
  return res.i;
}

static int __double2hiint(double a)
{
  volatile union __cudart_DoubleInthiloCvt cvt;
  
  cvt.d = a;
  return cvt.i[1];
}

static int __double2loint(double a)
{
  volatile union __cudart_DoubleInthiloCvt cvt;
  
  cvt.d = a;
  return cvt.i[0];
}

static double __hiloint2double(int a, int b)
{
  volatile union __cudart_DoubleInthiloCvt cvt;
  
  cvt.i[0] = b;
  cvt.i[1] = a;
  return cvt.d;
}

static float __double2float_rn(double a)
{
  return (float)a;
}

static float __double2float_rz(double a)
{
  return __internal_double2float_kernel(a);
}

static int __internal_double2int(double a, enum cudaRoundMode rndMode)
{
  return (int)__internal_double2ll_kernel(a, 2147483647LL, -2147483648LL, -2147483648LL, rndMode);
}

static int __double2int_rn(double a)
{
  return __internal_double2int(a, cudaRoundNearest);
}

static int __double2int_ru(double a)
{
  return __internal_double2int(a, cudaRoundPosInf);
}

static int __double2int_rd(double a)
{
  return __internal_double2int(a, cudaRoundMinInf);
}

static unsigned int __internal_double2uint(double a, enum cudaRoundMode rndMode)
{
  return (unsigned int)__internal_double2ull_kernel(a, 4294967295ULL, 2147483648ULL, rndMode);
}

static unsigned int __double2uint_rn(double a)
{
  return __internal_double2uint(a, cudaRoundNearest);
}

static unsigned int __double2uint_ru(double a)
{
  return __internal_double2uint(a, cudaRoundPosInf);
}

static unsigned int __double2uint_rd(double a)
{
  return __internal_double2uint(a, cudaRoundMinInf);
}

static long long int __internal_double2ll(double a, enum cudaRoundMode rndMode)
{
  return __internal_double2ll_kernel(a, 9223372036854775807LL, -9223372036854775807LL -1LL, -9223372036854775807LL -1LL, rndMode);
}

static long long int __double2ll_rn(double a)
{
  return __internal_double2ll(a, cudaRoundNearest);
}

static long long int __double2ll_ru(double a)
{
  return __internal_double2ll(a, cudaRoundPosInf);
}

static long long int __double2ll_rd(double a)
{
  return __internal_double2ll(a, cudaRoundMinInf);
}

static unsigned long long int __internal_double2ull(double a, enum cudaRoundMode rndMode)
{
  return __internal_double2ull_kernel(a, 18446744073709551615ULL, 9223372036854775808ULL, rndMode);
}

static unsigned long long int __double2ull_rn(double a)
{
  return __internal_double2ull(a, cudaRoundNearest);
}

static unsigned long long int __double2ull_ru(double a)
{
  return __internal_double2ull(a, cudaRoundPosInf);
}

static unsigned long long int __double2ull_rd(double a)
{
  return __internal_double2ull(a, cudaRoundMinInf);
}

static double __int2double_rn(int a)
{
  return (double)a;
}

static double __uint2double_rn(unsigned int a)
{
  return (double)a;
}

static double __ll2double_rn(long long int a)
{
  return (double)a;
}

static double __ll2double_rz(long long int a)
{
  return __internal_ll2double_kernel(a, cudaRoundZero);
}

static double __ll2double_rd(long long int a)
{
  return __internal_ll2double_kernel(a, cudaRoundMinInf);
}

static double __ll2double_ru(long long int a)
{
  return __internal_ll2double_kernel(a, cudaRoundPosInf);
}

static double __ull2double_rn(unsigned long long int a)
{
  return __internal_ull2double_kernel(a, cudaRoundNearest);
}

static double __ull2double_rz(unsigned long long int a)
{
  return __internal_ull2double_kernel(a, cudaRoundZero);
}

static double __ull2double_rd(unsigned long long int a)
{
  return __internal_ull2double_kernel(a, cudaRoundMinInf);
}

static double __ull2double_ru(unsigned long long int a)
{
  return __internal_ull2double_kernel(a, cudaRoundPosInf);
}

#line 597 "c:\\cuda\\include\\sm_13_double_functions.h"



#line 1 "c:\\cuda\\include\\common_types.h"


































































#line 68 "c:\\cuda\\include\\common_types.h"
#line 601 "c:\\cuda\\include\\sm_13_double_functions.h"

static double __internal_fma_kernel(double x, double y, double z, enum cudaRoundMode rndMode)
{



  struct __cudart_UintUint xx, yy, zz, ww;
  unsigned int s, t, u, prod0, prod1, prod2, prod3, expo_x, expo_y, expo_z;
  
  xx.hi = __double2hiint(x);
  xx.lo = __double2loint(x);
  yy.hi = __double2hiint(y);
  yy.lo = __double2loint(y);
  zz.hi = __double2hiint(z);
  zz.lo = __double2loint(z);

  expo_z = 0x7FF;
  t =  xx.hi >> 20;
  expo_x = expo_z & t;
  expo_x = expo_x - 1;    
  t =  yy.hi >> 20;
  expo_y = expo_z & t;
  expo_y = expo_y - 1;    
  t =  zz.hi >> 20;
  expo_z = expo_z & t;
  expo_z = expo_z - 1;    

  if (!((expo_x <= 0x7FD) &&
        (expo_y <= 0x7FD) &&
        (expo_z <= 0x7FD))) {
    
    



    if (((yy.hi << 1) | (yy.lo != 0)) > 0xffe00000) {
      yy.hi |= 0x00080000;
      return __hiloint2double(yy.hi, yy.lo);
    }
    if (((zz.hi << 1) | (zz.lo != 0)) > 0xffe00000) {
      zz.hi |= 0x00080000;
      return __hiloint2double(zz.hi, zz.lo);
    }
    if (((xx.hi << 1) | (xx.lo != 0)) > 0xffe00000) {
      xx.hi |= 0x00080000;
      return __hiloint2double(xx.hi, xx.lo);
    }
    
    










    if (((((xx.hi << 1) | xx.lo) == 0) && 
         (((yy.hi << 1) | (yy.lo != 0)) == 0xffe00000)) ||
        ((((yy.hi << 1) | yy.lo) == 0) && 
         (((xx.hi << 1) | (xx.lo != 0)) == 0xffe00000))) {
      xx.hi = 0xfff80000;
      xx.lo = 0x00000000;
      return __hiloint2double(xx.hi, xx.lo);
    }
    if (((zz.hi << 1) | (zz.lo != 0)) == 0xffe00000) {
      if ((((yy.hi << 1) | (yy.lo != 0)) == 0xffe00000) ||
          (((xx.hi << 1) | (xx.lo != 0)) == 0xffe00000)) {
        if ((int)(xx.hi ^ yy.hi ^ zz.hi) < 0) {
          xx.hi = 0xfff80000;
          xx.lo = 0x00000000;
          return __hiloint2double(xx.hi, xx.lo);
        }
      }
    }
    



    if (((xx.hi << 1) | (xx.lo != 0)) == 0xffe00000) {
      xx.hi = xx.hi ^ (yy.hi & 0x80000000);
      return __hiloint2double(xx.hi, xx.lo);
    }
    if (((yy.hi << 1) | (yy.lo != 0)) == 0xffe00000) {
      yy.hi = yy.hi ^ (xx.hi & 0x80000000);
      return __hiloint2double(yy.hi, yy.lo);
    }
    if (((zz.hi << 1) | (zz.lo != 0)) == 0xffe00000) {
      return __hiloint2double(zz.hi, zz.lo);
    }
    




    if ((zz.hi == 0x80000000) && (zz.lo == 0)) {
      if ((((xx.hi << 1) | xx.lo) == 0) ||
          (((yy.hi << 1) | yy.lo) == 0)) {
        if ((int)(xx.hi ^ yy.hi) < 0) {
          return __hiloint2double(zz.hi, zz.lo);
        }
      }
    }
    


    if ((((zz.hi << 1) | zz.lo) == 0) &&
        ((((xx.hi << 1) | xx.lo) == 0) ||
         (((yy.hi << 1) | yy.lo) == 0))) {
      if (rndMode == cudaRoundMinInf) {
        return __hiloint2double((xx.hi ^ yy.hi ^ zz.hi) & 0x80000000, zz.lo);
      } else {
        zz.hi &= 0x7fffffff;
        return __hiloint2double(zz.hi, zz.lo);
      }
    }
    
    


    if ((((xx.hi << 1) | xx.lo) == 0) ||
        (((yy.hi << 1) | yy.lo) == 0)) {
      return __hiloint2double(zz.hi, zz.lo);
    }
    
    if (expo_x == 0xffffffff) {
      expo_x++;
      t = xx.hi & 0x80000000;
      s = xx.lo >> 21;
      xx.lo = xx.lo << 11;
      xx.hi = xx.hi << 11;
      xx.hi = xx.hi | s;
      if (!xx.hi) {
        xx.hi = xx.lo;
        xx.lo = 0;
        expo_x -= 32;
      }
      while ((int)xx.hi > 0) {
        s = xx.lo >> 31;
        xx.lo = xx.lo + xx.lo;
        xx.hi = xx.hi + xx.hi;
        xx.hi = xx.hi | s;
        expo_x--;
      }
      xx.lo = (xx.lo >> 11);
      xx.lo |= (xx.hi << 21);
      xx.hi = (xx.hi >> 11) | t;
    }
    if (expo_y == 0xffffffff) {
      expo_y++;
      t = yy.hi & 0x80000000;
      s = yy.lo >> 21;
      yy.lo = yy.lo << 11;
      yy.hi = yy.hi << 11;
      yy.hi = yy.hi | s;
      if (!yy.hi) {
        yy.hi = yy.lo;
        yy.lo = 0;
        expo_y -= 32;
      }
      while ((int)yy.hi > 0) {
        s = yy.lo >> 31;
        yy.lo = yy.lo + yy.lo;
        yy.hi = yy.hi + yy.hi;
        yy.hi = yy.hi | s;
        expo_y--;
      }
      yy.lo = (yy.lo >> 11);
      yy.lo |= (yy.hi << 21);
      yy.hi = (yy.hi >> 11) | t;
    }
    if (expo_z == 0xffffffff) {
      expo_z++;
      t = zz.hi & 0x80000000;
      s = zz.lo >> 21;
      zz.lo = zz.lo << 11;
      zz.hi = zz.hi << 11;
      zz.hi = zz.hi | s;
      if (!zz.hi) {
        zz.hi = zz.lo;
        zz.lo = 0;
        expo_z -= 32;
      }
      while ((int)zz.hi > 0) {
        s = zz.lo >> 31;
        zz.lo = zz.lo + zz.lo;
        zz.hi = zz.hi + zz.hi;
        zz.hi = zz.hi | s;
        expo_z--;
      }
      zz.lo = (zz.lo >> 11);
      zz.lo |= (zz.hi << 21);
      zz.hi = (zz.hi >> 11) | t;
    }
  }
  
  expo_x = expo_x + expo_y;
  expo_y = xx.hi ^ yy.hi;
  t = xx.lo >> 21;
  xx.lo = xx.lo << 11;
  xx.hi = xx.hi << 11;
  xx.hi = xx.hi | t;
  yy.hi = yy.hi & 0x000fffff;
  xx.hi = xx.hi | 0x80000000; 
  yy.hi = yy.hi | 0x00100000; 

  prod0 = xx.lo * yy.lo;
  prod1 = __umulhi (xx.lo, yy.lo);
  prod2 = xx.hi * yy.lo;
  prod3 = xx.lo * yy.hi;
  prod1 += prod2;
  t = prod1 < prod2;
  prod1 += prod3;
  t += prod1 < prod3;
  prod2 = __umulhi (xx.hi, yy.lo);
  prod3 = __umulhi (xx.lo, yy.hi);
  prod2 += prod3;
  s = prod2 < prod3;
  prod3 = xx.hi * yy.hi;
  prod2 += prod3;
  s += prod2 < prod3;
  prod2 += t;
  s += prod2 < t;
  prod3 = __umulhi (xx.hi, yy.hi) + s;
  
  yy.lo = prod0;                 
  yy.hi = prod1;                 
  xx.lo = prod2;                 
  xx.hi = prod3;                 
  expo_x = expo_x - (1023 - 2);  
  expo_y = expo_y & 0x80000000;  

  if (xx.hi < 0x00100000) {
    s = xx.lo >> 31;
    s = (xx.hi << 1) + s;
    xx.hi = s;
    s = yy.hi >> 31;
    s = (xx.lo << 1) + s;
    xx.lo = s;
    s = yy.lo >> 31;
    s = (yy.hi << 1) + s;
    yy.hi = s;
    s = yy.lo << 1;
    yy.lo = s;
    expo_x--;
  }

  t = 0;
  if (((zz.hi << 1) | zz.lo) != 0) { 
    
    s = zz.hi & 0x80000000;
    
    zz.hi &= 0x000fffff;
    zz.hi |= 0x00100000;
    ww.hi = 0;
    ww.lo = 0;
    
    
    if ((int)expo_z > (int)expo_x) {
      t = expo_z;
      expo_z = expo_x;
      expo_x = t;
      t = zz.hi;
      zz.hi = xx.hi;
      xx.hi = t;
      t = zz.lo;
      zz.lo = xx.lo;
      xx.lo = t;
      t = ww.hi;
      ww.hi = yy.hi;
      yy.hi = t;
      t = ww.lo;
      ww.lo = yy.lo;
      yy.lo = t;
      t = expo_y;
      expo_y = s;
      s = t;
    }
    
    
    
    expo_z = expo_x - expo_z;
    u = expo_y ^ s;
    if (expo_z <= 107) {
      
      t = 0;
      while (expo_z >= 32) {
        t     = ww.lo | (t != 0);
        ww.lo = ww.hi;
        ww.hi = zz.lo;
        zz.lo = zz.hi;
        zz.hi = 0;
        expo_z -= 32;
      }
      if (expo_z) {
        t     = (t     >> expo_z) | (ww.lo << (32 - expo_z)) | 
                ((t << (32 - expo_z)) != 0);
        ww.lo = (ww.lo >> expo_z) | (ww.hi << (32 - expo_z));
        ww.hi = (ww.hi >> expo_z) | (zz.lo << (32 - expo_z));
        zz.lo = (zz.lo >> expo_z) | (zz.hi << (32 - expo_z));
        zz.hi = (zz.hi >> expo_z);
      }
    } else {
      t = 1;
      ww.lo = 0;
      ww.hi = 0;
      zz.lo = 0;
      zz.hi = 0;
    }
    if ((int)u < 0) {
      
      t = (unsigned)(-(int)t);
      s = (t != 0);
      u = yy.lo - s;
      s = u > yy.lo;
      yy.lo = u - ww.lo;
      s += yy.lo > u;
      u = yy.hi - s;
      s = u > yy.hi;
      yy.hi = u - ww.hi;
      s += yy.hi > u;
      u = xx.lo - s;
      s = u > xx.lo;
      xx.lo = u - zz.lo;
      s += xx.lo > u;
      xx.hi = (xx.hi - zz.hi) - s;
      if (!(xx.hi | xx.lo | yy.hi | yy.lo | t)) {
        
        if (rndMode == cudaRoundMinInf) {
          return __hiloint2double(0x80000000, xx.lo);
        } else {
          return __hiloint2double(xx.hi, xx.lo);
        }
      }
      if ((int)xx.hi < 0) {
        


        t = ~t;
        yy.lo = ~yy.lo;
        yy.hi = ~yy.hi;
        xx.lo = ~xx.lo;
        xx.hi = ~xx.hi;
        if (++t == 0) {
          if (++yy.lo == 0) {
            if (++yy.hi == 0) {
              if (++xx.lo == 0) {
              ++xx.hi;
              }
            }
          }
        }
        expo_y ^= 0x80000000;
      }
        
      
      while (!(xx.hi & 0x00100000)) {
        xx.hi = (xx.hi << 1) | (xx.lo >> 31);
        xx.lo = (xx.lo << 1) | (yy.hi >> 31);
        yy.hi = (yy.hi << 1) | (yy.lo >> 31);
        yy.lo = (yy.lo << 1);
        expo_x--;
      }
    } else {
      
      yy.lo = yy.lo + ww.lo;
      s = yy.lo < ww.lo;
      yy.hi = yy.hi + s;
      u = yy.hi < s;
      yy.hi = yy.hi + ww.hi;
      u += yy.hi < ww.hi;
      xx.lo = xx.lo + u;
      s = xx.lo < u;
      xx.lo = xx.lo + zz.lo;
      s += xx.lo < zz.lo;
      xx.hi = xx.hi + zz.hi + s;
      if (xx.hi & 0x00200000) {
        t = t | (yy.lo << 31);
        yy.lo = (yy.lo >> 1) | (yy.hi << 31);
        yy.hi = (yy.hi >> 1) | (xx.lo << 31);
        xx.lo = (xx.lo >> 1) | (xx.hi << 31);
        xx.hi = ((xx.hi & 0x80000000) | (xx.hi >> 1)) & ~0x40000000;
        expo_x++;
      }
    }
  }
  t = yy.lo | (t != 0);
  t = yy.hi | (t != 0);
        
  xx.hi |= expo_y; 
  if (expo_x <= 0x7FD) {
    
    xx.hi = xx.hi & ~0x00100000; 
    s = xx.lo & 1; 
    u = xx.lo;
    if (rndMode == cudaRoundNearest) {
      xx.lo += (t == 0x80000000) ? s : (t >> 31);
    } else if (((rndMode == cudaRoundPosInf) && t && (!expo_y)) ||
               ((rndMode == cudaRoundMinInf) && t && expo_y)) {
      xx.lo += 1;
    }
    xx.hi += (u > xx.lo);
    xx.hi += ((expo_x + 1) << 20);
    return __hiloint2double(xx.hi, xx.lo);
  } else if ((int)expo_x >= 2046) {      
    
    if ((rndMode == cudaRoundNearest) || 
        ((rndMode == cudaRoundPosInf) && (!expo_y)) ||
        ((rndMode == cudaRoundMinInf) && expo_y)) {
      xx.hi = (xx.hi & 0x80000000) | 0x7ff00000;
      xx.lo = 0;
    } else {
      xx.hi = (xx.hi & 0x80000000) | 0x7fefffff;
      xx.lo = 0xffffffff;
    }
    return __hiloint2double(xx.hi, xx.lo);
  }
  
  expo_x = (unsigned)(-(int)expo_x);
  if (expo_x > 54) {
    
    if (((rndMode == cudaRoundPosInf) && (!expo_y)) ||
        ((rndMode == cudaRoundMinInf) && expo_y)) {
      return __hiloint2double(xx.hi & 0x80000000, 1);
    } else {
      return __hiloint2double(xx.hi & 0x80000000, 0);
    }
  }  
  yy.hi = xx.hi &  0x80000000;   
  xx.hi = xx.hi & ~0xffe00000;
  if (expo_x >= 32) {
    t = xx.lo | (t != 0);
    xx.lo = xx.hi;
    xx.hi = 0;
    expo_x -= 32;
  }
  if (expo_x) {
    t     = (t     >> expo_x) | (xx.lo << (32 - expo_x)) | (t != 0);
    xx.lo = (xx.lo >> expo_x) | (xx.hi << (32 - expo_x));
    xx.hi = (xx.hi >> expo_x);
  }
  expo_x = xx.lo & 1; 
  u = xx.lo;
  if (rndMode == cudaRoundNearest) {
    xx.lo += (t == 0x80000000) ? expo_x : (t >> 31);
  } else if (((rndMode == cudaRoundPosInf) && t && (!expo_y)) ||
             ((rndMode == cudaRoundMinInf) && t && expo_y)) {
    xx.lo += 1;
  }
  xx.hi += (u > xx.lo);
  xx.hi |= yy.hi;
  return __hiloint2double(xx.hi, xx.lo);
}

static double __fma_rn(double x, double y, double z)
{
  return __internal_fma_kernel(x, y, z, cudaRoundNearest);
}

static double __fma_rd(double x, double y, double z)
{
  return __internal_fma_kernel(x, y, z, cudaRoundMinInf);
}

static double __fma_ru(double x, double y, double z)
{
  return __internal_fma_kernel(x, y, z, cudaRoundPosInf);
}

static double __fma_rz(double x, double y, double z)
{
  return __internal_fma_kernel(x, y, z, cudaRoundZero);
}

static double __dadd_rz(double a, double b)
{
  return __fma_rz(a, 1.0, b); 
}

static double __dadd_ru(double a, double b)
{
  return __fma_ru(a, 1.0, b); 
}

static double __dadd_rd(double a, double b)
{
  return __fma_rd(a, 1.0, b); 
}

static double __dmul_rz(double a, double b)
{
  return __fma_rz(a, b, __longlong_as_double(0x8000000000000000ULL)); 
}

static double __dmul_ru(double a, double b)
{
  return __fma_ru(a, b, __longlong_as_double(0x8000000000000000ULL)); 
}

static double __dmul_rd(double a, double b)
{
  return __fma_rd(a, b, 0.0); 
}

static double __dadd_rn(double a, double b)
{
  return __fma_rn(a, 1.0, b); 
}

static double __dmul_rn(double a, double b)
{
  return __fma_rn(a, b, __longlong_as_double(0x8000000000000000ULL)); 
}

#line 1118 "c:\\cuda\\include\\sm_13_double_functions.h"







#line 1126 "c:\\cuda\\include\\sm_13_double_functions.h"

#line 1128 "c:\\cuda\\include\\sm_13_double_functions.h"

#line 4670 "c:\\cuda\\include\\device_functions.h"
#line 1 "c:\\cuda\\include\\texture_fetch_functions.h"


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1876 "c:\\cuda\\include\\texture_fetch_functions.h"

#line 1 "c:\\cuda\\include\\host_defines.h"




































































































































#line 134 "c:\\cuda\\include\\host_defines.h"
#line 1878 "c:\\cuda\\include\\texture_fetch_functions.h"
#line 1 "c:\\cuda\\include\\crt/func_macro.h"
































































































#line 98 "c:\\cuda\\include\\crt/func_macro.h"
#line 1879 "c:\\cuda\\include\\texture_fetch_functions.h"





























#line 1909 "c:\\cuda\\include\\texture_fetch_functions.h"

extern void __stdcall __cudaTextureFetch(const void *tex, void *index, int integer, void *val);

static int4 __itexfetchi(const void *tex, int4 index)
{
  int4 val;

  __cudaTextureFetch(tex, (void*)&index, 1, (void*)&val);

  return val;
}

static uint4 __utexfetchi(const void *tex, int4 index)
{
  uint4 val;

  __cudaTextureFetch(tex, (void*)&index, 1, (void*)&val);

  return val;
}

static float4 __ftexfetchi(const void *tex, int4 index)
{
  float4 val;

  __cudaTextureFetch(tex, (void*)&index, 1, (void*)&val);

  return val;
}

static int4 __itexfetch(const void *tex, float4 index, int dim)
{
  int4 val;

  __cudaTextureFetch(tex, (void*)&index, 0, (void*)&val);

  return val;
}

static uint4 __utexfetch(const void *tex, float4 index, int dim)
{
  uint4 val;

  __cudaTextureFetch(tex, (void*)&index, 0, (void*)&val);

  return val;
}

static float4 __ftexfetch(const void *tex, float4 index, int dim)
{
  float4 val;

  __cudaTextureFetch(tex, (void*)&index, 0, (void*)&val);

  return val;
}

#line 1967 "c:\\cuda\\include\\texture_fetch_functions.h"

#line 1969 "c:\\cuda\\include\\texture_fetch_functions.h"

#line 1971 "c:\\cuda\\include\\texture_fetch_functions.h"

#line 4671 "c:\\cuda\\include\\device_functions.h"

#line 4673 "c:\\cuda\\include\\device_functions.h"

#line 997 "c:\\cuda\\include\\math_functions.h"
#line 1 "c:\\cuda\\include\\math_constants.h"











































































































































#line 141 "c:\\cuda\\include\\math_constants.h"
#line 998 "c:\\cuda\\include\\math_functions.h"

static int __cuda___signbitf(float a)
{
  return (int)((unsigned int)__float_as_int(a) >> 31);
}




static float __cuda_copysignf(float a, float b)
{
  return __int_as_float((__float_as_int(b) &  0x80000000) | 
                        (__float_as_int(a) & ~0x80000000));
}











static int min(int a, int b)
{
  return a < b ? a : b;
}

static unsigned int umin(unsigned int a, unsigned int b)
{
  return a < b ? a : b;
}

static long long int llmin(long long int a, long long int b)
{
  return a < b ? a : b;
}

static unsigned long long int ullmin(unsigned long long int a, unsigned long long int b)
{
  return a < b ? a : b;
}

static int max(int a, int b)
{
  return a > b ? a : b;
}

static unsigned int umax(unsigned int a, unsigned int b)
{
  return a > b ? a : b;
}

static long long int llmax(long long int a, long long int b)
{
  return a > b ? a : b;
}

static unsigned long long int ullmax(unsigned long long int a, unsigned long long int b)
{
  return a > b ? a : b;
}







static double fmax(double a, double b)
{
  return a > b ? a : b;
}

static double fmin(double a, double b)
{
  return a < b ? a : b;
}

static float fmaxf(float a, float b)
{
  return (float)fmax((double)a, (double)b);
}

static float fminf(float a, float b)
{
  return (float)fmin((double)a, (double)b);
}

static int __signbit(double a)
{
  volatile union {
    double               d;
    signed long long int l;
  } cvt;

  cvt.d = a;

  return cvt.l < 0ll;
}

static double copysign(double a, double b)
{
  volatile union {
    double                 d;
    unsigned long long int l;
  } cvta, cvtb;

  cvta.d = a;
  cvtb.d = b;
  cvta.l = (cvta.l & 0x7fffffffffffffffULL) | (cvtb.l & 0x8000000000000000ULL);

  return cvta.d;
}

static int __signbitf(float a)
{
  return __cuda___signbitf(a);
}

static float copysignf(float a, float b)
{
  return __cuda_copysignf(a, b);
}



#line 1128 "c:\\cuda\\include\\math_functions.h"







static float __internal_nearbyintf(float a)
{
  float fa = fabsf(a);

  if (fa >= 8388608.0f) {
    return a;
  } else {
    volatile float u = 8388608.0f + fa;

    u = u - 8388608.0f;
    return copysignf(u, a);
  }
}

static float __internal_fminf(float a, float b)
{
  volatile union {
    float        f;
    unsigned int i;
  } cvta, cvtb;
  int nana, nanb;

  cvta.f = a;
  cvtb.f = b;
  nana = ((cvta.i << 1) > 0xff000000);
  nanb = ((cvtb.i << 1) > 0xff000000);
  if (nana && nanb) return a + b;
  if (nana) return b;
  if (nanb) return a;
  if ((cvta.i | cvtb.i) == 0x80000000) {
    return __int_as_float(0x80000000);
  }
  return a < b ? a : b;
}

static float __internal_fmaxf(float a, float b)
{
  volatile union {
    float        f;
    unsigned int i;
  } cvta, cvtb;
  int nana, nanb;

  cvta.f = a;
  cvtb.f = b;
  nana = ((cvta.i << 1) > 0xff000000);
  nanb = ((cvtb.i << 1) > 0xff000000);
  if (nana && nanb) return a + b;
  if (nana) return b;
  if (nanb) return a;
  if ((cvta.f == 0.0f) && (cvtb.f == 0.0f)) {
    cvta.i &= cvtb.i;
    return cvta.f;
  }
  return a > b ? a : b;
}





static double trunc(double a)
{
  return a < 0.0 ? ceil(a) : floor(a);
}

static double nearbyint(double a)
{
  double fa = fabs(a);
  if (fa >= 4503599627370496.0) {
    return a;
  } else {
    double u = 4503599627370496.0 + fa;
    u = u - 4503599627370496.0;
    return copysign(u, a);
  }
}

static float truncf(float a)
{
  return (float)trunc((double)a);
}

static float nearbyintf(float a)
{
  return __internal_nearbyintf(a);
}



#line 1226 "c:\\cuda\\include\\math_functions.h"

#line 1228 "c:\\cuda\\include\\math_functions.h"







static long int __cuda_labs(long int a)
{
  return labs(a);
}

static float __cuda_ceilf(float a)
{
  return ceilf(a);
}

static float __cuda_floorf(float a)
{
  return floorf(a);
}

static float __cuda_sqrtf(float a)
{
  return sqrtf(a);
}

static float __cuda_rsqrtf(float a)
{
  return rsqrtf(a);
}

static float __cuda_truncf(float a)
{
  return truncf(a);
}

static int __cuda_max(int a, int b)
{
  return max(a, b);
}

static int __cuda_min(int a, int b)
{
  return min(a, b);
}

static unsigned int __cuda_umax(unsigned int a, unsigned int b)
{
  return umax(a, b);
}

static unsigned int __cuda_umin(unsigned int a, unsigned int b)
{
  return umin(a, b);
}

static long long int __cuda_llmax(long long int a, long long int b)
{
  return llmax(a, b);
}

static long long int __cuda_llmin(long long int a, long long int b)
{
  return llmin(a, b);
}

static unsigned long long int __cuda_ullmax(unsigned long long int a, unsigned long long int b)
{
  return ullmax(a, b);
}

static unsigned long long int __cuda_ullmin(unsigned long long int a, unsigned long long int b)
{
  return ullmin(a, b);
}

static long long int __cuda_llrintf(float a)
{


#line 1310 "c:\\cuda\\include\\math_functions.h"
  return __float2ll_rn(a);
#line 1312 "c:\\cuda\\include\\math_functions.h"
}

static long int __cuda_lrintf(float a)
{


#line 1319 "c:\\cuda\\include\\math_functions.h"


#line 1322 "c:\\cuda\\include\\math_functions.h"
  return (long int)__float2int_rn(a);
#line 1324 "c:\\cuda\\include\\math_functions.h"
#line 1325 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_nearbyintf(float a)
{


#line 1332 "c:\\cuda\\include\\math_functions.h"

#line 1334 "c:\\cuda\\include\\math_functions.h"
  return __internal_nearbyintf(a);
#line 1336 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_fmaxf(float a, float b)
{


#line 1343 "c:\\cuda\\include\\math_functions.h"

#line 1345 "c:\\cuda\\include\\math_functions.h"
  return __internal_fmaxf(a, b);
#line 1347 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_fminf(float a, float b)
{


#line 1354 "c:\\cuda\\include\\math_functions.h"

#line 1356 "c:\\cuda\\include\\math_functions.h"
  return __internal_fminf(a, b);
#line 1358 "c:\\cuda\\include\\math_functions.h"
}






static int __cuda___finitef(float a)
{
  return __cuda_fabsf(a) < __int_as_float(0x7f800000);
}








#line 1378 "c:\\cuda\\include\\math_functions.h"

static int __cuda___isinff(float a)
{
  return __cuda_fabsf(a) == __int_as_float(0x7f800000);
}

static int __cuda___isnanf(float a)
{
  return !(__cuda_fabsf(a) <= __int_as_float(0x7f800000));
}

static float __cuda_nextafterf(float a, float b)
{
  unsigned int ia;
  unsigned int ib;
  ia = __float_as_int(a);
  ib = __float_as_int(b);



#line 1399 "c:\\cuda\\include\\math_functions.h"
  if (__cuda___isnanf(a) || __cuda___isnanf(b)) return a + b; 
  if (__int_as_float (ia | ib) == 0.0f) return __int_as_float(ib);




#line 1406 "c:\\cuda\\include\\math_functions.h"
  if (__int_as_float(ia) == 0.0f) {
    return __cuda_copysignf(__int_as_float(0x00000001), b); 
  }
#line 1410 "c:\\cuda\\include\\math_functions.h"
  if ((a < b) && (a < 0.0f)) ia--;
  if ((a < b) && (a > 0.0f)) ia++;
  if ((a > b) && (a < 0.0f)) ia++;
  if ((a > b) && (a > 0.0f)) ia--;
  a = __int_as_float(ia);




#line 1420 "c:\\cuda\\include\\math_functions.h"
  return a;
}

static float __cuda_nanf(const char *tagp)
{
  
  return __int_as_float(0x7fffffff);
}

static float __internal_fmad(float a, float b, float c)
{

  return __fmaf_rn (a, b, c);


#line 1436 "c:\\cuda\\include\\math_functions.h"
}


static float __internal_atanhf_kernel(float a_1, float a_2)
{
  float a, a2, t;

  a = a_1 + a_2;
  a2 = a * a;    
  t =                         1.566305595598990E-001f/64.0f;
  t = __internal_fmad (t, a2, 1.995081856004762E-001f/16.0f);
  t = __internal_fmad (t, a2, 3.333382699617026E-001f/4.0f);
  t = t * a2;
  t = __internal_fmad (t, a, a_2);
  t = t + a_1;
  return t;
}  




static float __internal_atanf_kernel(float a)
{
  float t4, t0, t1;

  t4 = a * a;
  t0 = -5.674867153f;
  t0 = __internal_fmad (t4, -0.823362947f, t0);
  t0 = __internal_fmad (t0, t4, -6.565555096f);
  t0 = t0 * t4;
  t0 = t0 * a;
  t1 = t4 + 11.33538818f;
  t1 = __internal_fmad (t1, t4, 28.84246826f);
  t1 = __internal_fmad (t1, t4, 19.69667053f);
  t1 = 1.0f / t1;
  a = __internal_fmad (t0, t1, a);
  return a;
}


static float __internal_tan_kernel(float a)
{
  float a2, s, t;

  a2 = a * a;
  t  = __internal_fmad (4.114678393115178E-003f, a2, -8.231194034909670E-001f);
  s  = a2 - 2.469348886157666E+000f;
  s  = 1.0f / s;
  t  = t * s;
  t  = t * a2;
  t  = __internal_fmad (t, a, a);
  return t;
}

static float __internal_accurate_logf(float a)
{
  float t;
  float z;
  float m;
  int ia;
  ia = __float_as_int(a);

  if ((a > 0.0f) && (a < __int_as_float(0x7f800000))) {
    int e = -127;

    
    if ((unsigned)ia < (unsigned)0x00800000) {
      a = a * 16777216.0f;
      e -= 24;
      ia = __float_as_int(a);
    }
#line 1508 "c:\\cuda\\include\\math_functions.h"
    
    m = __int_as_float((ia & 0x807fffff) | 0x3f800000);
    e += ((unsigned)ia >> 23);
    if (m > 1.414213562f) {
      m = m * 0.5f;
      e = e + 1;
    }      
    t = m - 1.0f;
    z = m + 1.0f;
    z = __fdividef (t, z);
    z = -t * z;
    z = __internal_atanhf_kernel(t, z);
    z = __internal_fmad ((float)e, 0.693147181f, z);
    return z;
  } else {
    
    return __logf(a);
  }
}  

static float2 __internal_log_ep(float a)
{
  float2 res;
  int expo;
  float m;
  float log_hi, log_lo;
  float t_hi, t_lo;
  float f, g, u, v, q;


#line 1539 "c:\\cuda\\include\\math_functions.h"
  float r, s, e;
#line 1541 "c:\\cuda\\include\\math_functions.h"
  expo = (__float_as_int(a) >> 23) & 0xff;

  
  if (expo == 0) {
    a *= 16777216.0f;
    expo = (__float_as_int(a) >> 23) & 0xff;
    expo -= 24;
  }  
#line 1550 "c:\\cuda\\include\\math_functions.h"
  expo -= 127;
  m = __int_as_float((__float_as_int(a) & 0x807fffff) | 0x3f800000);
  if (m > 1.414213562f) {
    m = m * 0.5f;
    expo = expo + 1;
  }

  




  f = m - 1.0f;
  g = m + 1.0f;
  g = 1.0f / g;
  u = 2.0f * f * g;
  v = u * u;
  q = 1.49356810919559350E-001f/64.0f;
  q = __internal_fmad (q, v, 1.99887797540072460E-001f/16.0f);
  q = __internal_fmad (q, v, 3.33333880955515580E-001f/4.0f);
  q = q * v;
  q = q * u;
  log_hi = __int_as_float(__float_as_int(u) & 0xfffff000);
  v = __int_as_float(__float_as_int(f) & 0xfffff000);
  u = 2.0f * (f - log_hi);
  f = f - v;
  u = __internal_fmad (-log_hi, v, u);
  u = __internal_fmad (-log_hi, f, u);
  u = g * u;
  

  
  r = log_hi + u;
  s = u - (r - log_hi);
  log_hi = r;
  log_lo = s;
  
  r = log_hi + q;
  s = ((log_hi - r) + q) + log_lo;
  log_hi = e = r + s;
  log_lo = (r - e) + s;

  
  t_hi = expo * 0.6931457519f;    
  t_lo = expo * 1.4286067653e-6f;

  
  r = t_hi + log_hi;
  s = (((t_hi - r) + log_hi) + log_lo) + t_lo;
  res.y = e = r + s;
  res.x = (r - e) + s;
  return res;
}

static float __internal_accurate_log2f(float a)
{
  return 1.442695041f * __internal_accurate_logf(a);
}




static float2 __internal_dsmul (float2 x, float2 y)
{
    float2 z;

    volatile float up, vp, u1, u2, v1, v2, mh, ml;


#line 1620 "c:\\cuda\\include\\math_functions.h"
    up  = x.y * 4097.0f;
    u1  = (x.y - up) + up;
    u2  = x.y - u1;
    vp  = y.y * 4097.0f;
    v1  = (y.y - vp) + vp;
    v2  = y.y - v1;
    mh  = __fmul_rn(x.y,y.y);
    ml  = (((u1 * v1 - mh) + u1 * v2) + u2 * v1) + u2 * v2;
    ml  = (__fmul_rn(x.y,y.x) + __fmul_rn(x.x,y.y)) + ml;
    z.y = up = mh + ml;
    z.x = (mh - up) + ml;
    return z;
}


static  unsigned int __cudart_i2opi_f [] = {
  0x3c439041,
  0xdb629599,
  0xf534ddc0,
  0xfc2757d1,
  0x4e441529,
  0xa2f9836e,
};


static float __internal_trig_reduction_kernel(float a, int *quadrant)
{
  float j;
  int q;
  if (__cuda_fabsf(a) > 48039.0f) {
    
    unsigned int ia = __float_as_int(a);
    unsigned int s = ia & 0x80000000;
    unsigned int result[7];
    unsigned int phi, plo;
    unsigned int hi, lo;
    unsigned int e;
    int idx;
    e = ((ia >> 23) & 0xff) - 128;
    ia = (ia << 8) | 0x80000000;
    
    idx = 4 - (e >> 5);
    hi = 0;


#line 1666 "c:\\cuda\\include\\math_functions.h"
    for (q = 0; q < 6; q++) {
      plo = __cudart_i2opi_f[q] * ia;
      phi = __umulhi (__cudart_i2opi_f[q], ia);
      lo = hi + plo;
      hi = phi + (lo < plo);
      result[q] = lo;
    }
    result[q] = hi;
    e = e & 31;
    


    hi = result[idx+2];
    lo = result[idx+1];
    if (e) {
      q = 32 - e;
      hi = (hi << e) + (lo >> q);
      lo = (lo << e) + (result[idx] >> q);
    }
    q = hi >> 30;
    
    hi = (hi << 2) + (lo >> 30);
    lo = (lo << 2);
    e = (hi + (lo > 0)) > 0x80000000; 
    q += e;
    if (s) q = -q;
    if (e) {
      unsigned int t;
      hi = ~hi;
      lo = -(int)lo;
      t = (lo == 0);
      hi += t;
      s = s ^ 0x80000000;
    }
    *quadrant = q;
    
    e = 0;
    while ((int)hi > 0) {
      hi = (hi << 1) + (lo >> 31);
      lo = (lo << 1);
      e--;
    }
    lo = hi * 0xc90fdaa2;
    hi = __umulhi(hi, 0xc90fdaa2);
    if ((int)hi > 0) {
      hi = (hi << 1) + (lo >> 31);
      lo = (lo << 1);
      e--;
    }
    hi = hi + (lo > 0);
    ia = s | (((e + 126) << 23) + (hi >> 8) + ((hi << 24) >= 0x80000000));
    return __int_as_float(ia);
  }
  q = __float2int_rn (a * 0.636619772f);
  j = (float)q;
  a = __internal_fmad (-j, 1.5703125000000000e+000f, a);

  
  a = __fmaf_rn (-j, 4.8382673412561417e-004f, a);



#line 1729 "c:\\cuda\\include\\math_functions.h"
  a = __internal_fmad (-j, 6.0771005065061922e-011f, a);
  *quadrant = q;
  return a;
}










static float __internal_expf_kernel(float a, float scale)
{
  float j, z;

  j = __cuda_truncf(a * 1.442695041f);
  z = __internal_fmad (j, -0.6931457519f,    a);
  z = __internal_fmad (j, -1.4286067653e-6f, z);
  z = z * 1.442695041f;
  z = __cuda_exp2f(z) * __cuda_exp2f(j + scale);
  return z;
}

static float __internal_accurate_expf(float a)
{
  float z;

  z = __internal_expf_kernel(a, 0.0f);
  if (a < -105.0f) z = 0.0f;
  if (a >  105.0f) z = __int_as_float(0x7f800000);
  return z;
}

static float __internal_accurate_exp10f(float a)
{
  float j, z;

  j = __cuda_truncf(a * 3.321928094f);
  z = __internal_fmad (j, -3.0102920532226563e-001f, a);
  z = __internal_fmad (j, -7.9034171557301747e-007f, z);
  z = z * 3.321928094f;
  z = __cuda_exp2f(z) * __cuda_exp2f(j);
  if (a < -46.0f) z = 0.0f;
  if (a >  46.0f) z = __int_as_float(0x7f800000);
  return z;
}

static float __internal_lgammaf_pos(float a)
{
  float sum;
  float s, t;

  if (a == __int_as_float(0x7f800000)) {
    return a;
  }
  if (a >= 3.0f) {
    if (a >= 7.8f) {
      


      s = 1.0f / a;
      t = s * s;
      sum =                           0.77783067e-3f;
      sum = __internal_fmad (sum, t, -0.2777655457e-2f);
      sum = __internal_fmad (sum, t,  0.83333273853e-1f);
      sum = __internal_fmad (sum, s,  0.918938533204672f);
      s = 0.5f * __internal_accurate_logf(a);
      t = a - 0.5f;
      s = s * t;
      t = s - a;
      s = __fadd_rn(s, sum); 
      t = t + s;
      return t;
    } else {
      a = a - 3.0f;
      s =                        -7.488903254816711E+002f;
      s = __internal_fmad (s, a, -1.234974215949363E+004f);
      s = __internal_fmad (s, a, -4.106137688064877E+004f);
      s = __internal_fmad (s, a, -4.831066242492429E+004f);
      s = __internal_fmad (s, a, -1.430333998207429E+005f);
      t =                     a - 2.592509840117874E+002f;
      t = __internal_fmad (t, a, -1.077717972228532E+004f);
      t = __internal_fmad (t, a, -9.268505031444956E+004f);
      t = __internal_fmad (t, a, -2.063535768623558E+005f);
      t = __fdividef (s, t);
      t = t + a;
      return t;
    }
  } else if (a >= 1.5f) {
    a = a - 2.0f;
    t =                         4.959849168282574E-005f;
    t = __internal_fmad (t, a, -2.208948403848352E-004f);
    t = __internal_fmad (t, a,  5.413142447864599E-004f);
    t = __internal_fmad (t, a, -1.204516976842832E-003f);
    t = __internal_fmad (t, a,  2.884251838546602E-003f);
    t = __internal_fmad (t, a, -7.382757963931180E-003f);
    t = __internal_fmad (t, a,  2.058131963026755E-002f);
    t = __internal_fmad (t, a, -6.735248600734503E-002f);
    t = __internal_fmad (t, a,  3.224670187176319E-001f);
    t = __internal_fmad (t, a,  4.227843368636472E-001f);
    t = t * a;
    return t;
  } else if (a >= 0.7f) {
    a = 1.0f - a;
    t =                        4.588266515364258E-002f;
    t = __internal_fmad (t, a, 1.037396712740616E-001f);
    t = __internal_fmad (t, a, 1.228036339653591E-001f);
    t = __internal_fmad (t, a, 1.275242157462838E-001f);
    t = __internal_fmad (t, a, 1.432166835245778E-001f);
    t = __internal_fmad (t, a, 1.693435824224152E-001f);
    t = __internal_fmad (t, a, 2.074079329483975E-001f);
    t = __internal_fmad (t, a, 2.705875136435339E-001f);
    t = __internal_fmad (t, a, 4.006854436743395E-001f);
    t = __internal_fmad (t, a, 8.224669796332661E-001f);
    t = __internal_fmad (t, a, 5.772156651487230E-001f);
    t = t * a;
    return t;
  } else {
    t =                         3.587515669447039E-003f;
    t = __internal_fmad (t, a, -5.471285428060787E-003f);
    t = __internal_fmad (t, a, -4.462712795343244E-002f);
    t = __internal_fmad (t, a,  1.673177015593242E-001f);
    t = __internal_fmad (t, a, -4.213597883575600E-002f);
    t = __internal_fmad (t, a, -6.558672843439567E-001f);
    t = __internal_fmad (t, a,  5.772153712885004E-001f);
    t = t * a;
    t = __internal_fmad (t, a, a);
    return -__internal_accurate_logf(t);
  }
}


static float __internal_sin_kernel(float x)
{
  float x2, z;

  x2 = x * x;
  z  =                         -1.95152959e-4f;
  z  = __internal_fmad (z, x2,  8.33216087e-3f);
  z  = __internal_fmad (z, x2, -1.66666546e-1f);
  z  = z * x2;
  z  = __internal_fmad (z, x, x);
  return z;
}


static float __internal_cos_kernel(float x)
{
  float x2, z;

  x2 = x * x;
  z  =                          2.44331571e-5f;
  z  = __internal_fmad (z, x2, -1.38873163e-3f);
  z  = __internal_fmad (z, x2,  4.16666457e-2f);
  z  = __internal_fmad (z, x2, -5.00000000e-1f);
  z  = __internal_fmad (z, x2,  1.00000000e+0f);
  return z;
}

static float __internal_accurate_sinf(float a)
{
  float z;
  int   i;

  if ((__cuda___isinff(a)) || (a == 0.0f)) {
    return __fmul_rn (a, 0.0f);
  }
  z = __internal_trig_reduction_kernel(a, &i);
  
  if (i & 1) {
    z = __internal_cos_kernel(z);
  } else {
    z = __internal_sin_kernel(z);
  }
  if (i & 2) {
    z = -z;
  }
  return z;
}







static float __cuda_rintf(float a)
{


#line 1923 "c:\\cuda\\include\\math_functions.h"
  return __cuda_nearbyintf(a);
#line 1925 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_sinf(float a)
{


#line 1932 "c:\\cuda\\include\\math_functions.h"

#line 1934 "c:\\cuda\\include\\math_functions.h"
  return __internal_accurate_sinf(a);
#line 1936 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_cosf(float a)
{


#line 1943 "c:\\cuda\\include\\math_functions.h"

#line 1945 "c:\\cuda\\include\\math_functions.h"
  float z;
  int i;

  if (__cuda___isinff(a)) {
    return __fadd_rn (a, -a); 
  }
  z = __internal_trig_reduction_kernel(a, &i);
  
  i++;
  if (i & 1) {
    z = __internal_cos_kernel(z);
  } else {
    z = __internal_sin_kernel(z);
  }
  if (i & 2) {
    z = -z;
  }
  return z;
#line 1964 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_tanf(float a)
{


#line 1971 "c:\\cuda\\include\\math_functions.h"

#line 1973 "c:\\cuda\\include\\math_functions.h"
  float z;
  int   i;

  if (__cuda___isinff(a)) {
    return __fadd_rn (a, -a); 
  }
  z = __internal_trig_reduction_kernel(a, &i);
  
  z = __internal_tan_kernel(z);
  if (i & 1) {
    z = - (1.0f / z);
  }
  return z;
#line 1987 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_log2f(float a)
{


#line 1994 "c:\\cuda\\include\\math_functions.h"

#line 1996 "c:\\cuda\\include\\math_functions.h"
  return __internal_accurate_log2f(a);
#line 1998 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_expf(float a)
{


#line 2005 "c:\\cuda\\include\\math_functions.h"

#line 2007 "c:\\cuda\\include\\math_functions.h"
  return __internal_accurate_expf(a);
#line 2009 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_exp10f(float a)
{


#line 2016 "c:\\cuda\\include\\math_functions.h"

#line 2018 "c:\\cuda\\include\\math_functions.h"
  return __internal_accurate_exp10f(a);
#line 2020 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_coshf(float a)
{
  float z;

  a = __cuda_fabsf(a);
  z = __internal_expf_kernel(a, -2.0f);
  z = __internal_fmad (2.0f, z,  __fdividef (0.125f, z));
  if (a >= 90.0f) {
    z = __int_as_float(0x7f800000);     
  }
  return z;
}

static float __cuda_sinhf(float a)
{
  float s, z;

  s = a;
  a = __cuda_fabsf(a);
  if (a < 1.0f) {         
    float a2 = a * a;
    
    z =                         2.816951222e-6f;
    z = __internal_fmad (z, a2, 1.983615978e-4f);
    z = __internal_fmad (z, a2, 8.333350058e-3f);
    z = __internal_fmad (z, a2, 1.666666650e-1f);
    z = z * a2;
    z = __internal_fmad (z, a, a);
  } else {
    z = __internal_expf_kernel(a, -2.0f);
    z = __internal_fmad (2.0f, z, -__fdividef (0.125f, z));
    if (a >= 90.0f) {
      z = __int_as_float(0x7f800000);     
    }
  }
  return __cuda_copysignf(z, s);
}

static float __cuda_tanhf(float a)
{
  float s, t;

  t = __cuda_fabsf(a);
  if (t < 0.55f) {
    float z, z2;
    z = t;
    z2 = z * z;
    t =                          1.643758066599993e-2f;
    t = __internal_fmad (t, z2, -5.267181327760551e-2f);
    t = __internal_fmad (t, z2,  1.332072505223051e-1f);
    t = __internal_fmad (t, z2, -3.333294663641083e-1f);
    t = t * z2;
    s = __internal_fmad (t, z, z);
  } else {
    s = 1.0f - __fdividef(2.0f,(__internal_expf_kernel(2.0f * t, 0.0f)+1.0f));
    if (t >= 88.0f) {
      s = 1.0f;
    }
  }
  return __cuda_copysignf(s, a);
}

static float __cuda_atan2f(float a, float b)
{


#line 2089 "c:\\cuda\\include\\math_functions.h"
  float t0, t1, t3, fa, fb;

  
  
  fb = __cuda_fabsf(b);
  fa = __cuda_fabsf(a);

  if (fa == 0.0f && fb == 0.0f) {
    t3 = __cuda___signbitf(b) ? 3.141592654f : 0;
  } else if ((fa == __int_as_float(0x7f800000)) && (fb == __int_as_float(0x7f800000))) {
    t3 = __cuda___signbitf(b) ? 2.356194490f : 0.785398163f;
  } else {
    
    if (fb < fa) {
      t0 = fa;
      t1 = fb;
    } else {
      t0 = fb;
      t1 = fa;
    }
    t3 = __internal_accurate_fdividef(t1, t0);
    t3 = __internal_atanf_kernel(t3);
    
    if (fa > fb)  t3 = 1.570796327f - t3;
    if (b < 0.0f) t3 = 3.141592654f - t3;
  }
  t3 = __cuda_copysignf(t3, a);

  return t3;
#line 2119 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_atanf(float a)
{
  float t0, t1;

  
  t0 = __cuda_fabsf(a);
  t1 = t0;
  if (t0 > 1.0f) {
    t1 = 1.0f / t1;
  }
  
  t1 = __internal_atanf_kernel(t1);
  
  if (t0 > 1.0f) {
    t1 = 1.570796327f - t1;
  }
  return __cuda_copysignf(t1, a);
}


static float __internal_asinf_kernel(float a)
{
  float t2, t3, t4;

  t2 = a * a;
  t3 = -0.501162291f;
  t3 = __internal_fmad (t3, t2, 0.915201485f);
  t3 = t3 * t2;
  t3 = t3 * a;
  t4 = t2 - 5.478654385f;
  t4 = __internal_fmad (t4, t2, 5.491230488f);
  t4 = 1.0f / t4;
  a = __internal_fmad (t3, t4, a);
  return a;
}

static float __cuda_asinf(float a)
{
  float t0, t1, t2;

  t0 = __cuda_fabsf(a);
  t2 = 1.0f - t0;
  t2 = 0.5f * t2;
  t2 = __cuda_sqrtf(t2);
  t1 = t0 > 0.575f ? t2 : t0;
  t1 = __internal_asinf_kernel(t1);
  t2 = __internal_fmad (-2.0f, t1, 1.570796327f);
  if (t0 > 0.575f) {
    t1 = t2;
  }
  return __cuda_copysignf(t1, a);
}

static float __cuda_acosf(float a)
{
  float t0, t1, t2;

  t0 = __cuda_fabsf(a);
  t2 = 1.0f - t0;
  t2 = 0.5f * t2;
  t2 = __cuda_sqrtf(t2);
  t1 = t0 > 0.575f ? t2 : t0;
  t1 = __internal_asinf_kernel(t1);
  t1 = t0 > 0.575f ? 2.0f * t1 : 1.570796327f - t1;
  if (__cuda___signbitf(a)) {
    t1 = 3.141592654f - t1;
  }
  return t1;
}

static float __cuda_logf(float a)
{


#line 2196 "c:\\cuda\\include\\math_functions.h"

#line 2198 "c:\\cuda\\include\\math_functions.h"
  return __internal_accurate_logf(a);
#line 2200 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_log10f(float a)
{


#line 2207 "c:\\cuda\\include\\math_functions.h"

#line 2209 "c:\\cuda\\include\\math_functions.h"
  return 0.434294482f * __internal_accurate_logf(a);
#line 2211 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_log1pf(float a)
{


#line 2218 "c:\\cuda\\include\\math_functions.h"
  float t;

  
  if (a == 0.0f) return a;
#line 2223 "c:\\cuda\\include\\math_functions.h"
  if (a >= -0.394f && a <= 0.65f) {
    
    t = a + 2.0f;
    t = __fdividef (a, t);
    t = -a * t;
    t = __internal_atanhf_kernel (a, t);
  } else {
    t = __internal_accurate_logf (1.0f + a);
  }
  return t;
#line 2234 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_acoshf(float a)
{


#line 2241 "c:\\cuda\\include\\math_functions.h"
  float t;

  t = a - 1.0f;
  if (__cuda_fabsf(t) > 8388608.0f) {
    
    return 0.693147181f + __internal_accurate_logf(a);
  } else {
    t = t + __cuda_sqrtf(__internal_fmad (a, t, t));
    return __cuda_log1pf(t);
  }
#line 2252 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_asinhf(float a)
{


#line 2259 "c:\\cuda\\include\\math_functions.h"
  float fa, oofa, t;

  fa = __cuda_fabsf(a);
  if (fa > 8.507059173e37f) {   
    t = 0.693147181f + __logf(fa);  
  } else {
    oofa = 1.0f / fa;
    t =fa+__fdividef (fa,(oofa+__cuda_sqrtf(__internal_fmad(oofa,oofa,1.0f))));
    t = __cuda_log1pf(t);
  }
  return __cuda_copysignf(t, a);
#line 2271 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_atanhf(float a)
{


#line 2278 "c:\\cuda\\include\\math_functions.h"
  float fa, t;

  fa = __cuda_fabsf(a);
  t = __fdividef ((2.0f * fa), (1.0f - fa));
  t = 0.5f * __cuda_log1pf(t);
  return __cuda_copysignf(t, a);
#line 2285 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_expm1f(float a)
{
  float t, z, j, u;
  
  t = __cuda_rintf (a * 1.442695041f);
  z = __internal_fmad (-t, 0.6931457519f, a);
  z = __internal_fmad (-t, 1.4286067653e-6f, z);
  
  if (__cuda_fabsf(a) < 0.41f) {
    z = a;
    t = 0.0f;
  }
  
  j = t;
  if (t == 128.0f) j = j - 1.0f; 
  
  u =                        1.38795078474044430E-003f;
  u = __internal_fmad (u, z, 8.38241261853264930E-003f);
  u = __internal_fmad (u, z, 4.16678317762833940E-002f);
  u = __internal_fmad (u, z, 1.66663978874356580E-001f);
  u = __internal_fmad (u, z, 4.99999940395997040E-001f);
  u = u * z;
  u = __internal_fmad (u, z, z);
  if (a == 0.0f) u = a; 
  
  z = __cuda_exp2f (j);
  a = z - 1.0f;
  if (a != 0.0f) u = __internal_fmad (u, z, a); 
  if (t == 128.0f) u = u + u; 
  
  if (j >  128.0f) u = __int_as_float(0x7f800000);
  if (j <  -25.0f) u = -1.0f;
  return u;
}

static float __cuda_hypotf(float a, float b)
{


#line 2327 "c:\\cuda\\include\\math_functions.h"
  float v, w, t;

  a = __cuda_fabsf(a);
  b = __cuda_fabsf(b);
  
  if (a > b) {
    v = a;
    w = b; 
  } else {
    v = b;
    w = a;
  }
  t = __internal_accurate_fdividef(w, v);
  t = __internal_fmad (t, t, 1.0f);
  t = v * __cuda_sqrtf(t);
  if (v == 0.0f) {
    t = v + w;
  }
  if ((v == __int_as_float(0x7f800000)) || (w == __int_as_float(0x7f800000))) {
    t = __int_as_float(0x7f800000);
  }
  return t;
#line 2350 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_cbrtf(float a)
{


#line 2357 "c:\\cuda\\include\\math_functions.h"
  float s, t;

  s = __cuda_fabsf(a);
  if ((a == 0.0f) || (s == __int_as_float(0x7f800000))) {
    return a + a;
  } 
  t = __cuda_exp2f(0.333333333f * __log2f(s));   
  t = t-(t-(__fdividef(s,(t*t))))*0.333333333f;  




#line 2370 "c:\\cuda\\include\\math_functions.h"
  t = __cuda_copysignf(t, a);
#line 2372 "c:\\cuda\\include\\math_functions.h"
  return t;
#line 2374 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_erff(float a)
{
  float t, r, q;

  t = __cuda_fabsf(a);
  if (t < 1.0f) {
    t = t * t;
    r =                        -5.58510127926029810E-004f;
    r = __internal_fmad (r, t,  4.90688891415893070E-003f);
    r = __internal_fmad (r, t, -2.67027980930150640E-002f);
    r = __internal_fmad (r, t,  1.12799056505903940E-001f);
    r = __internal_fmad (r, t, -3.76122956138427440E-001f);
    r = __internal_fmad (r, t,  1.12837911712623450E+000f);
    a = a * r;
  } else if (t <= __int_as_float(0x7f800000)) { 
    


    q = __internal_fmad (t, 0.3275911f, 1.0f);
    q = 1.0f / q;
    r =                         1.061405429f;
    r = __internal_fmad (r, q, -1.453152027f);
    r = __internal_fmad (r, q,  1.421413741f);
    r = __internal_fmad (r, q, -0.284496736f);
    r = __internal_fmad (r, q,  0.254829592f);
    r = r * q;
    q = __internal_expf_kernel(-a * a, 0.0f);
    r = __internal_fmad (-q, r, 1.0f);
    if (t >= 5.5f) {
      r = 1.0f;
    }
    a = __int_as_float (__float_as_int(r) | (__float_as_int(a) & 0x80000000));
  }
  return a;
}

static float __cuda_erfinvf (float a)
{
  float fa, t;
  
  fa = fabsf(a);
  if (fa >= 1.0f) {
    t = __cuda_rsqrtf (__int_as_float (0xffc00000));  
    if (fa == 1.0f) {
      t = a * __int_as_float(0x7f800000);   
    }
  } else if (fa > 0.9375f) {
    



    float p, q;

    t = __cuda_log1pf(-fa);
    t = __cuda_rsqrtf(-t);
    p =                        -1.64441567910e-1f;
    p = __internal_fmad (p, t,  6.80544246825e-1f);
    p = __internal_fmad (p, t, -1.12808139162e+0f);
    p = __internal_fmad (p, t,  6.90969348887e-1f);
    p = __internal_fmad (p, t,  1.38271964963e+0f);
    p = __internal_fmad (p, t,  1.55047000312e-1f);
    q =                     t + 1.38522814199e+0f;
    q = __internal_fmad (q, t,  1.55024849822e-1f);
    q = q * t;
    t = __fdividef (p, q);
    if (a < 0.0f) t = -t;
  } else if (fa > 0.75f) {
    



    float p, q;

    t = __internal_fmad (a, a, -0.87890625f);
    p =                        -7.1986748896e+0f;
    p = __internal_fmad (p, t, +1.3411974175e+1f);
    p = __internal_fmad (p, t, -5.1381573203e+0f);
    p = __internal_fmad (p, t,  4.9633374831e-1f);
    q =                     t  -1.1436535838e+1f;
    q = __internal_fmad (q, t,  1.3568885572e+1f);
    q = __internal_fmad (q, t, -4.1747509256e+0f);
    q = __internal_fmad (q, t,  3.5327242323e-1f);
    p = __fdividef (p, q);
    t = a * p;
  } else {  
    float a2;

    a2 = a * a;
    t =                          6.1046168794766742E-001f;
    t = __internal_fmad (t, a2, -8.9504882462753121E-001f);
    t = __internal_fmad (t, a2,  7.0224162369928511E-001f);
    t = __internal_fmad (t, a2, -1.9993784895823222E-001f);
    t = __internal_fmad (t, a2,  1.1920613463949599E-001f);
    t = __internal_fmad (t, a2,  8.0131492246997685E-002f);
    t = __internal_fmad (t, a2,  1.2793154958377403E-001f);
    t = __internal_fmad (t, a2,  2.3200529172828793E-001f);
    t = __internal_fmad (t, a2,  8.8622695604694379E-001f);
    t = t * a;
  }
  return t;
}

static float __cuda_erfcf(float a)
{

    if (__cuda___isnanf(a)) return a + a;
#line 2483 "c:\\cuda\\include\\math_functions.h"
  if (a <= 0.813f) {
    return 1.0f - __cuda_erff(a);
  } else if (a > 10.055f) {
    return 0.0f;
  } else {
    float p;
    float q;
    float h;
    float l;
    



    p =                        1.9997798317768276E-006f;
    p = __internal_fmad (p, a, 5.6410849770777538E-001f);
    p = __internal_fmad (p, a, 2.4579440583231387E+000f);
    p = __internal_fmad (p, a, 4.9763988947448308E+000f);
    p = __internal_fmad (p, a, 4.5767235962336885E+000f);
    q =                    a + 4.3540863476555538E+000f;
    q = __internal_fmad (q, a, 9.3453217404616584E+000f);
    q = __internal_fmad (q, a, 1.0132282183545772E+001f);
    q = __internal_fmad (q, a, 4.5781789912165518E+000f);   
    
    h = 1.0f / q;
    q = __internal_fmad (-q * h, h, 2.0f * h);
    p = p * q;
    
    h = __int_as_float(__float_as_int(a) & 0xfffff000);  
    l = __fadd_rn (a, -h);  
    q = __fmul_rn (-h, h);  
    q = __internal_expf_kernel(q, 0.0f);
    a = a + h;
    l = l * a;
    h = __internal_expf_kernel(-l, 0.0f);
    q = q * h;
    p = p * q;
    return p;
  }
}

static float __cuda_erfcinvf (float a)
{
  float t;
  if (a <= 0.0f) {
    t = __int_as_float(0x7fffffff);
    if (a == 0.0f) {
      t = (1.0f - a) * __int_as_float(0x7f800000);
    }
  } 
  else if (a >= 0.0625f) {
    t = __cuda_erfinvf (1.0f - a);
  }
  else {
    float p, q;
    t = __cuda_logf(a);
    t = __cuda_rsqrtf(-t);
    p =                        -1.64441567910e-1f;
    p = __internal_fmad (p, t,  6.80544246825e-1f);
    p = __internal_fmad (p, t, -1.12808139162e+0f);
    p = __internal_fmad (p, t,  6.90969348887e-1f);
    p = __internal_fmad (p, t,  1.38271964963e+0f);
    p = __internal_fmad (p, t,  1.55047000312e-1f);
    q =                     t + 1.38522814199e+0f;
    q = __internal_fmad (q, t,  1.55024849822e-1f);
    q = q * t;
    t = __fdividef (p, q);
  }
  return t;
}

static float __cuda_lgammaf(float a)
{
  float t;
  float i;
  int quot;
  t = __internal_lgammaf_pos(__cuda_fabsf(a));
  if (a >= 0.0f) return t;
  a = __cuda_fabsf(a);
  i = __cuda_floorf(a);                   
  if (a == i) return __int_as_float(0x7f800000); 
  if (a < 1e-19f) return -__internal_accurate_logf(a);
  i = __cuda_rintf (2.0f * a);
  quot = (int)i;
  i = __internal_fmad (-i, 0.5f, a);
  i = i * 3.141592654f;
  if (quot & 1) {
    i = __internal_cos_kernel(i);
  } else {
    i = __internal_sin_kernel(i);
  }
  i = __cuda_fabsf(i);
  t = 1.144729886f - __internal_accurate_logf(i * a) - t;
  return t;
}

static float __cuda_ldexpf(float a, int b)
{


#line 2583 "c:\\cuda\\include\\math_functions.h"
  float fa = __cuda_fabsf(a);

  if ((fa == 0.0f) || (fa == __int_as_float(0x7f800000)) || (b == 0)) {
    if (!(fa > 0.0f)) a = a + a;
    return a;
  } else if (__cuda_abs(b) < 126) {
    return a * __cuda_exp2f((float)b);
  } else if (__cuda_abs(b) < 252) {
    int bhalf = b / 2;
    return a * __cuda_exp2f((float)bhalf) * __cuda_exp2f((float)(b - bhalf));
  } else {
    int bquarter = b / 4;
    float t = __cuda_exp2f((float)bquarter);
    return a * t * t * t * __cuda_exp2f((float)(b - 3 * bquarter));
  }
#line 2599 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_scalbnf(float a, int b)
{


#line 2606 "c:\\cuda\\include\\math_functions.h"
  
  return __cuda_ldexpf(a, b);
#line 2609 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_scalblnf(float a, long int b)
{


#line 2616 "c:\\cuda\\include\\math_functions.h"
  int t;
  if (b > 2147483647L) {
    t = 2147483647;
  } else if (b < (-2147483647 - 1)) {
    t = (-2147483647 - 1);
  } else {
    t = (int)b;
  }
  return __cuda_scalbnf(a, t);
#line 2626 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_frexpf(float a, int *b)
{
  float fa = __cuda_fabsf(a);
  unsigned int expo;
  unsigned int denorm;

  if (fa < 1.175494351e-38f) {
    a *= 16777216.0f;
    denorm = 24;
  } else {
    denorm = 0;
  }
  expo = ((__float_as_int(a) >> 23) & 0xff);
  if ((fa == 0.0f) || (expo == 0xff)) {
    expo = 0;
    a = a + a;
  } else {  
    expo = expo - denorm - 126;
    a = __int_as_float(((__float_as_int(a) & 0x807fffff) | 0x3f000000));
  }
  *b = expo;
  return a;
}

static float __cuda_modff(float a, float *b)
{


#line 2657 "c:\\cuda\\include\\math_functions.h"
  float t;
  if (__cuda___finitef(a)) {
    t = __cuda_truncf(a);
    *b = t;
    t = a - t;
    return __cuda_copysignf(t, a);
  } else if (__cuda___isinff(a)) {
    t = 0.0f;
    *b = a;
    return __cuda_copysignf(t, a);
  } else {
    *b = a; 
    return a;
  }
#line 2672 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_fmodf(float a, float b)
{


#line 2679 "c:\\cuda\\include\\math_functions.h"
  float orig_a = a;
  float orig_b = b;
  a = __cuda_fabsf(a);
  b = __cuda_fabsf(b);
  if (!((a <= __int_as_float(0x7f800000)) && (b <= __int_as_float(0x7f800000)))) {
    return orig_a + orig_b;
  }
  if ((a == __int_as_float(0x7f800000)) || (b == 0.0f)) {
    return __cuda_rsqrtf (__int_as_float (0xffc00000));
  } else if (a >= b) {

    
    int expoa = (a < 1.175494351e-38f) ? 
        ((int)__log2f(a)) : (((__float_as_int(a) >> 23) & 0xff) - 127);
    int expob = (b < 1.175494351e-38f) ? 
        ((int)__log2f(b)) : (((__float_as_int(b) >> 23) & 0xff) - 127);
    int scale = expoa - expob;
    float scaled_b = __cuda_ldexpf(b, scale);
    if (scaled_b <= 0.5f * a) {
      scaled_b *= 2.0f;
    }






#line 2707 "c:\\cuda\\include\\math_functions.h"
    while (scaled_b >= b) {
      if (a >= scaled_b) {
        a -= scaled_b;
      }
      scaled_b *= 0.5f;
    }
    return __cuda_copysignf(a, orig_a);
  } else {
    if (!(a > 0.0f)) orig_a = orig_a + orig_a;
    return orig_a;
  }
#line 2719 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_remainderf(float a, float b)
{

  float twoa = 0.0f;
  unsigned int quot0 = 0;  
  float orig_a = a;
  float orig_b = b;

  a = __cuda_fabsf(a);
  b = __cuda_fabsf(b);
  if (!((a <= __int_as_float(0x7f800000)) && (b <= __int_as_float(0x7f800000)))) {
    return orig_a + orig_b;
  }
  if ((a == __int_as_float(0x7f800000)) || (b == 0.0f)) {
    return __cuda_rsqrtf (__int_as_float (0xffc00000));
  } else if (a >= b) {

    int expoa = (a < 1.175494351e-38f) ? 
        ((int)__log2f(a)) : (((__float_as_int(a) >> 23) & 0xff) - 127);
    int expob = (b < 1.175494351e-38f) ? 
        ((int)__log2f(b)) : (((__float_as_int(b) >> 23) & 0xff) - 127);
    int scale = expoa - expob;
    float scaled_b = __cuda_ldexpf(b, scale);
    if (scaled_b <= 0.5f * a) {
      scaled_b *= 2.0f;
    }










#line 2758 "c:\\cuda\\include\\math_functions.h"
    while (scaled_b >= b) {
      quot0 = 0;
      if (a >= scaled_b) {
        twoa = __internal_fmad (a, 2.0f, -scaled_b) - scaled_b;
        a = a - scaled_b;
        quot0 = 1;
      }
      scaled_b *= 0.5f;
    }
  }
  

  twoa = 2.0f * a;
  if ((twoa > b) || ((twoa == b) && quot0)) {
    a -= b;
    a = __int_as_float(__float_as_int(a) | 0x80000000);
  }














#line 2790 "c:\\cuda\\include\\math_functions.h"
  a = __int_as_float((__float_as_int(orig_a) & 0x80000000)^
                     __float_as_int(a));
  return a;
}

static float __cuda_remquof(float a, float b, int* quo)
{
  float twoa = 0.0f;
  unsigned int quot = 0;  
  unsigned int sign;
  float orig_a = a;
  float orig_b = b;

  
  sign = 0 - (__cuda___signbitf(a) != __cuda___signbitf(b));
  a = __cuda_fabsf(a);
  b = __cuda_fabsf(b);
  if (!((a <= __int_as_float(0x7f800000)) && (b <= __int_as_float(0x7f800000)))) {
    *quo = quot;
    return orig_a + orig_b;
  }
  if ((a == __int_as_float(0x7f800000)) || (b == 0.0f)) {
    *quo = quot;
    return __cuda_rsqrtf (__int_as_float (0xffc00000));
  } else if (a >= b) {

    
    int expoa = (a < 1.175494351e-38f) ? 
        ((int)__log2f(a)) : (((__float_as_int(a) >> 23) & 0xff) - 127);
    int expob = (b < 1.175494351e-38f) ? 
        ((int)__log2f(b)) : (((__float_as_int(b) >> 23) & 0xff) - 127);
    int scale = expoa - expob;
    float scaled_b = __cuda_ldexpf(b, scale);
    if (scaled_b <= 0.5f * a) {
      scaled_b *= 2.0f;
    }



















#line 2846 "c:\\cuda\\include\\math_functions.h"
    while (scaled_b >= b) {
      quot <<= 1;
      if (a >= scaled_b) {
        twoa = (2.0f * a - scaled_b) - scaled_b;
        a -= scaled_b;
        quot += 1;
      }
      scaled_b *= 0.5f;
    }
  }
  

  twoa = 2.0f * a;
  if ((twoa > b) || ((twoa == b) && (quot & 1))) {
    quot++;
    a -= b;
    a = __cuda_copysignf (a, -1.0f);
  }
















#line 2881 "c:\\cuda\\include\\math_functions.h"
  a = __int_as_float((__float_as_int(orig_a) & 0x80000000)^
                     __float_as_int(a));
  quot = quot & (~((~0)<<3));
  quot = quot ^ sign;
  quot = quot - sign;
  *quo = quot;
  return a;
}

static float __cuda_fmaf(float a, float b, float c)
{
  return __fmaf_rn(a, b, c);
}

static float __internal_accurate_powf(float a, float b)
{
  float2 loga, prod;

  volatile float t;


#line 2903 "c:\\cuda\\include\\math_functions.h"

  
  loga = __internal_log_ep(a);

  
  if (__cuda_fabsf(b) > 1.0e34f) b *= 1.220703125e-4f;
  prod.y = b;
  prod.x = 0.0f;
  prod = __internal_dsmul (prod, loga);

  
  if (__float_as_int(prod.y) == 0x42b17218) {
    prod.y = __int_as_float(__float_as_int(prod.y) - 1);
    prod.x = prod.x + __int_as_float(0x37000000);
  }

  
  t = __cuda_expf(prod.y);
  
  if (t != __int_as_float(0x7f800000)) {
    


    t = __internal_fmad (t, prod.x, t);
  }
  return t;
}

static float __cuda_powif(float a, int b)
{
  unsigned int e = __cuda_abs(b);
  float        r = 1.0f;

  while (1) {
    if ((e & 1) != 0) {
      r = r * a;
    }
    e = e >> 1;
    if (e == 0) {
      return b < 0 ? 1.0f / r : r;
    }
    a = a * a;
  }
}

static double __cuda_powi(double a, int b)
{
  unsigned int e = __cuda_abs(b);
  double       r = 1.0;

  while (1) {
    if ((e & 1) != 0) {
      r = r * a;
    }
    e = e >> 1;
    if (e == 0) {
      return b < 0 ? 1.0 / r : r;
    }
    a = a * a;
  }
}

static float __cuda_powf(float a, float b)
{


#line 2970 "c:\\cuda\\include\\math_functions.h"

#line 2972 "c:\\cuda\\include\\math_functions.h"
  int bIsOddInteger;
  float t;
  if (a == 1.0f || b == 0.0f) {
    return 1.0f;
  } 
  if (__cuda___isnanf(a) || __cuda___isnanf(b)) {
    return a + b;
  }
  if (a == __int_as_float(0x7f800000)) {
    return __cuda___signbitf(b) ? 0.0f : __int_as_float(0x7f800000);
  }
  if (__cuda___isinff(b)) {
    if (a == -1.0f) {
      return 1.0f;
    }
    t = (__cuda_fabsf(a) > 1.0f) ? __int_as_float(0x7f800000) : 0.0f;
    if (b < 0.0f) {
      t = 1.0f / t;
    }
    return t;
  }
  bIsOddInteger = (b - (2.0f * floorf(0.5f * b))) == 1.0f;
  if (a == 0.0f) {
    t = bIsOddInteger ? a : 0.0f;
    if (b < 0.0f) {
      t = 1.0f / t;
    }
    return t;
  } 
  if (a == -__int_as_float(0x7f800000)) {
    t = - ((b < 0.0f) ? (1.0f / a) : a);
    if (bIsOddInteger) {
      t = __int_as_float(__float_as_int(t) ^ 0x80000000);
    }
    return t;
  } 
  if ((a < 0.0f) && (b != __cuda_truncf(b))) {
    return __cuda_rsqrtf(__int_as_float(0xffc00000));
  }
  t = __cuda_fabsf(a);
  t = __internal_accurate_powf(t, b);
  if ((a < 0.0f) && bIsOddInteger) {
    t = __int_as_float(__float_as_int(t) ^ 0x80000000);
  }
  return t;
#line 3018 "c:\\cuda\\include\\math_functions.h"
}


static float __internal_tgammaf_kernel(float a)
{
  float t;
  t =                        -1.05767296987211380E-003f;
  t = __internal_fmad (t, a,  7.09279059435508670E-003f);
  t = __internal_fmad (t, a, -9.65347121958557050E-003f);
  t = __internal_fmad (t, a, -4.21736613253687960E-002f);
  t = __internal_fmad (t, a,  1.66542401247154280E-001f);
  t = __internal_fmad (t, a, -4.20043267827838460E-002f);
  t = __internal_fmad (t, a, -6.55878234051332940E-001f);
  t = __internal_fmad (t, a,  5.77215696929794240E-001f);
  t = __internal_fmad (t, a,  1.00000000000000000E+000f);
  return t;
}





static float __cuda_tgammaf(float a)
{
  float s, xx, x=a;
  if (x >= 0.0f) {
    if (x > 36.0f) x = 36.0f; 
    s = 1.0f;
    xx = x;
    if (x > 34.03f) { 
      xx -= 1.0f;
    }
    while (xx > 1.5f) {
      xx = xx - 1.0f;
      s = s * xx;
    }
    if (x >= 0.5f) {
      xx = xx - 1.0f;
    }
    xx = __internal_tgammaf_kernel(xx);
    if (x < 0.5f) {
      xx = xx * x;
    }
    s = __fdividef(s, xx);
    if (x > 34.03f) {
      
      xx = x - 1.0f;
      s = s * xx;
    }
    return s;
  } else {
    if (x == __cuda_floorf(x)) {  
      x = __int_as_float(0x7fffffff);  

      return x;
#line 3074 "c:\\cuda\\include\\math_functions.h"
    } 
    if (x < -41.1f) x = -41.1f; 
    xx = x;
    if (x < -34.03f) {           
      xx += 6.0f;
    } 
    s = xx;
    while (xx < -0.5f) {
      xx = xx + 1.0f;
      s = s * xx;
    }
    xx = __internal_tgammaf_kernel(xx);
    s = s * xx;
    s = 1.0f / s;
    if (x < -34.03f) {
      xx = x;
      xx *= (x + 1.0f);
      xx *= (x + 2.0f);
      xx *= (x + 3.0f);
      xx *= (x + 4.0f);
      xx *= (x + 5.0f);
      xx = 1.0f / xx;
      s = s * xx;
      if ((a < -42.0f) && !(((int)a)&1)) {
        s = __int_as_float(0x80000000);
      }
    }    
    return s;
  }
}

static float __cuda_roundf(float a)
{


#line 3110 "c:\\cuda\\include\\math_functions.h"
  float fa = __cuda_fabsf(a);
  float u = __cuda_copysignf (0.5f, a);
  u = __cuda_truncf (a + u);
  if (fa > 8388608.0f) u = a;
  if (fa < 0.5f) u = __cuda_truncf (a);
  return u;
#line 3117 "c:\\cuda\\include\\math_functions.h"
}

static long long int __internal_llroundf_kernel(float a)
{
  unsigned long long int res, t = 0LL;
  int shift;
  unsigned int ia = __float_as_int(a);
  
  if ((ia << 1) > 0xff000000) return 0x8000000000000000LL;
  if ((int)ia >= 0x5f000000) return 0x7fffffffffffffffLL;
  if (ia >= 0xdf000000) return 0x8000000000000000LL;
  shift = 189 - ((ia >> 23) & 0xff);
  res = ((long long int)(((ia << 8) | 0x80000000) >> 1)) << 32;
  if (shift >= 64) {
    t = res;
    res = 0;
  } else if (shift) {
    t = res << (64 - shift);
    res = res >> shift;
  }
  if (t >= 0x8000000000000000LL) {
    res++;
  }
  if ((int)ia < 0) res = (unsigned long long int)(-(long long int)res);
  return (long long int)res;
}

static long long int __cuda_llroundf(float a)
{


#line 3149 "c:\\cuda\\include\\math_functions.h"
  return __internal_llroundf_kernel(a);
#line 3151 "c:\\cuda\\include\\math_functions.h"
}

static long int __cuda_lroundf(float a)
{


#line 3158 "c:\\cuda\\include\\math_functions.h"


#line 3161 "c:\\cuda\\include\\math_functions.h"

  if (__cuda___isnanf(a)) return 0L;
  if (a >=  2147483648.0f) return 2147483647L;
  if (a <= -2147483648.0f) return (-2147483647L - 1L);
#line 3166 "c:\\cuda\\include\\math_functions.h"
  return (long int)(__cuda_roundf(a));
#line 3168 "c:\\cuda\\include\\math_functions.h"
#line 3169 "c:\\cuda\\include\\math_functions.h"
}

static float __cuda_fdimf(float a, float b)
{
  float t;
  t = a - b;    
  if (a <= b) {
    t = 0.0f;
  }
  return t;
}

static int __cuda_ilogbf(float a)
{
  unsigned int i;
  int expo;
  a = __cuda_fabsf(a);
  if (a <= 1.175494351e-38f) {
    
    if (a == 0.0f) {
      expo = -((int)((unsigned int)-1 >> 1))-1;
    } else {
      expo = -126;
      i = __float_as_int(a);
      i = i << 8;
      while ((int)i >= 0) {
        expo--;
        i = i + i;
      }
    }
  } else {
    i = __float_as_int(a);
    expo = ((int)((i >> 23) & 0xff)) - 127;
    if ((i == 0x7f800000)) {
      expo = ((int)((unsigned int)-1 >> 1));
    }
    if ((i > 0x7f800000)) {
      expo = -((int)((unsigned int)-1 >> 1))-1;
    }
  } 
  return expo;
}

static float __cuda_logbf(float a)
{


#line 3217 "c:\\cuda\\include\\math_functions.h"
  unsigned int i;
  int expo;
  float res;

  if (__cuda___isnanf(a)) return a + a;
#line 3223 "c:\\cuda\\include\\math_functions.h"
  a = __cuda_fabsf(a);
  if (a <= 1.175494351e-38f) {
    
    if (a == 0.0f) {
      res = -__int_as_float(0x7f800000);
    } else {
      expo = -126;
      i = __float_as_int(a);
      i = i << 8;
      while ((int)i >= 0) {
        expo--;
        i = i + i;
      }
      res = (float)expo;
    }
  } else {
    i = __float_as_int(a);
    expo = ((int)((i >> 23) & 0xff)) - 127;
    res = (float)expo;
    if ((i >= 0x7f800000)) {  
      
      res = a + a;
    }
  } 
  return res;
#line 3249 "c:\\cuda\\include\\math_functions.h"
}

static void __cuda_sincosf(float a, float *sptr, float *cptr)
{


#line 3256 "c:\\cuda\\include\\math_functions.h"

#line 3258 "c:\\cuda\\include\\math_functions.h"
  float t, u, s, c;
  int quadrant;
  t = __cuda_fabsf(a);
  if ((t == __int_as_float(0x7f800000)) || (t == 0.0f)) {
    s = __fmul_rn (a, 0.0f); 
    c = 1.0f + s;                     
    *sptr = s;
    *cptr = c;
    return;
  }
  t = __internal_trig_reduction_kernel(a, &quadrant);
  u = __internal_cos_kernel(t);
  t = __internal_sin_kernel(t);
  if (quadrant & 1) {
    s = u;
    c = t;
  } else {
    s = t;
    c = u;
  }
  if (quadrant & 2) {
    s = -s;
  }
  quadrant++;
  if (quadrant & 2) {
    c = -c;
  }
  *sptr = s;
  *cptr = c;
#line 3288 "c:\\cuda\\include\\math_functions.h"
}











static double rsqrt(double a)
{
  return 1.0 / sqrt(a);
}

static float rsqrtf(float a)
{
  return (float)rsqrt((double)a);
}













static double exp10(double a)
{
  return pow(10.0, a);
}



#line 3330 "c:\\cuda\\include\\math_functions.h"





static int __finite(double a)
{
  volatile union {
    double                 d;
    unsigned long long int l;
  } cvt;

  cvt.d = a;

  return cvt.l << 1 < 0xffe0000000000000ull;
}

static int __isnan(double a)
{
  volatile union {
    double                 d;
    unsigned long long int l;
  } cvt;

  cvt.d = a;

  return cvt.l << 1 > 0xffe0000000000000ull;
}

static int __isinf(double a)
{
  volatile union {
    double                 d;
    unsigned long long int l;
  } cvt;

  cvt.d = a;

  return cvt.l << 1 == 0xffe0000000000000ull;
}

static double round(double a)
{
  double fa = fabs(a);

  if (fa > 4503599627370496.0) {
    return a;
  } else {
    double u = floor(fa + 0.5);

    if (__signbit(a)) {
      u = -u;
    }
    return u;
  }
}

static long int lround(double a)
{
  return (long int)round(a);
}

static long long int llround(double a)
{
  return (long long int)round(a);
}

static double rint(double a)
{
  double fa = fabs(a);
  double u = 4503599627370496.0 + fa;
  if (fa >= 4503599627370496.0) {
    u = a;
  } else {
    u = u - 4503599627370496.0;
    if (__signbit(a)) {
      u = -u;
    }
  }
  return u;  
}

static long int lrint(double a)
{
  return (long int)rint(a);
}

static long long int llrint(double a)
{
  return (long long int)rint(a);
}

static double fdim(double a, double b)
{
  if (a > b) {
    return (a - b);
  } else if (a <= b) {
    return 0.0;
  } else if (__isnan(a)) {
    return a;
  } else {
    return b;
  }
}

static double scalbn(double a, int b)
{
  return ldexp(a, b);
}

static double scalbln(double a, long int b)
{
  int t;
  if (b > 2147483647L) {
    t = 2147483647;
  } else if (b < (-2147483647 - 1)) {
    t = (-2147483647 - 1);
  } else {
    t = (int)b;
  }
  return scalbn(a, t);
}






static double log1p(double a)
{
  volatile double u, m;

  u = 1.0 + a;
  if (u == 1.0) {
    
    u = a;
  } else {
    m = u - 1.0;
    u = log(u);
    if (a < 1.0) {
      
      u = a * u;
      u = u / m;
    }
  }
  return u;
}




static double expm1(double a)
{
  volatile double u, m;

  u = exp(a);
  m = u - 1.0;
  if (m == 0.0) {
    
    m = a;
  } 
  else if (fabs(a) < 1.0) {
    
    u = log(u);
    m = m * a;
    m = m / u;
  }
  return m;
}

static double cbrt(double a)
{
  double s, t;
  if (a == 0.0 || __isinf(a)) {
    return a;
  } 
  s = fabs(a);
  t = exp2(3.3333333333333333e-1 * log2(s));           
  t = t - (t - (s / (t * t))) * 3.3333333333333333e-1; 
  if (__signbit(a)) {
    t = -t;
  }
  return t;
}

static double acosh(double a)
{
  double s, t;

  t = a - 1.0;
  if (t == a) {
    return log(2.0) + log(a);
  } else {
    s = a + 1.0;
    t = t + sqrt(s * t);
    return log1p(t);
  }
}

static double asinh(double a)
{
  double fa, oofa, t;

  fa = fabs(a);
  oofa = 1.0 / fa;
  t = fa + fa / (oofa + sqrt(1.0 + oofa * oofa));
  t = log1p(t);
  if (__signbit(a)) {
    t = -t;
  }
  return t;
}

static double atanh(double a)
{
  double fa, t;

  fa = fabs(a);
  t = (2.0 * fa) / (1.0 - fa);
  t = 0.5 * log1p(t);
  if (__signbit(a)) {
    t = -t;
  }
  return t;
}

static int ilogb(double a)
{
  volatile union {
    double                 d;
    unsigned long long int l;
  } x;
  unsigned long long int i;
  int expo = -1022;

  if (__isnan(a)) return -((int)((unsigned int)-1 >> 1))-1;
  if (__isinf(a)) return ((int)((unsigned int)-1 >> 1));
  x.d = a;
  i = x.l & 0x7fffffffffffffffull;
  if (i == 0) return -((int)((unsigned int)-1 >> 1))-1;
  if (i >= 0x0010000000000000ull) {
    return (int)(((i >> 52) & 0x7ff) - 1023);
  }
  while (i < 0x0010000000000000ull) {
    expo--;
    i <<= 1;
  }
  return expo;
}

static double logb(double a)
{
  volatile union {
    double                 d;
    unsigned long long int l;
  } x;
  unsigned long long int i;
  int expo = -1022;

  if (__isnan(a)) return a;
  if (__isinf(a)) return fabs(a);
  x.d = a;
  i = x.l & 0x7fffffffffffffffull;
  if (i == 0) return -1.0/a;
  if (i >= 0x0010000000000000ull) {
    return (double)((int)((i >> 52) & 0x7ff) - 1023);
  }
  while (i < 0x0010000000000000ull) {
    expo--;
    i <<= 1;
  }
  return (double)expo;
}

static double fma(double a, double b, double c)
{
  return __fma_rn(a, b, c);
}

static void sincos(double a, double *sptr, double *cptr)
{
  *sptr = sin(a);
  *cptr = cos(a);
}







static float roundf(float a)
{
  return (float)round((double)a);
}

static long int lroundf(float a)
{
  return lround((double)a);
}

static long long int llroundf(float a)
{
  return llround((double)a);
}

static float rintf(float a)
{
  return (float)rint((double)a);
}

static long int lrintf(float a)
{
  return lrint((double)a);
}

static long long int llrintf(float a)
{
  return llrint((double)a);
}

static float logbf(float a)
{
  return (float)logb((double)a);
}

static float scalblnf(float a, long int b)
{
  return (float)scalbln((double)a, b);
}

static float acoshf(float a)
{
  return (float)acosh((double)a);
}

static float asinhf(float a)
{
  return (float)asinh((double)a);
}

static float atanhf(float a)
{
  return (float)atanh((double)a);
}

static float cbrtf(float a)
{
  return (float)cbrt((double)a);
}

static float expm1f(float a)
{
  return (float)expm1((double)a);
}

static float exp10f(float a)
{
  return (float)exp10((double)a);
}

static float fdimf(float a, float b)
{
  return (float)fdim((double)a, (double)b);
}

static float hypotf(float a, float b)
{
  return (float)hypot((double)a, (double)b);
}

static float log1pf(float a)
{
  return (float)log1p((double)a);
}

static float scalbnf(float a, int b)
{
  return (float)scalbn((double)a, b);
}

static float fmaf(float a, float b, float c)
{
  return (float)fma((double)a, (double)b, (double)c);
}

static void sincosf(float a, float *sptr, float *cptr)
{
  double s, c;

  sincos((double)a, &s, &c);
  *sptr = (float)s;
  *cptr = (float)c;
}

static int ilogbf(float a)
{
  return ilogb((double)a);
}

static float erff(float a)
{
  return (float)erf((double)a);
}

static float erfinvf(float a)
{
  return (float)erfinv((double)a);
}

static float erfcf(float a)
{
  return (float)erfc((double)a);
}

static float erfcinvf(float a)
{
  return (float)erfcinv((double)a);
}

static float lgammaf(float a)
{
  return (float)lgamma((double)a);
}

static float tgammaf(float a)
{
  return (float)tgamma((double)a);
}

static float remquof(float a, float b, int *quo)
{
  return (float)remquo((double)a, (double)b, quo);
}

static float remainderf(float a, float b)
{
  return (float)remainder((double)a, (double)b);
}

static float nextafterf(float a, float b)
{
  return (float)nextafter((double)a, (double)b);
}







static int __finitef(float a)
{
  return __cuda___finitef(a);
}

static int __isinff(float a)
{
  return __cuda___isinff(a);
}

static int __isnanf(float a)
{
  return __cuda___isnanf(a);
}







static double lgamma(double a)
{
  return (double)__cuda_lgammaf((float)a);
}

static double tgamma(double a)
{
  return (double)__cuda_tgammaf((float)a);
}

static double erf(double a)
{
  return (double)__cuda_erff((float)a);
}

static double erfinv(double a)
{
  return (double)__cuda_erfinvf((float)a);
}

static double erfc(double a)
{
  return (double)__cuda_erfcf((float)a);
}

static double erfcinv(double a)
{
  return (double)__cuda_erfcinvf((float)a);
}

static double remquo(double a, double b, int *quo)
{
  return (double)__cuda_remquof((float)a, (float)b, quo);
}

static double remainder(double a, double b)
{
  return (double)__cuda_remainderf((float)a, (float)b);
}

static double nextafter(double a, double b)
{
  return (double)__cuda_nextafterf((float)a, (float)b);
}



#line 3850 "c:\\cuda\\include\\math_functions.h"

#line 3852 "c:\\cuda\\include\\math_functions.h"

#line 3854 "c:\\cuda\\include\\math_functions.h"





#line 3860 "c:\\cuda\\include\\math_functions.h"





#line 3866 "c:\\cuda\\include\\math_functions.h"



#line 1 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"










































#line 44 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"

#line 1 "c:\\cuda\\include\\crt/func_macro.h"
































































































#line 98 "c:\\cuda\\include\\crt/func_macro.h"
#line 46 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"




#line 1 "c:\\cuda\\include\\device_functions.h"































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 4673 "c:\\cuda\\include\\device_functions.h"

#line 51 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
#line 1 "c:\\cuda\\include\\math_constants.h"











































































































































#line 141 "c:\\cuda\\include\\math_constants.h"
#line 52 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"

#line 1 "c:\\cuda\\include\\common_types.h"


































































#line 68 "c:\\cuda\\include\\common_types.h"
#line 54 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
#line 55 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"






static double __cuda_fabs(double a)
{
  return fabs(a);
}
   
static double __cuda_fmax(double a, double b)
{

  volatile union __cudart_DoubleUlonglongCvt cvta, cvtb;
  int nana, nanb;
  
  cvta.d = a;
  cvtb.d = b;
  nana = ((cvta.i << 1) > 0xffe0000000000000ULL);
  nanb = ((cvtb.i << 1) > 0xffe0000000000000ULL);
  if (nana && nanb) return a + b;
  if (nana) return b;
  if (nanb) return a;
  if ((cvta.d == 0.0) && (cvtb.d == 0.0)) {
    cvta.i &= cvtb.i;
    return cvta.d;
  }
  return a > b ? a : b;


#line 87 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
}

static double __cuda_fmin(double a, double b)
{

  volatile union __cudart_DoubleUlonglongCvt cvta, cvtb;
  int nana, nanb;  

  cvta.d = a;
  cvtb.d = b;
  nana = ((cvta.i << 1) > 0xffe0000000000000ULL);
  nanb = ((cvtb.i << 1) > 0xffe0000000000000ULL);
  if (nana && nanb) return a + b;
  if (nana) return b;
  if (nanb) return a;
  if ((cvta.i | cvtb.i) == 0x8000000000000000ULL) {
    return __longlong_as_double(0x8000000000000000ULL)  ;
  }
  return a < b ? a : b;


#line 109 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
}

static double __cuda_ceil(double a)
{
  return ceil(a);
}

static double __cuda_floor(double a)
{
  return floor(a);
}

static double __cuda_trunc(double a)
{
  return trunc(a);
}

static double __cuda_nearbyint(double a)
{


#line 131 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  double res = nearbyint(a);




#line 137 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  return res;
#line 139 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
}







static double __cuda_rint(double a)
{
  return __cuda_nearbyint(a);
}

static long int __cuda_lrint(double a)
{


#line 157 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  return (long int)__double2int_rn(a);
#line 159 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
}

static long long int __cuda_llrint(double a)
{
  return __double2ll_rn(a);
}

static int __cuda___signbit(double a)
{
  return (int)((unsigned int)__double2hiint(a) >> 31);
}

static int __cuda___finite(double a)
{
  return __cuda_fabs(a) < __longlong_as_double(0x7ff0000000000000ULL);
}

static int __cuda___isinf(double a)
{
  return __cuda_fabs(a) == __longlong_as_double(0x7ff0000000000000ULL);
}

static int __cuda___isnan(double a)
{
  return !(__cuda_fabs(a) <= __longlong_as_double(0x7ff0000000000000ULL));
}

static double __cuda_copysign(double a, double b)
{
  int alo, ahi, bhi;

  bhi = __double2hiint(b);
  alo = __double2loint(a);
  ahi = __double2hiint(a);
  ahi = (bhi & 0x80000000) | (ahi & ~0x80000000);
  return __hiloint2double(ahi, alo);
}


static  unsigned long long int __cudart_i2opi_d [] = {
  0x6bfb5fb11f8d5d08ULL,
  0x3d0739f78a5292eaULL,
  0x7527bac7ebe5f17bULL,
  0x4f463f669e5fea2dULL,
  0x6d367ecf27cb09b7ULL,
  0xef2f118b5a0a6d1fULL,
  0x1ff897ffde05980fULL,
  0x9c845f8bbdf9283bULL,
  0x3991d639835339f4ULL,
  0xe99c7026b45f7e41ULL,
  0xe88235f52ebb4484ULL,
  0xfe1deb1cb129a73eULL,
  0x06492eea09d1921cULL,
  0xb7246e3a424dd2e0ULL,
  0xfe5163abdebbc561ULL,
  0xdb6295993c439041ULL,
  0xfc2757d1f534ddc0ULL,
  0xa2f9836e4e441529ULL,
};

static double __internal_trig_reduction_kerneld(double a, int *quadrant)
{
  double j;
  int q;
  if (__cuda_fabs(a) > 2147483648.0) {
    
    unsigned long long int ia;
    unsigned long long int s;
    unsigned long long int result[5];
    unsigned long long int phi, plo;
    unsigned long long int hi, lo;
    unsigned int e;
    int idx;

    ia = __double_as_longlong(a);
    s = ia & 0x8000000000000000ULL;
    e = (unsigned int)(((ia >> 52) & 0x7ff) - 1024);
    ia = (ia << 11) | 0x8000000000000000ULL;
    
    idx = 16 - (e >> 6);
    hi = 0;


#line 243 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
    for (q = (idx-1); q < min(18,idx+3); q++) {
      plo = __cudart_i2opi_d[q] * ia;
      phi = __umul64hi (__cudart_i2opi_d[q], ia);
      lo = hi + plo;
      hi = phi + (lo < plo);
      result[q-(idx-1)] = lo;
    }
    result[q-(idx-1)] = hi;
    e = e & 63;
    


    hi = result[3];
    lo = result[2];
    if (e) {
      q = 64 - e;
      hi = (hi << e) | (lo >> q);
      lo = (lo << e) | (result[1] >> q);
    }
    q = (int)(hi >> 62);
    
    hi = (hi << 2) | (lo >> 62);
    lo = (lo << 2);
    e = (hi | (lo > 0)) > 0x8000000000000000ULL; 
    q += e;
    if (s) q = -q;
    if (e) {
      unsigned long long int t;
      hi = ~hi;
      lo = -(long long int)lo;
      t = (lo == 0ULL);
      hi += t;
      s = s ^ 0x8000000000000000ULL;
    }
    *quadrant = q;
    
    e = 0;
    while ((long long int)hi > 0) {
      hi = (hi << 1) | (lo >> 63);
      lo = (lo << 1);
      e--;
    }
    lo = hi * 0xC90FDAA22168C235ULL;
    hi = __umul64hi (hi, 0xC90FDAA22168C235ULL);
    if ((long long int)hi > 0) {
      hi = (hi << 1) | (lo >> 63);
      lo = (lo << 1);
      e--;
    }
    hi = hi + (lo > 0);
    ia = s | ((((unsigned long long int)(e + 1022)) << 52) + (hi >> 11) +
              ((hi << 53) >= 0x8000000000000000ULL));
    return __longlong_as_double(ia);
  } 
  
  q = __double2int_rn (a * 6.3661977236758138e-1);
  j = (double)q;
  



  a = __fma_rn (-j, 1.5707963267948966e+000, a);
  a = __fma_rn (-j, 6.1232339957367574e-017, a);
  a = __fma_rn (-j, 8.4784276603688985e-032, a);
  *quadrant = q;
  return a;
}


static double __internal_sin_kerneld(double x)
{
  double x2, z;
  x2 = x * x;
  z =                   1.5896230157221844E-010;
  z = __fma_rn (z, x2, -2.5050747762850355E-008);
  z = __fma_rn (z, x2,  2.7557313621385676E-006);
  z = __fma_rn (z, x2, -1.9841269829589539E-004);
  z = __fma_rn (z, x2,  8.3333333333221182E-003);
  z = __fma_rn (z, x2, -1.6666666666666630E-001);
  z  = z * x2;
  z  = __fma_rn (z, x, x);
  return z;
}


static double __internal_cos_kerneld(double x)
{
  double x2, z;
  x2 = x * x;
  z  =                  -1.136788825395985E-011;   
  z  = __fma_rn (z, x2,  2.087588480545065E-009);
  z  = __fma_rn (z, x2, -2.755731555403950E-007);
  z  = __fma_rn (z, x2,  2.480158729365970E-005);
  z  = __fma_rn (z, x2, -1.388888888888074E-003);
  z  = __fma_rn (z, x2,  4.166666666666664E-002);
  z  = __fma_rn (z, x2, -5.000000000000000E-001);
  z  = __fma_rn (z, x2,  1.000000000000000E+000);
  return z;
}


static double __internal_tan_kerneld(double x, int i)
{
  double x2, z, q;
  x2 = x * x;
  z =                   9.8006287203286300E-006;
  z = __fma_rn (z, x2, -2.4279526494179897E-005);
  z = __fma_rn (z, x2,  4.8644173130937162E-005);
  z = __fma_rn (z, x2, -2.5640012693782273E-005);
  z = __fma_rn (z, x2,  6.7223984330880073E-005);
  z = __fma_rn (z, x2,  8.3559287318211639E-005);
  z = __fma_rn (z, x2,  2.4375039850848564E-004);
  z = __fma_rn (z, x2,  5.8886487754856672E-004);
  z = __fma_rn (z, x2,  1.4560454844672040E-003);
  z = __fma_rn (z, x2,  3.5921008885857180E-003);
  z = __fma_rn (z, x2,  8.8632379218613715E-003);
  z = __fma_rn (z, x2,  2.1869488399337889E-002);
  z = __fma_rn (z, x2,  5.3968253972902704E-002);
  z = __fma_rn (z, x2,  1.3333333333325342E-001);
  z = __fma_rn (z, x2,  3.3333333333333381E-001);
  z = z * x2;
  q = __fma_rn (z, x, x);
  if (i) {
    double s = q - x; 
    double w = __fma_rn (z, x, -s); 
    z = 1.0 / q;
    z = -z;
    s = __fma_rn (q, z, 1.0);
    q = __fma_rn (z, __fma_rn (z, w, s), z);
  }           
  return q;
}

static double __cuda_sqrt(double a)
{
  return sqrt(a);
}

static double __cuda_rsqrt(double a)
{

    return 1.0 / sqrt(a);


#line 388 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
}


static double __internal_expm1_kernel (double a)
{
  double t;
  t =                 2.08842685477913050E-009;
  t = __fma_rn (t, a, 2.51366409033551950E-008);
  t = __fma_rn (t, a, 2.75574612072447230E-007);
  t = __fma_rn (t, a, 2.75571539284473460E-006);
  t = __fma_rn (t, a, 2.48015869443077950E-005);
  t = __fma_rn (t, a, 1.98412699878799470E-004);
  t = __fma_rn (t, a, 1.38888888892029890E-003);
  t = __fma_rn (t, a, 8.33333333327662860E-003);
  t = __fma_rn (t, a, 4.16666666666656370E-002);
  t = __fma_rn (t, a, 1.66666666666667380E-001);
  t = __fma_rn (t, a, 5.00000000000000000E-001);
  t = t * a;
  t = __fma_rn (t, a, a);
  return t;
}


static double __internal_atanh_kernel (double a_1, double a_2)
{
  double a, a2, t;

  a = a_1 + a_2;
  a2 = a * a;
  t =                  7.597322383488143E-002/65536.0;
  t = __fma_rn (t, a2, 6.457518383364042E-002/16384.0);          
  t = __fma_rn (t, a2, 7.705685707267146E-002/4096.0);
  t = __fma_rn (t, a2, 9.090417561104036E-002/1024.0);
  t = __fma_rn (t, a2, 1.111112158368149E-001/256.0);
  t = __fma_rn (t, a2, 1.428571416261528E-001/64.0);
  t = __fma_rn (t, a2, 2.000000000069858E-001/16.0);
  t = __fma_rn (t, a2, 3.333333333333198E-001/4.0);
  t = t * a2;
  t = __fma_rn (t, a, a_2);
  t = t + a_1;
  return t;
}

static double __internal_exp2i_kernel(int b)
{
  return __hiloint2double((b + 1023) << 20, 0);
}

static double __internal_half(double a)
{
  unsigned int ihi, ilo;
  ilo = __double2loint(a);
  ihi = __double2hiint(a);
  return __hiloint2double(ihi - 0x00100000, ilo);
}

static double __internal_twice(double a)
{
  unsigned int ihi, ilo;
  ilo = __double2loint(a);
  ihi = __double2hiint(a);
  return __hiloint2double(ihi + 0x00100000, ilo);
}

static double __cuda_sin(double a)
{
  double z;
  int i;
  if (__cuda___isinf(a) || (a == 0.0)) {
    return __dmul_rn(a, 0.0);
  }
  z = __internal_trig_reduction_kerneld(a, &i);
  
  if (i & 1) {
    z = __internal_cos_kerneld(z);
  } else {
    z = __internal_sin_kerneld(z);
  }
  if (i & 2) {
    z = -z;
  }
  return z;
}

static double __cuda_cos(double a)
{
  double z;
  int i;
  if (__cuda___isinf(a)) {
    return __longlong_as_double(0xfff8000000000000ULL);
  }
  z = __internal_trig_reduction_kerneld(a, &i);
  
  i++;
  if (i & 1) {
    z = __internal_cos_kerneld(z);
  } else {
    z = __internal_sin_kerneld(z);
  }
  if (i & 2) {
    z = -z;
  }
  return z;
}

static void __cuda_sincos(double a, double *sptr, double *cptr)
{
  double t, u, s, c;
  int i;
  t = __cuda_fabs(a);
  if ((t == __longlong_as_double(0x7ff0000000000000ULL)) || (t == 0.0)) {
    s = __dmul_rn (a, 0.0); 
    c = 1.0 + s;                    
    *sptr = s;
    *cptr = c;
    return;
  }
  t = __internal_trig_reduction_kerneld(a, &i);
  u = __internal_cos_kerneld(t);
  t = __internal_sin_kerneld(t);
  if (i & 1) {
    s = u;
    c = t;
  } else {
    s = t;
    c = u;
  }
  if (i & 2) {
    s = -s;
  }
  i++;
  if (i & 2) {
    c = -c;
  }
  *sptr = s;
  *cptr = c;
}

static double __cuda_tan(double a)
{
  double z;
  int i;
  if (__cuda___isinf(a)) {
    return __longlong_as_double(0xfff8000000000000ULL);
  }
  z = __internal_trig_reduction_kerneld(a, &i);
  
  z = __internal_tan_kerneld(z, i & 1);
  return z;
}

static double __cuda_log(double a)
{
  double m, f, g, u, v, tmp, q, ulo, log_lo, log_hi;
  int ihi, ilo;

  ihi = __double2hiint(a);
  ilo = __double2loint(a);

  if ((a > 0.0) && (a < __longlong_as_double(0x7ff0000000000000ULL))) {
    int e = -1023;
    
    if ((unsigned)ihi < (unsigned)0x00100000) {
      a = a * 18014398509481984.0;
      e -= 54;
      ihi = __double2hiint(a);
      ilo = __double2loint(a);
    }
    


    e += (ihi >> 20);
    ihi = (ihi & 0x800fffff) | 0x3ff00000;
    m = __hiloint2double (ihi, ilo);
    if ((unsigned)ihi > (unsigned)0x3ff6a09e) {
      m = __internal_half(m);
      e = e + 1;
    }
    
    f = m - 1.0;
    g = m + 1.0;
    g = 1.0 / g;
    u = f * g;
    u = u + u;  
    
    v = u * u;
    q =                 6.7261411553826339E-2/65536.0;
    q = __fma_rn (q, v, 6.6133829643643394E-2/16384.0);
    q = __fma_rn (q, v, 7.6940931149150890E-2/4096.0);
    q = __fma_rn (q, v, 9.0908745692137444E-2/1024.0);
    q = __fma_rn (q, v, 1.1111111499059706E-1/256.0);
    q = __fma_rn (q, v, 1.4285714283305975E-1/64.0);
    q = __fma_rn (q, v, 2.0000000000007223E-1/16.0);
    q = __fma_rn (q, v, 3.3333333333333326E-1/4.0);
    tmp = __internal_twice (f - u);
    tmp = __fma_rn (-u, f, tmp); 
    ulo = g * tmp;               
    
    q = q * v;
    q = q * u;      
     
    log_hi = u;
    log_lo = ulo + q;
    
    q   = __fma_rn ( e, 6.9314718055994529e-1, log_hi);
    tmp = __fma_rn (-e, 6.9314718055994529e-1, q);
    tmp = tmp - log_hi;
    log_hi = q;
    log_lo = log_lo - tmp;
    log_lo = __fma_rn (e, 2.3190468138462996e-17, log_lo);
    return log_hi + log_lo;
  } else {
    if (__cuda___isnan(a)) {
      return a + a;
    }
    
    if (a == 0) {
      return -__longlong_as_double(0x7ff0000000000000ULL);
    }
    
    if (a == __longlong_as_double(0x7ff0000000000000ULL)) {
      return a;
    }
    
    return __longlong_as_double(0xfff8000000000000ULL);
  }
}


static double2 __internal_ddadd_xgty (double2 x, double2 y)
{
  double2 z;


#line 623 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  double r, s, e;
  r = x.y + y.y;
  e = x.y - r;
  s = ((e + y.y) + y.x) + x.x;
  z.y = e = r + s;
  z.x = (r - e) + s;
  return z;
}


static double2 __internal_ddmul (double2 x, double2 y)
{


#line 638 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  double e;
  double2 t, z;
  t.y = x.y * y.y;
  t.x = __fma_rn (x.y, y.y, -t.y);
  t.x = __fma_rn (x.x, y.x, t.x);
  t.x = __fma_rn (x.y, y.x, t.x);
  t.x = __fma_rn (x.x, y.y, t.x);
  z.y = e = t.y + t.x;
  z.x = (t.y - e) + t.x;
  return z;
}

static double2 __internal_log_ext_prec(double a)
{
  double2 res;
  double2 qq, cc, uu, tt;
  double f, g, u, v, q, ulo, tmp, m;
  int ilo, ihi, expo;

  ihi = __double2hiint(a);
  ilo = __double2loint(a);
  expo = (ihi >> 20) & 0x7ff;
  
  if (expo == 0) {
    a *= 18014398509481984.0;
    ihi = __double2hiint(a);
    ilo = __double2loint(a);
    expo = (ihi >> 20) & 0x7ff;
    expo -= 54;
  }  
  expo -= 1023;
  



  ihi = (ihi & 0x800fffff) | 0x3ff00000;
  m = __hiloint2double (ihi, ilo);
  if ((unsigned)ihi > (unsigned)0x3ff6a09e) {
    m = __internal_half(m);
    expo = expo + 1;
  }
  




  f = m - 1.0;
  g = m + 1.0;
  g = 1.0 / g;
  u = f * g;
  u = u + u;  
  
  v = u * u;
  q =                 6.6253631649203309E-2/65536.0;
  q = __fma_rn (q, v, 6.6250935587260612E-2/16384.0);
  q = __fma_rn (q, v, 7.6935437806732829E-2/4096.0);
  q = __fma_rn (q, v, 9.0908878711093280E-2/1024.0);
  q = __fma_rn (q, v, 1.1111111322892790E-1/256.0);
  q = __fma_rn (q, v, 1.4285714284546502E-1/64.0);
  q = __fma_rn (q, v, 2.0000000000003113E-1/16.0);
  q = q * v;
  
  tmp = __internal_twice (f - u);
  tmp = __fma_rn (-u, f, tmp); 
  ulo = g * tmp;               
  
  qq.y = q;
  qq.x = 0.0;
  uu.y = u;
  uu.x = ulo;
  cc.y =  3.3333333333333331E-1/4.0;
  cc.x = -9.8201492846582465E-18/4.0;
  qq = __internal_ddadd_xgty (cc, qq);
  
  qq = __internal_ddmul(qq, uu);
  qq = __internal_ddmul(qq, uu);
  qq = __internal_ddmul(qq, uu);
  uu = __internal_ddadd_xgty (uu, qq);
  u   = uu.y;
  ulo = uu.x;
  
  tt.y = expo * 6.9314718055966296e-001;  
  tt.x = expo * 2.8235290563031577e-013;
  
  res = __internal_ddadd_xgty (tt, uu);
  return res;
}

static double __cuda_log2(double a)
{
  double t;
  t = __cuda_log(a);
  return __fma_rn (t, 1.4426950408889634e+0, t * 2.0355273740931033e-17);
}

static double __cuda_log10(double a)
{
  double t;
  t = __cuda_log(a);
  return __fma_rn (t, 4.3429448190325182e-1, t * 1.09831965021676510e-17);
}

static double __cuda_log1p(double a)
{
  double t;
  int i;

  i = __double2hiint(a);
  if (((unsigned)i < (unsigned)0x3fe55555) || ((int)i < (int)0xbfd99999)) {
    
    t = a + 2.0;
    t = a / t;
    t = -a * t;
    t = __internal_atanh_kernel(a, t);
    return t;
  }
  return __cuda_log (a + 1.0);
}

static double __internal_exp_kernel(double a, int scale)
{ 
  double t, fac, z;
  int i;
  
  t = __cuda_rint (a * 1.4426950408889634e+0);
  i = (int)t;
  z = __fma_rn (t, -6.9314718055994529e-1, a);
  z = __fma_rn (t, -2.3190468138462996e-17, z);
  fac = 2.0;
  if (i <= -1021) {
    i += 55;
    fac = 5.5511151231257827e-17;
  }
  
  t = __internal_expm1_kernel(z);
  z = __internal_exp2i_kernel(i + scale - 1);
  t = __fma_rn (t, z, z);
  t = t * fac;
  return t;
}

static double __cuda_exp(double a)
{
  double t;
  int i;
  i = __double2hiint(a);
  if (((unsigned)i < (unsigned)0x40862e43) || ((int)i < (int)0xC0874911)) {
    t = __internal_exp_kernel(a, 0);
    return t;
  }
  t = ((unsigned int)i >> 31) ? 0.0 : __longlong_as_double(0x7ff0000000000000ULL);
  if (__cuda___isnan(a)) {
    t = a + a;
  }
  return t;
}

static double __cuda_exp2(double a)
{
  double z;
  double t;
  double fac;
  int i;

  i = __double2hiint(a);
  if (((unsigned)i < (unsigned)0x40900000) || ((int)i < (int)0xc090cc00)) {
    t = __cuda_rint (a);
    z = a - t;
    i = (int)t;
    fac = 2.0;
    if (i <= -1021) {
      i += 55;
      fac = 5.5511151231257827e-17;
    }
    
    z = __fma_rn (z, 6.9314718055994529e-1, z * 2.3190468138462996e-17);
    t = __internal_expm1_kernel(z);
    z = __internal_exp2i_kernel(i - 1);
    t = __fma_rn (t, z, z);
    t = t * fac;
    return t;
  } 
  t = ((unsigned int)i >> 31) ? 0.0 : __longlong_as_double(0x7ff0000000000000ULL);
  if (__cuda___isnan(a)) {
    t = a + a;
  }
  return t;
}

static double __cuda_exp10(double a)
{
  double z;
  double t;
  double fac;
  int i;

  i = __double2hiint(a);
  if (((unsigned)i < (unsigned)0x40734414) || ((int)i < (int)0xc07439b8)) {
    t = __cuda_rint (a * 3.3219280948873622e+0);
    i = (int)t;
    z = __fma_rn (t, -3.0102999566398120e-1, a);
    z = __fma_rn (t, -(-2.8037281277851704e-18), z);
    fac = 2.0;
    if (i <= -1021) {
      i += 55;
      fac = 5.5511151231257827e-17;
    }
    
    z = __fma_rn (z, 2.3025850929940459e+0, z * (-2.1707562233822494e-16));
    t = __internal_expm1_kernel(z);
    z = __internal_exp2i_kernel(i - 1);
    t = __fma_rn (t, z, z);
    t = t * fac;
    return t;
  }
  t = ((unsigned int)i >> 31) ? 0.0 : __longlong_as_double(0x7ff0000000000000ULL);
  if (__cuda___isnan(a)) {
    t = a + a;
  }
  return t;
}

static double __cuda_expm1(double a)
{
  double t, z, u;
  int i, j, k;

  k = __double2hiint(a);
  if (((unsigned)k < (unsigned)0x40862e43) || ((int)k < (int)0xc04a8000)) {
    t = __cuda_rint (a * 1.4426950408889634e+0);
    i = (int)t;
    z = __fma_rn (t, -6.9314718055994529e-1, a);
    z = __fma_rn (t, -2.3190468138462996e-17, z);
    k = k + k;
    if ((unsigned)k < (unsigned)0x7fb3e647) {
      z = a;
      i = 0;
    }
    t = __internal_expm1_kernel(z);
    j = i;
    if (i == 1024) j--;
    u = __internal_exp2i_kernel(j);
    a = u - 1.0;
    t = __fma_rn (t, u, a);
    if (i == 1024) t = t + t;
    if (k == 0) t = z;              
    return t;
  }
  t = ((unsigned int)k >> 31) ? -1.0 : __longlong_as_double(0x7ff0000000000000ULL);
  if (__cuda___isnan(a)) {
    t = a + a;
  }
  return t;
}

static double __cuda_cosh(double a)
{
  double z;
  int i;

  z = __cuda_fabs(a);
  i = __double2hiint(z);
  if ((unsigned)i < (unsigned)0x408633cf) {
    z = __internal_exp_kernel(z, -2);
    z = __fma_rn(2.0, z, 0.125 / z);
    return z;
  } else {
    if (z > 0.0) a = __int_as_float(0x7f800000);
    return a + a;
  }
}

static double __cuda_sinh(double a)
{
  double s, z;
  s = a;
  a = __cuda_fabs(a);
  if (a < 1.0) {          
    double a2 = a * a;
    
    z =                  1.632386098183803E-010;
    z = __fma_rn (z, a2, 2.504854501385687E-008);
    z = __fma_rn (z, a2, 2.755734274788706E-006);
    z = __fma_rn (z, a2, 1.984126976294102E-004);
    z = __fma_rn (z, a2, 8.333333333452911E-003);
    z = __fma_rn (z, a2, 1.666666666666606E-001);
    z = z * a2;
    z = __fma_rn (z, a, a);
  } else if (a < 2.0) {   
    z = __cuda_expm1(a);
    z = __internal_half (z + z / (z + 1.0));
  } else {
    z = __internal_exp_kernel(a, -1);
    z = z + (1.0 / (-4.0 * z));
    if (a >= 7.1047586007394398e+2) {
      z = __longlong_as_double(0x7ff0000000000000ULL);     
    }
  }
  z = __cuda_copysign(z, s);
  return z;
}

static double __cuda_tanh(double a)
{
  double t;
  t = __cuda_fabs(a);
  if (t >= 0.55) {
    double s;
    s = 1.0 - 2.0 / (__internal_exp_kernel(2.0 * t, 0) + 1.0);
    if (t > 350.0) {
      s = 1.0;       
    }
    a = __cuda_copysign(s, a);
  } else {
    double a2;
    a2 = a * a;
    t =                   5.102147717274194E-005;
    t = __fma_rn (t, a2, -2.103023983278533E-004);
    t = __fma_rn (t, a2,  5.791370145050539E-004);
    t = __fma_rn (t, a2, -1.453216755611004E-003);
    t = __fma_rn (t, a2,  3.591719696944118E-003);
    t = __fma_rn (t, a2, -8.863194503940334E-003);
    t = __fma_rn (t, a2,  2.186948597477980E-002);
    t = __fma_rn (t, a2, -5.396825387607743E-002);
    t = __fma_rn (t, a2,  1.333333333316870E-001);
    t = __fma_rn (t, a2, -3.333333333333232E-001);
    t = t * a2;
    t = __fma_rn (t, a, a);
    a = __cuda_copysign(t, a);
  }
  return a;
}

static double __internal_atan_kernel(double a)
{
  double t, a2;
  a2 = a * a;
  t =                  -2.0258553044438358E-005 ;
  t = __fma_rn (t, a2,  2.2302240345758510E-004);
  t = __fma_rn (t, a2, -1.1640717779930576E-003);
  t = __fma_rn (t, a2,  3.8559749383629918E-003);
  t = __fma_rn (t, a2, -9.1845592187165485E-003);
  t = __fma_rn (t, a2,  1.6978035834597331E-002);
  t = __fma_rn (t, a2, -2.5826796814495994E-002);
  t = __fma_rn (t, a2,  3.4067811082715123E-002);
  t = __fma_rn (t, a2, -4.0926382420509971E-002);
  t = __fma_rn (t, a2,  4.6739496199157994E-002);
  t = __fma_rn (t, a2, -5.2392330054601317E-002);
  t = __fma_rn (t, a2,  5.8773077721790849E-002);
  t = __fma_rn (t, a2, -6.6658603633512573E-002);
  t = __fma_rn (t, a2,  7.6922129305867837E-002);
  t = __fma_rn (t, a2, -9.0909012354005225E-002);
  t = __fma_rn (t, a2,  1.1111110678749424E-001);
  t = __fma_rn (t, a2, -1.4285714271334815E-001);
  t = __fma_rn (t, a2,  1.9999999999755019E-001);
  t = __fma_rn (t, a2, -3.3333333333331860E-001);
  t = t * a2;
  t = __fma_rn (t, a, a);
  return t;
}

static double __cuda_atan2(double a, double b)
{
  double t0, t1, t3;
  if (__cuda___isnan(a) || __cuda___isnan(b)) {
    return a + b;
  }
  
  
  t3 = __cuda_fabs(b);
  t1 = __cuda_fabs(a);
  if (t3 == 0.0 && t1 == 0.0) {
    t3 = __cuda___signbit(b) ? 3.1415926535897931e+0 : 0;
  } else if (__cuda___isinf(t3) && __cuda___isinf(t1)) {
    t3 = __cuda___signbit(b) ? 2.3561944901923448e+0 : 7.8539816339744828e-1;
  } else {
    t0 = __cuda_fmax (t1, t3);
    t1 = __cuda_fmin (t1, t3);
    t3 = t1 / t0;
    t3 = __internal_atan_kernel(t3);
    
    if (__cuda_fabs(a) > __cuda_fabs(b)) t3 = 1.5707963267948966e+0 - t3;
    if (b < 0.0)                         t3 = 3.1415926535897931e+0 - t3;
  }
  t3 = __cuda_copysign(t3, a);
  return t3;
}

static double __cuda_atan(double a)
{
  double t0, t1;
  
  t0 = __cuda_fabs(a);
  t1 = t0;
  if (t0 > 1.0) {
    t1 = 1.0 / t1;
  }
  
  t1 = __internal_atan_kernel(t1);
  
  if (t0 > 1.0) {
    t1 = 1.5707963267948966e+0 - t1;
  }
  return __cuda_copysign (t1, a);
}


static double __internal_asin_kernel(double a, double b)
{
  double r;
  r =                  6.259798167646803E-002;
  r = __fma_rn (r, b, -7.620591484676952E-002);
  r = __fma_rn (r, b,  6.686894879337643E-002);
  r = __fma_rn (r, b, -1.787828218369301E-002); 
  r = __fma_rn (r, b,  1.745227928732326E-002);
  r = __fma_rn (r, b,  1.000422754245580E-002);
  r = __fma_rn (r, b,  1.418108777515123E-002);
  r = __fma_rn (r, b,  1.733194598980628E-002);
  r = __fma_rn (r, b,  2.237350511593569E-002);
  r = __fma_rn (r, b,  3.038188875134962E-002);
  r = __fma_rn (r, b,  4.464285849810986E-002);
  r = __fma_rn (r, b,  7.499999998342270E-002);
  r = __fma_rn (r, b,  1.666666666667375E-001);
  r = r * b;
  return r;
}

static double __cuda_asin(double a)
{
  double fa, t0, t1;
  int ihi, ahi;
  ahi = __double2hiint(a);
  fa  = __cuda_fabs(a);
  ihi = __double2hiint(fa);
  if (ihi < 0x3fe26666) {
    t1 = fa * fa;
    t1 = __internal_asin_kernel (fa, t1);
    t1 = __fma_rn (t1, fa, fa);
    t1 = __cuda_copysign(t1, a);
  } else {
    t1 = __fma_rn (-0.5, fa, 0.5);
    t0 = __cuda_sqrt (t1);
    t1 = __internal_asin_kernel (t0, t1);
    t0 = -2.0 * t0;
    t1 = __fma_rn (t0, t1, 6.1232339957367660e-17);
    t0 = t0 + 7.8539816339744828e-1;
    t1 = t0 + t1;
    t1 = t1 + 7.8539816339744828e-1;
    if (ahi < 0x3ff00000) {
      t1 = __cuda_copysign(t1, a);
    }
  }
  return t1;
}

static double __cuda_acos(double a)
{
  double t0, t1;
  int ihi, ahi;


  if (__cuda___isnan(a)) {
    return a + a;
  }
#line 1103 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  ahi = __double2hiint(a);
  t0 = __cuda_fabs (a);
  ihi = __double2hiint(t0);
  if (ihi < 0x3fe26666) {  
    t1 = t0 * t0;
    t1 = __internal_asin_kernel (t0, t1);
    t0 = __fma_rn (t1, t0, t0);
    if ((unsigned)ahi >= (unsigned)0x80000000) {
      t0 = __fma_rn (1.0, t0, +6.1232339957367660e-17);
      t0 = 1.5707963267948966e+0 + t0;
    } else {
      t0 = __fma_rn (1.0, t0, -6.1232339957367660e-17);
      t0 = 1.5707963267948966e+0 - t0;
    }
  } else {
    t1 = __fma_rn (-0.5, t0, 0.5);
    t0 = __cuda_sqrt(t1);
    t1 = __internal_asin_kernel (t0, t1);
    t0 = __fma_rn (t1, t0, t0);
    t0 = 2.0 * t0;
    if ((unsigned)ahi >= (unsigned)0x80000000) {    
      t0 = __fma_rn (1.0, t0, -1.2246467991473532e-16);
      t0 = 3.1415926535897931e+0 - t0;
    }
  } 
  return t0;
}

static double __cuda_acosh(double a)
{
  double t;

  if (__cuda___isnan(a)) {
    return a + a;
  }
#line 1139 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  t = a - 1.0;
  if (__cuda_fabs(t) > 4503599627370496.0) {
    
    return 6.9314718055994529e-1 + __cuda_log(a);
  } else {
    t = t + __cuda_sqrt(__fma_rn(a, t, t));
    return __cuda_log1p(t);
  }  
}

static double __cuda_asinh(double a)
{










#line 1162 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  double fa, t;
  fa = __cuda_fabs(a);
  if (fa > 1.0e153) {
    t = 6.9314718055994529e-1 + __cuda_log(fa);
  } else {
    t = fa * fa;
    t = __cuda_log1p (fa + t / (1.0 + __cuda_sqrt(1.0 + t)));
  }
#line 1171 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  return __cuda_copysign(t, a);  
}

static double __cuda_atanh(double a)
{
  double fa, t;

  if (__cuda___isnan(a)) {
    return a + a;
  }
#line 1182 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  fa = __cuda_fabs(a);
  t = (2.0 * fa) / (1.0 - fa);
  t = 0.5 * __cuda_log1p(t);

  if (__cuda___isnan(t)) {
    return t;
  }
#line 1190 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  if (__cuda___signbit(a)) {
    t = -t;
  }
  return t;
}

static double __cuda_hypot(double a, double b)
{
  double v, w, t;
  if (__cuda___isinf(a) || __cuda___isinf(b)) {
    return __longlong_as_double(0x7ff0000000000000ULL);
  }
  if (__cuda___isnan(a) || __cuda___isnan(b)) {
    return a + b;
  }
  a = __cuda_fabs(a);
  b = __cuda_fabs(b);
  v = __cuda_fmax(a, b);
  w = __cuda_fmin(a, b);
  t = w / v;
  t = __fma_rn (t, t, 1.0);
  t = v * __cuda_sqrt(t);
  if (v == 0.0) {
    t = v + w;
  }
  return t;
}

static double __cuda_cbrt(double a)
{
  float s;
  double t, r;
  int ilo, ihi, expo, nexpo, denorm;
  if ((a == 0.0) || !(__cuda___finite(a))) {
    return a + a;
  } 
  t = __cuda_fabs(a);
  ilo = __double2loint(t);
  ihi = __double2hiint(t);
  expo = ((int)((unsigned int)ihi >> 20) & 0x7ff);
  denorm = 0;
  if (expo == 0) {
    
    t = t * 18014398509481984.0;
    denorm = 18;
    ilo = __double2loint(t);
    ihi = __double2hiint(t);
    expo = ((int)((unsigned int)ihi >> 20) & 0x7ff);
  }
  
  nexpo = __float2int_rn(0.333333333f * (float)(expo - 1022));
  ihi -= (3 * nexpo) << 20;
  r = __hiloint2double(ihi, ilo);
  
  s = (float)r;
  t = __cuda_exp2f(0.333333333f * __log2f(s));
    
  t = t - (t - (r / (t * t))) * 3.3333333333333333e-1;
  t = t - (t - (r / (t * t))) * 3.3333333333333333e-1;
  
  ilo = __double2loint(t);
  ihi = __double2hiint(t);
  ihi += (nexpo - denorm) << 20;
  t = __hiloint2double(ihi, ilo);
  if (__cuda___signbit(a)) {
     t = -t;
  }
  return t;
}

static double __internal_accurate_pow(double a, double b)
{
  double2 loga;
  double2 prod;
  double t_hi, t_lo;
  double tmp;


#line 1269 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  double e;
#line 1271 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"

  
  loga = __internal_log_ext_prec(a);

  
  if (__cuda_fabs(b) > 1e304) b *= 1.220703125e-4;
  
  t_hi = loga.y * b;
  t_lo = __fma_rn (loga.y, b, -t_hi);
  t_lo = __fma_rn (loga.x, b, t_lo);
  prod.y = e = t_hi + t_lo;
  prod.x = (t_hi - e) + t_lo;

  
  tmp = __cuda_exp(prod.y);
  
  if (!__cuda___isinf(tmp)) {
    


    tmp = __fma_rn (tmp, prod.x, tmp);
  }
  return tmp;
}

static double __cuda_pow(double a, double b)
{
  int bIsOddInteger;
  double t;
  if (a == 1.0 || b == 0.0) {
    return 1.0;
  } 
  if (__cuda___isnan(a) || __cuda___isnan(b)) {
    return a + b;
  }
  if (a == __longlong_as_double(0x7ff0000000000000ULL)) {
    return __cuda___signbit(b) ?  0.0 : __longlong_as_double(0x7ff0000000000000ULL);
  }
  if (__cuda___isinf(b)) {
    if (a == -1.0) {
      return 1.0;
    }
    t = __cuda_fabs(a) > 1.0 ? __longlong_as_double(0x7ff0000000000000ULL) : 0.0;
    if (b < 0.0) {
      t = 1.0 / t;
    }
    return t;
  }
  bIsOddInteger = (b - (2.0 * __cuda_floor(0.5 * b))) == 1.0;
  if (a == 0.0) {
    t = bIsOddInteger ? a : 0.0;
    if (b < 0.0) {
      t = 1.0 / t;
    }
    return t;
  } 
  if (a == -__longlong_as_double(0x7ff0000000000000ULL)) {
    t = (b < 0.0) ? -1.0/a : -a;
    if (bIsOddInteger) {
      t = __longlong_as_double(__double_as_longlong(t)^0x8000000000000000ULL);
    }
    return t;
  } 
  if ((a < 0.0) && (b != __cuda_trunc(b))) {
    return __longlong_as_double(0xfff8000000000000ULL);
  } 
  t = __cuda_fabs(a);
  t = __internal_accurate_pow(t, b);
  if ((a < 0.0) && bIsOddInteger) {
    t = __longlong_as_double(__double_as_longlong(t) ^ 0x8000000000000000ULL); 
  }
  return t;
}

static double __cuda_erf(double a)
{
  double t, r, q;

  if (__cuda___isnan(a)) {
    return a + a;
  }
#line 1353 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  t = __cuda_fabs(a);
  if (t >= 1.0) {
    r =                 -1.28836351230756500E-019;
    r = __fma_rn (r, t,  1.30597472161093370E-017);
    r = __fma_rn (r, t, -6.33924401259620500E-016);
    r = __fma_rn (r, t,  1.96231865908940140E-014);
    r = __fma_rn (r, t, -4.35272243559990750E-013);
    r = __fma_rn (r, t,  7.37083927929352150E-012);
    r = __fma_rn (r, t, -9.91402142550461630E-011);
    r = __fma_rn (r, t,  1.08817017167760820E-009);
    r = __fma_rn (r, t, -9.93918713097634620E-009);
    r = __fma_rn (r, t,  7.66739923255145500E-008);
    r = __fma_rn (r, t, -5.05440278302806720E-007);
    r = __fma_rn (r, t,  2.87474157099000620E-006);
    r = __fma_rn (r, t, -1.42246725399722510E-005);
    r = __fma_rn (r, t,  6.16994555079419460E-005);
    r = __fma_rn (r, t, -2.36305221938908790E-004);
    r = __fma_rn (r, t,  8.05032844055371070E-004);
    r = __fma_rn (r, t, -2.45833366629108140E-003);
    r = __fma_rn (r, t,  6.78340988296706120E-003);
    r = __fma_rn (r, t, -1.70509103597554640E-002);
    r = __fma_rn (r, t,  3.93322852515666300E-002);
    r = __fma_rn (r, t, -8.37271292613764040E-002);
    r = __fma_rn (r, t,  1.64870423707623280E-001);
    r = __fma_rn (r, t, -2.99729521787681470E-001);
    r = __fma_rn (r, t,  4.99394435612628580E-001);
    r = __fma_rn (r, t, -7.52014596480123030E-001);
    r = __fma_rn (r, t,  9.99933138314926250E-001);
    r = __fma_rn (r, t, -1.12836725321102670E+000);
    r = __fma_rn (r, t,  9.99998988715182450E-001);
    q = __internal_exp_kernel(-t * t, 0);
    r = __fma_rn (r, -q, 1.0);
    if (t >= 6.5) {
      r = 1.0;
    }    
    a = __cuda_copysign (r, a);
  } else {
    q = t * t;
    r =                 -7.77946848895991420E-010;
    r = __fma_rn (r, q,  1.37109803980285950E-008);
    r = __fma_rn (r, q, -1.62063137584932240E-007);
    r = __fma_rn (r, q,  1.64471315712790040E-006);
    r = __fma_rn (r, q, -1.49247123020098620E-005);
    r = __fma_rn (r, q,  1.20552935769006260E-004);
    r = __fma_rn (r, q, -8.54832592931448980E-004);
    r = __fma_rn (r, q,  5.22397760611847340E-003);
    r = __fma_rn (r, q, -2.68661706431114690E-002);
    r = __fma_rn (r, q,  1.12837916709441850E-001);
    r = __fma_rn (r, q, -3.76126389031835210E-001);
    r = __fma_rn (r, q,  1.12837916709551260E+000);
    a = r * a;
  }
  return a;
}

static double __cuda_erfinv(double a)
{
  double fa, t;

  fa = fabs(a);
  if (fa >= 1.0) {
    t = __longlong_as_double(0xfff8000000000000ULL);          
    if (fa == 1.0) {
      t = a * __longlong_as_double(0x7ff0000000000000ULL);    
    }
  } else if (fa >= 0.9375) {
    



    double p, q;

    t = __cuda_log1p(-fa);
    t = __cuda_rsqrt(-t);
    p =                 2.7834010353747001060e-3;
    p = __fma_rn (p, t, 8.6030097526280260580e-1);
    p = __fma_rn (p, t, 2.1371214997265515515e+0);
    p = __fma_rn (p, t, 3.1598519601132090206e+0);
    p = __fma_rn (p, t, 3.5780402569085996758e+0);
    p = __fma_rn (p, t, 1.5335297523989890804e+0);
    p = __fma_rn (p, t, 3.4839207139657522572e-1);
    p = __fma_rn (p, t, 5.3644861147153648366e-2);
    p = __fma_rn (p, t, 4.3836709877126095665e-3);
    p = __fma_rn (p, t, 1.3858518113496718808e-4);
    p = __fma_rn (p, t, 1.1738352509991666680e-6);
    q =              t+ 2.2859981272422905412e+0;
    q = __fma_rn (q, t, 4.3859045256449554654e+0);
    q = __fma_rn (q, t, 4.6632960348736635331e+0);
    q = __fma_rn (q, t, 3.9846608184671757296e+0);
    q = __fma_rn (q, t, 1.6068377709719017609e+0);
    q = __fma_rn (q, t, 3.5609087305900265560e-1);
    q = __fma_rn (q, t, 5.3963550303200816744e-2);
    q = __fma_rn (q, t, 4.3873424022706935023e-3);
    q = __fma_rn (q, t, 1.3858762165532246059e-4);
    q = __fma_rn (q, t, 1.1738313872397777529e-6);
    t = p / (q * t);
    if (a < 0.0) t = -t;
  } else if (fa >= 0.75) {
   



    double p, q;

    t = __fma_rn (a, a, -.87890625);
    p =                  .21489185007307062000e+0;
    p = __fma_rn (p, t, -.64200071507209448655e+1);
    p = __fma_rn (p, t,  .29631331505876308123e+2);
    p = __fma_rn (p, t, -.47644367129787181803e+2);
    p = __fma_rn (p, t,  .34810057749357500873e+2);
    p = __fma_rn (p, t, -.12954198980646771502e+2);
    p = __fma_rn (p, t,  .25349389220714893917e+1);
    p = __fma_rn (p, t, -.24758242362823355486e+0);
    p = __fma_rn (p, t,  .94897362808681080020e-2);
    q =              t  -.12831383833953226499e+2;
    q = __fma_rn (q, t,  .41409991778428888716e+2);
    q = __fma_rn (q, t, -.53715373448862143349e+2);
    q = __fma_rn (q, t,  .33880176779595142685e+2);
    q = __fma_rn (q, t, -.11315360624238054876e+2);
    q = __fma_rn (q, t,  .20369295047216351160e+1);
    q = __fma_rn (q, t, -.18611650627372178511e+0);
    q = __fma_rn (q, t,  .67544512778850945940e-2);
    p = p / q;
    t = a * p;
  } else {
    



    double p, q;

    t = __fma_rn (a, a, -.5625);
    p =                 -.23886240104308755900e+2;
    p = __fma_rn (p, t,  .45560204272689128170e+3);
    p = __fma_rn (p, t, -.22977467176607144887e+4);
    p = __fma_rn (p, t,  .46631433533434331287e+4);
    p = __fma_rn (p, t, -.43799652308386926161e+4);
    p = __fma_rn (p, t,  .19007153590528134753e+4);
    p = __fma_rn (p, t, -.30786872642313695280e+3);
    q =         t  -.83288327901936570000e+2;
    q = __fma_rn (q, t,  .92741319160935318800e+3);
    q = __fma_rn (q, t, -.35088976383877264098e+4);
    q = __fma_rn (q, t,  .59039348134843665626e+4);
    q = __fma_rn (q, t, -.48481635430048872102e+4);
    q = __fma_rn (q, t,  .18997769186453057810e+4);
    q = __fma_rn (q, t, -.28386514725366621129e+3);
    p = p / q;
    t = a * p;
  }
  return t;
}

static double __cuda_erfcinv(double a)
{
  double t;

  if (__cuda___isnan(a)) return a + a;
#line 1511 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  if (a <= 0.0) {
    t = __longlong_as_double(0xfff8000000000000ULL);
    if (a == 0.0) {
      t = (1.0 - a) * __longlong_as_double(0x7ff0000000000000ULL);
    }
  } 
  else if (a >= 0.0625) {
    t = __cuda_erfinv (1.0 - a);
  }
  else if (a >= 1e-100) {
    



    double p, q;
    t = __cuda_log(a);
    t = __cuda_rsqrt(-t);
    p =                 2.7834010353747001060e-3;
    p = __fma_rn (p, t, 8.6030097526280260580e-1);
    p = __fma_rn (p, t, 2.1371214997265515515e+0);
    p = __fma_rn (p, t, 3.1598519601132090206e+0);
    p = __fma_rn (p, t, 3.5780402569085996758e+0);
    p = __fma_rn (p, t, 1.5335297523989890804e+0);
    p = __fma_rn (p, t, 3.4839207139657522572e-1);
    p = __fma_rn (p, t, 5.3644861147153648366e-2);
    p = __fma_rn (p, t, 4.3836709877126095665e-3);
    p = __fma_rn (p, t, 1.3858518113496718808e-4);
    p = __fma_rn (p, t, 1.1738352509991666680e-6);
    q =              t+ 2.2859981272422905412e+0;
    q = __fma_rn (q, t, 4.3859045256449554654e+0);
    q = __fma_rn (q, t, 4.6632960348736635331e+0);
    q = __fma_rn (q, t, 3.9846608184671757296e+0);
    q = __fma_rn (q, t, 1.6068377709719017609e+0);
    q = __fma_rn (q, t, 3.5609087305900265560e-1);
    q = __fma_rn (q, t, 5.3963550303200816744e-2);
    q = __fma_rn (q, t, 4.3873424022706935023e-3);
    q = __fma_rn (q, t, 1.3858762165532246059e-4);
    q = __fma_rn (q, t, 1.1738313872397777529e-6);
    t = p / (q * t);
  }
  else {
    



    double p, q;
    t = __cuda_log(a);
    t = __cuda_rsqrt(-t);
    p =                 6.9952990607058154858e-1;
    p = __fma_rn (p, t, 1.9507620287580568829e+0);
    p = __fma_rn (p, t, 8.2810030904462690216e-1);
    p = __fma_rn (p, t, 1.1279046353630280005e-1);
    p = __fma_rn (p, t, 6.0537914739162189689e-3);
    p = __fma_rn (p, t, 1.3714329569665128933e-4);
    p = __fma_rn (p, t, 1.2964481560643197452e-6);
    p = __fma_rn (p, t, 4.6156006321345332510e-9);
    p = __fma_rn (p, t, 4.5344689563209398450e-12);
    q =              t+ 1.5771922386662040546e+0;
    q = __fma_rn (q, t, 2.1238242087454993542e+0);
    q = __fma_rn (q, t, 8.4001814918178042919e-1);
    q = __fma_rn (q, t, 1.1311889334355782065e-1);
    q = __fma_rn (q, t, 6.0574830550097140404e-3);
    q = __fma_rn (q, t, 1.3715891988350205065e-4);
    q = __fma_rn (q, t, 1.2964671850944981713e-6);
    q = __fma_rn (q, t, 4.6156017600933592558e-9);
    q = __fma_rn (q, t, 4.5344687377088206783e-12);
    t = p / (q * t);
  }
  return t;
}

static double __cuda_erfc(double a)
{
  double p, q, h, l;
  int ahi;

  ahi = __double2hiint(a);
  if (ahi < (int)0x3fe80000) {  
    return 1.0 - __cuda_erf(a);
  } 
  if (a > 27.3) {
    return 0.0;
  }
  if (ahi < (int)0x40140000) {  
    
    p =                 5.6418956292134603E-001;
    p = __fma_rn (p, a, 7.9573512229784757E+000);
    p = __fma_rn (p, a, 5.4297984550299049E+001);
    p = __fma_rn (p, a, 2.2775657465890461E+002);
    p = __fma_rn (p, a, 6.2995529536738172E+002);
    p = __fma_rn (p, a, 1.1508293767713837E+003);
    p = __fma_rn (p, a, 1.3002167301542784E+003);
    p = __fma_rn (p, a, 7.2716547570180592E+002);
    q =              a+ 1.4104035812651274E+001;
    q = __fma_rn (q, a, 9.6740724349422138E+001);
    q = __fma_rn (q, a, 4.1073916054746462E+002);
    q = __fma_rn (q, a, 1.1641974580374074E+003);
    q = __fma_rn (q, a, 2.2344896486798129E+003);
    q = __fma_rn (q, a, 2.8166572432808462E+003);
    q = __fma_rn (q, a, 2.1207350981593036E+003);
    q = __fma_rn (q, a, 7.2716547619708967E+002);
    p = p / q;
    h = a * a;
    l = __fma_rn (a, a, -h);
    q = __internal_exp_kernel(-h, 0);
    q = __fma_rn (l, -q, q);
    p = p * q;
  } else {
    
    double ooa, ooasq;

    ooa = 1.0 / a;
    ooasq = ooa * ooa;
    p =                     -4.0025406686930527E+005;
    p = __fma_rn (p, ooasq,  1.4420582543942123E+005);
    p = __fma_rn (p, ooasq, -2.7664185780951841E+004);
    p = __fma_rn (p, ooasq,  4.1144611644767283E+003);
    p = __fma_rn (p, ooasq, -5.8706000519209351E+002);
    p = __fma_rn (p, ooasq,  9.1490086446323375E+001);
    p = __fma_rn (p, ooasq, -1.6659491387740221E+001);
    p = __fma_rn (p, ooasq,  3.7024804085481784E+000);
    p = __fma_rn (p, ooasq, -1.0578553994424316E+000);
    p = __fma_rn (p, ooasq,  4.2314218745087778E-001);
    p = __fma_rn (p, ooasq, -2.8209479177354962E-001);
    p = __fma_rn (p, ooasq,  5.6418958354775606E-001);
    h = a * a;
    l = __fma_rn (a, a, -h);
    q = __internal_exp_kernel(-h, 0);
    q = __fma_rn (l, -q, q);
    p = p * ooa;
    p = p * q;
  }
  return p;
}


static double __internal_tgamma_kernel(double a)
{
  double t;
  t =                 -4.42689340712524750E-010;
  t = __fma_rn (t, a, -2.02665918466589540E-007);
  t = __fma_rn (t, a,  1.13812117211195270E-006);
  t = __fma_rn (t, a, -1.25077348166307480E-006);
  t = __fma_rn (t, a, -2.01365017404087710E-005);
  t = __fma_rn (t, a,  1.28050126073544860E-004);
  t = __fma_rn (t, a, -2.15241408115274180E-004);
  t = __fma_rn (t, a, -1.16516754597046040E-003);
  t = __fma_rn (t, a,  7.21894322484663810E-003);
  t = __fma_rn (t, a, -9.62197153268626320E-003);
  t = __fma_rn (t, a, -4.21977345547223940E-002);
  t = __fma_rn (t, a,  1.66538611382503560E-001);
  t = __fma_rn (t, a, -4.20026350341054440E-002);
  t = __fma_rn (t, a, -6.55878071520257120E-001);
  t = __fma_rn (t, a,  5.77215664901532870E-001);
  t = __fma_rn (t, a,  1.00000000000000000E+000);
  return t;
}


static double __internal_stirling_poly(double a)
{
  double x = 1.0 / a;
  double z = 0.0;
  z = __fma_rn (z, x,  8.3949872067208726e-004);
  z = __fma_rn (z, x, -5.1717909082605919e-005);
  z = __fma_rn (z, x, -5.9216643735369393e-004);
  z = __fma_rn (z, x,  6.9728137583658571e-005);
  z = __fma_rn (z, x,  7.8403922172006662e-004);
  z = __fma_rn (z, x, -2.2947209362139917e-004);
  z = __fma_rn (z, x, -2.6813271604938273e-003);
  z = __fma_rn (z, x,  3.4722222222222220e-003);
  z = __fma_rn (z, x,  8.3333333333333329e-002);
  z = __fma_rn (z, x,  1.0000000000000000e+000);
  return z;
}

static double __internal_tgamma_stirling(double a)
{
  if (a < 1.7162437695630274e+002) {


#line 1693 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
    double t_hi, t_lo, e;
#line 1695 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
    double2 loga, prod;
    double z = __internal_stirling_poly (a);
    double b = a - 0.5;

    
    loga = __internal_log_ext_prec(a);

    
    t_hi = loga.y * b;
    t_lo = __fma_rn (loga.y, b, -t_hi);
    t_lo = __fma_rn (loga.x, b, t_lo);
    prod.y = e = t_hi + t_lo;
    prod.x = (t_hi - e) + t_lo;

    
    loga.y = -a;
    loga.x = 0.0;
    prod = __internal_ddadd_xgty (prod, loga);

    
    a = __cuda_exp(prod.y);
    
    if (!__cuda___isinf(a)) {
      


      a = __fma_rn (a, prod.x, a);
    }
    a = __fma_rn (a, 2.5066282746310007e+0, a * (-1.8328579980459167e-16));
    return a * z;
  } else {
    return __longlong_as_double(0x7ff0000000000000ULL);
  }
}

static double __cuda_tgamma(double a)
{
  double s, xx, x = a;
  if (__cuda___isnan(a)) {
    return a + a;
  }
  if (__cuda_fabs(x) < 15.0) {
     



    if (x >= 0.0) {
      s = 1.0;
      xx = x;
      while (xx > 1.5) {
        s = __fma_rn(s, xx, -s);
        xx = xx - 1.0;
      }
      if (x >= 0.5) {
        xx = xx - 1.0;
      }
      xx = __internal_tgamma_kernel (xx);
      if (x < 0.5) {
        xx = xx * x;
      }
      s = s / xx;
    } else {
      xx = x;
      s = xx;
      if (x == __cuda_floor(x)) {
        return __longlong_as_double(0xfff8000000000000ULL);
      }
      while (xx < -0.5) {
        s = __fma_rn (s, xx, s);
        xx = xx + 1.0;
      }
      xx = __internal_tgamma_kernel (xx);
      s = s * xx;
      s = 1.0 / s;
    }
    return s;
  } else {
    if (x >= 0.0) {
      return __internal_tgamma_stirling (x);
    } else {
      double t;
      int quot;
      if (x == __cuda_floor(x)) {
        return __longlong_as_double(0xfff8000000000000ULL);
      }
      if (x < -185.0) {
        int negative;
        x = __cuda_floor(x);
        negative = ((x - (2.0 * __cuda_floor(0.5 * x))) == 1.0);
        return negative ? __longlong_as_double(0x8000000000000000ULL) : 0.0;
      }
      
      xx = __cuda_rint (__internal_twice(x));
      quot = (int)xx;
      xx = __fma_rn (-0.5, xx, x);
      xx = xx * 3.1415926535897931e+0;
      if (quot & 1) {
        xx = __internal_cos_kerneld (xx);
      } else {
        xx = __internal_sin_kerneld (xx);
      }
      if (quot & 2) {
        xx = -xx;
      }
      x = __cuda_fabs (x);
      s = __cuda_exp (-x);
      t = x - 0.5;
      if (x > 140.0) t = __internal_half(t);
      t = __cuda_pow (x, t);
      if (x > 140.0) s = s * t;
      s = s * __internal_stirling_poly (x);
      s = s * x;
      s = s * xx;
      s = 1.0 / s;
      s = __fma_rn (s, 1.2533141373155003e+0, (-9.1642899902295834e-17) * s);
      s = s / t;
      return s;
    }
  }
}

static double __internal_lgamma_pos(double a)
{
  double sum;
  double s, t;

  if (a == __longlong_as_double(0x7ff0000000000000ULL)) {
    return a;
  }
  if (a >= 3.0) {
    if (a >= 8.0) {
      


      s = 1.0 / a;
      t = s * s;
      sum =                   -0.1633436431e-2;
      sum = __fma_rn (sum, t,  0.83645878922e-3);
      sum = __fma_rn (sum, t, -0.5951896861197e-3);
      sum = __fma_rn (sum, t,  0.793650576493454e-3);
      sum = __fma_rn (sum, t, -0.277777777735865004e-2);
      sum = __fma_rn (sum, t,  0.833333333333331018375e-1);
      sum = __fma_rn (sum, s,  0.918938533204672);
      s = __internal_half(__cuda_log (a));
      t = a - 0.5;
      s = s * t;
      t = s - a;
      s = s + sum;
      t = t + s;
      return t;
    } else {
      a = a - 3.0;
      s =                 -4.02412642744125560E+003;
      s = __fma_rn (s, a, -2.97693796998962000E+005);
      s = __fma_rn (s, a, -6.38367087682528790E+006);
      s = __fma_rn (s, a, -5.57807214576539320E+007);
      s = __fma_rn (s, a, -2.24585140671479230E+008);
      s = __fma_rn (s, a, -4.70690608529125090E+008);
      s = __fma_rn (s, a, -7.62587065363263010E+008);
      s = __fma_rn (s, a, -9.71405112477113250E+008);
      t =              a  -1.02277248359873170E+003;
      t = __fma_rn (t, a, -1.34815350617954480E+005);
      t = __fma_rn (t, a, -4.64321188814343610E+006);
      t = __fma_rn (t, a, -6.48011106025542540E+007);
      t = __fma_rn (t, a, -4.19763847787431360E+008);
      t = __fma_rn (t, a, -1.25629926018000720E+009);
      t = __fma_rn (t, a, -1.40144133846491690E+009);
      t = s / t;
      t = t + a;
      return t;
    }
  } else if (a >= 1.5) {
    a = a - 2.0;
    t =                  9.84839283076310610E-009;
    t = __fma_rn (t, a, -6.69743850483466500E-008);
    t = __fma_rn (t, a,  2.16565148880011450E-007);
    t = __fma_rn (t, a, -4.86170275781575260E-007);
    t = __fma_rn (t, a,  9.77962097401114400E-007);
    t = __fma_rn (t, a, -2.03041287574791810E-006);
    t = __fma_rn (t, a,  4.36119725805364580E-006);
    t = __fma_rn (t, a, -9.43829310866446590E-006);
    t = __fma_rn (t, a,  2.05106878496644220E-005);
    t = __fma_rn (t, a, -4.49271383742108440E-005);
    t = __fma_rn (t, a,  9.94570466342226000E-005);
    t = __fma_rn (t, a, -2.23154589559238440E-004);
    t = __fma_rn (t, a,  5.09669559149637430E-004);
    t = __fma_rn (t, a, -1.19275392649162300E-003);
    t = __fma_rn (t, a,  2.89051032936815490E-003);
    t = __fma_rn (t, a, -7.38555102806811700E-003);
    t = __fma_rn (t, a,  2.05808084278121250E-002);
    t = __fma_rn (t, a, -6.73523010532073720E-002);
    t = __fma_rn (t, a,  3.22467033424113040E-001);
    t = __fma_rn (t, a,  4.22784335098467190E-001);
    t = t * a;
    return t;
  } else if (a >= 0.7) {
    a = 1.0 - a;
    t =                 1.17786911519331130E-002;  
    t = __fma_rn (t, a, 3.89046747413522300E-002);
    t = __fma_rn (t, a, 5.90045711362049900E-002);
    t = __fma_rn (t, a, 6.02143305254344420E-002);
    t = __fma_rn (t, a, 5.61652708964839180E-002);
    t = __fma_rn (t, a, 5.75052755193461370E-002);
    t = __fma_rn (t, a, 6.21061973447320710E-002);
    t = __fma_rn (t, a, 6.67614724532521880E-002);
    t = __fma_rn (t, a, 7.14856037245421020E-002);
    t = __fma_rn (t, a, 7.69311251313347100E-002);
    t = __fma_rn (t, a, 8.33503129714946310E-002);
    t = __fma_rn (t, a, 9.09538288991182800E-002);
    t = __fma_rn (t, a, 1.00099591546322310E-001);
    t = __fma_rn (t, a, 1.11334278141734510E-001);
    t = __fma_rn (t, a, 1.25509666613462880E-001);
    t = __fma_rn (t, a, 1.44049896457704160E-001);
    t = __fma_rn (t, a, 1.69557177031481600E-001);
    t = __fma_rn (t, a, 2.07385551032182120E-001);
    t = __fma_rn (t, a, 2.70580808427600350E-001);
    t = __fma_rn (t, a, 4.00685634386517050E-001);
    t = __fma_rn (t, a, 8.22467033424113540E-001);
    t = __fma_rn (t, a, 5.77215664901532870E-001);
    t = t * a;
    return t;
  } else {
    t=                  -9.04051686831357990E-008;
    t = __fma_rn (t, a,  7.06814224969349250E-007);
    t = __fma_rn (t, a, -3.80702154637902830E-007);
    t = __fma_rn (t, a, -2.12880892189316100E-005);
    t = __fma_rn (t, a,  1.29108470307156190E-004);
    t = __fma_rn (t, a, -2.15932815215386580E-004);
    t = __fma_rn (t, a, -1.16484324388538480E-003);
    t = __fma_rn (t, a,  7.21883433044470670E-003);
    t = __fma_rn (t, a, -9.62194579514229560E-003);
    t = __fma_rn (t, a, -4.21977386992884450E-002);
    t = __fma_rn (t, a,  1.66538611813682460E-001);
    t = __fma_rn (t, a, -4.20026350606819980E-002);
    t = __fma_rn (t, a, -6.55878071519427450E-001);
    t = __fma_rn (t, a,  5.77215664901523870E-001);
    t = t * a;
    t = __fma_rn (t, a, a);
    return -__cuda_log (t);
  }
}

static double __cuda_lgamma(double a)
{
  double t;
  double i;
  long long int quot;
  if (__cuda___isnan(a)) {
    return a + a;
  }
  t = __internal_lgamma_pos(__cuda_fabs(a));
  if (a >= 0.0) return t;
  a = __cuda_fabs(a);
  i = __cuda_floor(a);       
  if (a == i) return __longlong_as_double(0x7ff0000000000000ULL); 
  if (a < 1e-19) return -__cuda_log(a);
  i = __cuda_rint (2.0 * a);
  quot = (long long int)i;
  i = __fma_rn (-0.5, i, a);
  i = i * 3.1415926535897931e+0;
  if (quot & 1) {
    i = __internal_cos_kerneld(i);
  } else {
    i = __internal_sin_kerneld(i);
  }
  i = __cuda_fabs(i);
  t = __cuda_log(3.1415926535897931e+0 / (i * a)) - t;
  return t;
}

static double __cuda_ldexp(double a, int b)
{
  double fa = __cuda_fabs (a);
  if ((fa == 0.0) || (fa == __longlong_as_double(0x7ff0000000000000ULL)) || (!(fa <= __longlong_as_double(0x7ff0000000000000ULL)))) {
    return a + a;
  }
  if (b == 0) {
    return a;
  }
  if (b >  2200) b =  2200;
  if (b < -2200) b = -2200;
  if (__cuda_abs (b) < 1022) {
    return a * __internal_exp2i_kernel(b);
  }
  if (__cuda_abs (b) < 2044) {
    int bhalf = b / 2;
    return a * __internal_exp2i_kernel (bhalf) * 
           __internal_exp2i_kernel (b - bhalf);
  } else {
    int bquarter = b / 4;
    double t = __internal_exp2i_kernel(bquarter);
    return a * t * t * t *__internal_exp2i_kernel (b - 3 * bquarter);
  }
}

static double __cuda_scalbn(double a, int b)
{
  
  return __cuda_ldexp(a, b);
}

static double __cuda_scalbln(double a, long int b)
{




#line 2003 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  return __cuda_scalbn(a, (int)b);
}

static double __cuda_frexp(double a, int *b)
{
  double fa = __cuda_fabs(a);
  unsigned int expo;
  unsigned int denorm;

  if (fa < 2.22507385850720140e-308) {
    a *= 18014398509481984.0;
    denorm = 54;
  } else {
    denorm = 0;
  }
  expo = (__double2hiint(a) >> 20) & 0x7ff;
  if ((fa == 0.0) || (expo == 0x7ff)) {
    expo = 0;
    a = a + a;
  } else {
    expo = expo - denorm - 1022;
    a = __longlong_as_double((__double_as_longlong(a) & 0x800fffffffffffffULL)|
                              0x3fe0000000000000ULL);
  }
  *b = expo;
  return a;  
}

static double __cuda_modf(double a, double *b)
{
  double t;
  if (__cuda___finite(a)) {
    t = __cuda_trunc(a);
    *b = t;
    t = a - t;
    return __cuda_copysign(t, a);
  } else if (__cuda___isinf(a)) {
    t = 0.0;
    *b = a;
    return __cuda_copysign(t, a);
  } else {
    *b = a + a; 
    return a + a;
  }  
}

static double __cuda_fmod(double a, double b)
{
  double orig_a = a;
  double orig_b = b;
  a = __cuda_fabs(a);
  b = __cuda_fabs(b);
  if (!((a <= __longlong_as_double(0x7ff0000000000000ULL)) && (b <= __longlong_as_double(0x7ff0000000000000ULL)))) {
      return orig_a + orig_b;
  }
  if (a == __longlong_as_double(0x7ff0000000000000ULL) || b == 0.0) {
    return __longlong_as_double(0xfff8000000000000ULL);
  } else if (a >= b) {
    int bhi = __double2hiint(b);
    int blo = __double2loint(b);
    int ahi = __double2hiint(a);
    double scaled_b = 0.0;
    if (b < 2.22507385850720140e-308) {
      double t = b;
      while ((t < a) && (t < 2.22507385850720140e-308)) {
        t = t + t;
      }
      bhi = __double2hiint(t);
      blo = __double2loint(t);
      scaled_b = t;
    }
    if (a >= 2.22507385850720140e-308) {
      scaled_b = __hiloint2double ((bhi & 0x000fffff)|(ahi & 0x7ff00000), blo);
    }
    if (scaled_b > a) {
      scaled_b *= 0.5;
    }
    while (scaled_b >= b) {
      if (a >= scaled_b) {
        a -= scaled_b;
      }
      scaled_b *= 0.5;
    }
    return __cuda_copysign (a, orig_a);
  } else {
    return orig_a;
  }
}

static double __cuda_remainder(double a, double b)
{
  double orig_a;
  double twoa = 0.0;
  unsigned int quot0 = 0;  
  int bhi;
  int blo;
  int ahi;
  if (__cuda___isnan(a) || __cuda___isnan(b)) {
    return a + b;
  }
  orig_a = a;
  a = __cuda_fabs(a);
  b = __cuda_fabs(b);
  if (a == __longlong_as_double(0x7ff0000000000000ULL) || b == 0.0) {
    return __longlong_as_double(0xfff8000000000000ULL);
  } else if (a >= b) {
    double scaled_b = 0.0;
    bhi = __double2hiint(b);
    blo = __double2loint(b);
    ahi = __double2hiint(a);
    if (b < 2.22507385850720140e-308) {
      double t = b;
      while ((t < a) && (t < 2.22507385850720140e-308)) {
        t = t + t;
      }
      bhi = __double2hiint(t);
      blo = __double2loint(t);
      scaled_b = t;
    }
    if (a >= 2.22507385850720140e-308) {
      scaled_b = __hiloint2double ((bhi & 0x000fffff)|(ahi & 0x7ff00000), blo);
    }
    if (scaled_b > a) {
      scaled_b *= 0.5;
    }
    while (scaled_b >= b) {
      quot0 = 0;
      if (a >= scaled_b) {
        a -= scaled_b;
        quot0 = 1;
      }
      scaled_b *= 0.5;
    }
  }
  
  twoa = a + a;
  if ((twoa > b) || ((twoa == b) && quot0)) {
    a -= b;
  }
  bhi = __double2hiint(a);
  blo = __double2loint(a);
  ahi = __double2hiint(orig_a);
  a = __hiloint2double((ahi & 0x80000000) ^ bhi, blo);
  return a;
}

static double __cuda_remquo(double a, double b, int *c)
{
  double orig_a;
  double twoa = 0.0;
  unsigned int quot = 0;  
  unsigned int sign;
  int bhi;
  int blo;
  int ahi;
  if (__cuda___isnan(a) || __cuda___isnan(b)) {
    *c = quot;
    return a + b;
  }
  orig_a = a;
  sign = 0 - (__cuda___signbit(a) != __cuda___signbit(b));
  a = __cuda_fabs(a);
  b = __cuda_fabs(b);
  if (a == __longlong_as_double(0x7ff0000000000000ULL) || b == 0.0) {
    *c = quot;
    return __longlong_as_double(0xfff8000000000000ULL);
  } else if (a >= b) {
    double scaled_b = 0.0;
    bhi = __double2hiint(b);
    blo = __double2loint(b);
    ahi = __double2hiint(a);
    if (b < 2.22507385850720140e-308) {
      double t = b;
      while ((t < a) && (t < 2.22507385850720140e-308)) {
        t = t + t;
      }
      bhi = __double2hiint(t);
      blo = __double2loint(t);
      scaled_b = t;
    }
    if (a >= 2.22507385850720140e-308) {
      scaled_b = __hiloint2double ((bhi & 0x000fffff)|(ahi & 0x7ff00000), blo);
    }
    if (scaled_b > a) {
      scaled_b *= 0.5;
    }
    while (scaled_b >= b) {
      quot <<= 1;
      if (a >= scaled_b) {
        a -= scaled_b;
        quot += 1;
      }
      scaled_b *= 0.5;
    }
  }
  
  twoa = a + a;
  if ((twoa > b) || ((twoa == b) && (quot & 1))) {
    quot++;
    a -= b;
  }
  bhi = __double2hiint(a);
  blo = __double2loint(a);
  ahi = __double2hiint(orig_a);
  a = __hiloint2double((ahi & 0x80000000) ^ bhi, blo);
  quot = quot & (~((~0)<<3));
  quot = quot ^ sign;
  quot = quot - sign;
  *c = quot;
  return a;
}

static double __cuda_nextafter(double a, double b)
{
  unsigned long long int ia;
  unsigned long long int ib;
  ia = __double_as_longlong(a);
  ib = __double_as_longlong(b);
  if (__cuda___isnan(a) || __cuda___isnan(b)) return a + b; 
  if (((ia | ib) << 1) == 0ULL) return b;
  if ((ia + ia) == 0ULL) {
    return __cuda_copysign (__longlong_as_double(0x0000000000000001ULL), b); 
  }
  if ((a < b) && (a < 0.0)) ia--;
  if ((a < b) && (a > 0.0)) ia++;
  if ((a > b) && (a < 0.0)) ia++;
  if ((a > b) && (a > 0.0)) ia--;
  a = __longlong_as_double(ia);
  return a;
}

static double __cuda_nan(const char *s)
{
  unsigned long long i = 0;
  int c;
  int ovfl = 0;
  int invld = 0;
  if (*s == '0') {
    s++;
    if ((*s == 'x') || (*s == 'X')) {
      s++; 
      while (*s == '0') s++;
      while (*s) {
        if (i > 0x0fffffffffffffffULL) {
          ovfl = 1;
        }
        c = (((*s) >= 'A') && ((*s) <= 'F')) ? (*s + 'a' - 'A') : (*s);
        if ((c >= 'a') && (c <= 'f')) { 
          c = c - 'a' + 10;
          i = i * 16 + c;
        } else if ((c >= '0') && (c <= '9')) { 
          c = c - '0';
          i = i * 16 + c;
        } else {
          invld = 1;
        }
        s++;
      }
    } else {
      while (*s == '0') s++;
      while (*s) {
        if (i > 0x1fffffffffffffffULL) {
          ovfl = 1;
        }
        c = *s;
        if ((c >= '0') && (c <= '7')) { 
          c = c - '0';
          i = i * 8 + c;
        } else {
          invld = 1; 
        }
        s++;
      }
    }
  } else {
    while (*s) {
      c = *s;
      if ((i > 1844674407370955161ULL) || 
          ((i == 1844674407370955161ULL) && (c > '5'))) {
        ovfl = 1;
      }
      if ((c >= '0') && (c <= '9')) { 
        c = c - '0';
        i = i * 10 + c;
      } else {
        invld = 1;
      }
      s++;
    }
  }
  if (ovfl) {
    i = ~0ULL;
  }
  if (invld) {
    i = 0ULL;
  }
  i = (i & 0x000fffffffffffffULL) | 0x7ff8000000000000ULL;
  return __longlong_as_double(i);
}

static double __cuda_round(double a)
{
  double fa = __cuda_fabs(a);
  if (fa > 4503599627370496.0) {
    return a;
  } else {
    double u = __cuda_floor(fa + 0.5);
    if (fa < 0.5) u = 0;
    return __cuda_copysign(u, a);
  }
}

static long long int __cuda_llround(double a)
{

  if (a >=  9223372036854775807.0) return 0x7fffffffffffffffLL;
  if (a <= -9223372036854775808.0) return 0x8000000000000000LL;
#line 2321 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  return (long long int)(__cuda_round(a));
}

static long int __cuda_lround(double a)
{


#line 2329 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"

  if (__cuda___isnan(a))  return 0x80000000L;
  if (a >=  2147483647.0) return 0x7fffffffL;
  if (a <= -2147483648.0) return 0x80000000L;
#line 2334 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
  return (long int)(__cuda_round(a));
#line 2336 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"
}

static double __cuda_fdim(double a, double b)
{
  double t;
  t = a - b;    
  if (a <= b) {
    t = 0.0;
  }
  return t;
}

static int __cuda_ilogb(double a)
{
  unsigned long long int i;
  unsigned int ihi;
  unsigned int ilo;
  if (__cuda___isnan(a)) return -((int)((unsigned int)-1 >> 1))-1;
  if (__cuda___isinf(a)) return ((int)((unsigned int)-1 >> 1));
  if (a == 0.0) return -((int)((unsigned int)-1 >> 1))-1;
  a = __cuda_fabs(a);
  ilo = __double2loint(a);
  ihi = __double2hiint(a);
  i = ((unsigned long long int)ihi) << 32 | (unsigned long long int)ilo;
  if (a >= 2.22507385850720140e-308) {
    return ((int)((ihi >> 20) & 0x7ff)) - 1023;
  } else {
    int expo = -1022;
    while (i < 0x0010000000000000ULL) {
      expo--;
      i = i + i;
    }
    return expo;
  }
}

static double __cuda_logb(double a)
{
  unsigned long long int i;
  unsigned int ihi;
  unsigned int ilo;
  if (__cuda___isnan(a)) return a + a;
  a = __cuda_fabs(a);
  if (a == __longlong_as_double(0x7ff0000000000000ULL)) return a;
  if (a == 0.0) return -__longlong_as_double(0x7ff0000000000000ULL);
  ilo = __double2loint(a);
  ihi = __double2hiint(a);
  i = ((unsigned long long int)ihi) << 32 | (unsigned long long int)ilo;
  if (a >= 2.22507385850720140e-308) {
    return (double)((int)((ihi >> 20) & 0x7ff)) - 1023;
  } else {
    int expo = -1022;
    while (i < 0x0010000000000000ULL) {
      expo--;
      i = i + i;
    }
    return (double)expo;
  }
}

static double __cuda_fma(double a, double b, double c)
{
  return __fma_rn(a, b, c);
}











#line 2412 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"

#line 2414 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"

#line 2416 "c:\\cuda\\include\\math_functions_dbl_ptx3.h"

#line 3870 "c:\\cuda\\include\\math_functions.h"

#line 3872 "c:\\cuda\\include\\math_functions.h"

#line 3874 "c:\\cuda\\include\\math_functions.h"

#line 94 "C:\\CUDA\\bin64/../include\\common_functions.h"

#line 96 "C:\\CUDA\\bin64/../include\\common_functions.h"

#line 275 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"

#line 277 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"



















#pragma warning(disable: 4099)

#line 299 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"

#line 301 "C:\\CUDA\\bin64/../include\\crt/host_runtime.h"
#line 6 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"



#line 10 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"
struct __T20 {int *__par0;int *__par1;int *__par2;int __par3;int *__par4;int __dummy_field;};



#line 15 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"
struct __T21 {float *__par0;float *__par1;int *__par2;int *__par3;float *__par4;float *__par5;float *__par6;float *__par7;int *__par8;int *__par9;int *__par10;int __par11;int __par12;int __par13;float __par14;int __dummy_field;};



#line 20 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"
struct __T22 {float *__par0;float *__par1;int *__par2;int *__par3;float *__par4;float *__par5;float *__par6;float *__par7;int *__par8;int *__par9;int *__par10;int __par11;int __par12;int __par13;int __par14;int __par15;int __dummy_field;};
static void __sti____cudaRegisterAll_20_CUDA_kernels_cpp1_ii_1e5c49c2(void);
#pragma section(".CRT$XCU",read,write)
__declspec(allocate(".CRT$XCU"))static void (__cdecl *__dummy_static_init__sti____cudaRegisterAll_20_CUDA_kernels_cpp1_ii_1e5c49c2[])(void) = {__sti____cudaRegisterAll_20_CUDA_kernels_cpp1_ii_1e5c49c2};
void __device_stub__Z13run_reductionPiS_S_iS_(int *__par0, int *__par1, int *__par2, int __par3, int *__par4){auto struct __T20 *__T23;
*(void**)(void*)&__T23 = (void*)0;if (cudaSetupArgument((void*)(char*)&__par0, sizeof(__par0), (size_t)&__T23->__par0) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par1, sizeof(__par1), (size_t)&__T23->__par1) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par2, sizeof(__par2), (size_t)&__T23->__par2) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par3, sizeof(__par3), (size_t)&__T23->__par3) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par4, sizeof(__par4), (size_t)&__T23->__par4) != cudaSuccess) return;{ volatile static char *__f; __f = ((char *)((void ( *)(int *, int *, int *, int, int *))run_reduction__entry)); (void)cudaLaunch(((char *)((void ( *)(int *, int *, int *, int, int *))run_reduction__entry))); };}

}
void run_reduction__entry( int *__cuda_0,int *__cuda_1,int *__cuda_2,int __cuda_3,int *__cuda_4)
{__device_stub__Z13run_reductionPiS_S_iS_( __cuda_0,__cuda_1,__cuda_2,__cuda_3,__cuda_4);}
extern "C"{
#line 32 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"
void __device_stub__Z7FIMCudaPfS_PiS0_S_S_S_S_S0_S0_S0_iiif(float *__par0, float *__par1, int *__par2, int *__par3, float *__par4, float *__par5, float *__par6, float *__par7, int *__par8, int *__par9, int *__par10, int __par11, int __par12, int __par13, float __par14){auto struct __T21 *__T24;
*(void**)(void*)&__T24 = (void*)0;if (cudaSetupArgument((void*)(char*)&__par0, sizeof(__par0), (size_t)&__T24->__par0) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par1, sizeof(__par1), (size_t)&__T24->__par1) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par2, sizeof(__par2), (size_t)&__T24->__par2) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par3, sizeof(__par3), (size_t)&__T24->__par3) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par4, sizeof(__par4), (size_t)&__T24->__par4) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par5, sizeof(__par5), (size_t)&__T24->__par5) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par6, sizeof(__par6), (size_t)&__T24->__par6) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par7, sizeof(__par7), (size_t)&__T24->__par7) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par8, sizeof(__par8), (size_t)&__T24->__par8) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par9, sizeof(__par9), (size_t)&__T24->__par9) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par10, sizeof(__par10), (size_t)&__T24->__par10) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par11, sizeof(__par11), (size_t)&__T24->__par11) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par12, sizeof(__par12), (size_t)&__T24->__par12) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par13, sizeof(__par13), (size_t)&__T24->__par13) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par14, sizeof(__par14), (size_t)&__T24->__par14) != cudaSuccess) return;{ volatile static char *__f; __f = ((char *)((void ( *)(float *, float *, int *, int *, float *, float *, float *, float *, int *, int *, int *, int, int, int, float))FIMCuda__entry)); (void)cudaLaunch(((char *)((void ( *)(float *, float *, int *, int *, float *, float *, float *, float *, int *, int *, int *, int, int, int, float))FIMCuda__entry))); };}

}
void FIMCuda__entry( float *__cuda_0,float *__cuda_1,int *__cuda_2,int *__cuda_3,float *__cuda_4,float *__cuda_5,float *__cuda_6,float *__cuda_7,int *__cuda_8,int *__cuda_9,int *__cuda_10,int __cuda_11,int __cuda_12,int __cuda_13,float __cuda_14)
{__device_stub__Z7FIMCudaPfS_PiS0_S_S_S_S_S0_S0_S0_iiif( __cuda_0,__cuda_1,__cuda_2,__cuda_3,__cuda_4,__cuda_5,__cuda_6,__cuda_7,__cuda_8,__cuda_9,__cuda_10,__cuda_11,__cuda_12,__cuda_13,__cuda_14);}
extern "C"{
#line 40 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"
void __device_stub__Z18run_check_neighborPfS_PiS0_S_S_S_S_S0_S0_S0_iiiii(float *__par0, float *__par1, int *__par2, int *__par3, float *__par4, float *__par5, float *__par6, float *__par7, int *__par8, int *__par9, int *__par10, int __par11, int __par12, int __par13, int __par14, int __par15){auto struct __T22 *__T25;
*(void**)(void*)&__T25 = (void*)0;if (cudaSetupArgument((void*)(char*)&__par0, sizeof(__par0), (size_t)&__T25->__par0) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par1, sizeof(__par1), (size_t)&__T25->__par1) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par2, sizeof(__par2), (size_t)&__T25->__par2) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par3, sizeof(__par3), (size_t)&__T25->__par3) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par4, sizeof(__par4), (size_t)&__T25->__par4) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par5, sizeof(__par5), (size_t)&__T25->__par5) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par6, sizeof(__par6), (size_t)&__T25->__par6) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par7, sizeof(__par7), (size_t)&__T25->__par7) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par8, sizeof(__par8), (size_t)&__T25->__par8) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par9, sizeof(__par9), (size_t)&__T25->__par9) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par10, sizeof(__par10), (size_t)&__T25->__par10) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par11, sizeof(__par11), (size_t)&__T25->__par11) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par12, sizeof(__par12), (size_t)&__T25->__par12) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par13, sizeof(__par13), (size_t)&__T25->__par13) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par14, sizeof(__par14), (size_t)&__T25->__par14) != cudaSuccess) return;if (cudaSetupArgument((void*)(char*)&__par15, sizeof(__par15), (size_t)&__T25->__par15) != cudaSuccess) return;{ volatile static char *__f; __f = ((char *)((void ( *)(float *, float *, int *, int *, float *, float *, float *, float *, int *, int *, int *, int, int, int, int, int))run_check_neighbor__entry)); (void)cudaLaunch(((char *)((void ( *)(float *, float *, int *, int *, float *, float *, float *, float *, int *, int *, int *, int, int, int, int, int))run_check_neighbor__entry))); };}

}
void run_check_neighbor__entry( float *__cuda_0,float *__cuda_1,int *__cuda_2,int *__cuda_3,float *__cuda_4,float *__cuda_5,float *__cuda_6,float *__cuda_7,int *__cuda_8,int *__cuda_9,int *__cuda_10,int __cuda_11,int __cuda_12,int __cuda_13,int __cuda_14,int __cuda_15)
{__device_stub__Z18run_check_neighborPfS_PiS0_S_S_S_S_S0_S0_S0_iiiii( __cuda_0,__cuda_1,__cuda_2,__cuda_3,__cuda_4,__cuda_5,__cuda_6,__cuda_7,__cuda_8,__cuda_9,__cuda_10,__cuda_11,__cuda_12,__cuda_13,__cuda_14,__cuda_15);}
extern "C"{
#line 48 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"








#line 57 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"








#line 66 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"








#line 75 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"
static void __sti____cudaRegisterAll_20_CUDA_kernels_cpp1_ii_1e5c49c2(void){__cudaFatCubinHandle = __cudaRegisterFatBinary((void*)(&__fatDeviceText)); atexit(__cudaUnregisterBinaryUtil);__cudaRegisterFunction(__cudaFatCubinHandle, (const char*)((void ( *)(float *, float *, int *, int *, float *, float *, float *, float *, int *, int *, int *, int, int, int, int, int))run_check_neighbor__entry), (char*)"_Z18run_check_neighborPfS_PiS0_S_S_S_S_S0_S0_S0_iiiii", "_Z18run_check_neighborPfS_PiS0_S_S_S_S_S0_S0_S0_iiiii", (-1), (uint3*)0, (uint3*)0, (dim3*)0, (dim3*)0, (int*)0);__cudaRegisterFunction(__cudaFatCubinHandle, (const char*)((void ( *)(float *, float *, int *, int *, float *, float *, float *, float *, int *, int *, int *, int, int, int, float))FIMCuda__entry), (char*)"_Z7FIMCudaPfS_PiS0_S_S_S_S_S0_S0_S0_iiif", "_Z7FIMCudaPfS_PiS0_S_S_S_S_S0_S0_S0_iiif", (-1), (uint3*)0, (uint3*)0, (dim3*)0, (dim3*)0, (int*)0);__cudaRegisterFunction(__cudaFatCubinHandle, (const char*)((void ( *)(int *, int *, int *, int, int *))run_reduction__entry), (char*)"_Z13run_reductionPiS_S_iS_", "_Z13run_reductionPiS_S_iS_", (-1), (uint3*)0, (uint3*)0, (dim3*)0, (dim3*)0, (int*)0);__cudaRegisterShared(__cudaFatCubinHandle, (void**)"s_array");__cudaRegisterShared(__cudaFatCubinHandle, (void**)"s_run_check_neghbor_array");}

}
#line 79 "d:\\lab2\\fim\\meshfim_cuda_partition_color_square_modifiedb_modifieddatastucture_globalco\\meshfim_cuda\\CUDA_kernels.cudafe1.stub.c"
#line 807 "d:/Lab2/FIM/meshFIM_CUDA_partition_color_square_ModifiedB_modifiedDatastucture_globalCo/meshFIM_CUDA//CUDA_kernels.cu"

